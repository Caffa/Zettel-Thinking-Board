<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 80f37e1a-9b15-49a1-852b-11b0683bd5d9 (2026-02-03 09:09Z) -->

# Plugin note processing optimization (2026-02-03 09:09Z)

_**User**_

Help me improve the performance of this plugin by adjusting how we do the calculation of which notes should be processed first when doing a chain or run everything. If a path does not have any AI, process that path first to get the output out early e.g. python node paths. Example: Given the choice between three next nodes, if two are AI and one is Python, you should run the Python one first. 

Check if there is a bug causing occassional flickering of the canvas.

---

_**Agent (model default, mode Agent)**_


Improving processing order (prioritize non-AI paths) and checking for canvas flicker. Exploring how the chain/run-everything logic and canvas updates work.


---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Where is the order of nodes calculated for chain or run everything?",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 440,
            "column": 1
          },
          "endPosition": {
            "line": 472,
            "column": 104
          }
        },
        "contents": "/** Run chain from roots to the given node. */\nexport async function runChain(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst roots = getRootIds(data);\n\tconst rootsReachingCurrent = roots.filter((r) =&gt; canReach(data, r, nodeId));\n\tif (rootsReachingCurrent.length === 0) return { ok: false, message: \"No root reaches this node.\" };\n\tconst order = topologicalOrderToTarget(data, nodeId);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\ttry {\n\t\tfor (const nid of order) {\n\t\t\ttry {\n\t\t\t\tsetRunningNodeId(canvasKey, nid);\n\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);\n\t\t\t} finally {\n\t\t\t\tsetRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t}\n}\n\n/** Remove the Green output node and its output edge for a given source node; mutates data and saves. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run chain from roots to the given node. */",
            "lineNumber": 443
          },
          {
            "text": "export async function runChain(",
            "lineNumber": 444,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 445,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 446,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 447,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 448,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 449,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 450,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 451
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 452
          },
          {
            "text": "\tconst roots = getRootIds(data);",
            "lineNumber": 453
          },
          {
            "text": "\tconst rootsReachingCurrent = roots.filter((r) =&gt; canReach(data, r, nodeId));",
            "lineNumber": 454
          },
          {
            "text": "\tif (rootsReachingCurrent.length === 0) return { ok: false, message: \"No root reaches this node.\" };",
            "lineNumber": 455
          },
          {
            "text": "\tconst order = topologicalOrderToTarget(data, nodeId);",
            "lineNumber": 456
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 457
          },
          {
            "text": "\ttry {",
            "lineNumber": 458
          },
          {
            "text": "\t\tfor (const nid of order) {",
            "lineNumber": 459
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 460
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, nid);",
            "lineNumber": 461
          },
          {
            "text": "\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);",
            "lineNumber": 462
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 463
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 464
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 465
          },
          {
            "text": "\t\t}",
            "lineNumber": 466
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 467
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 468
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 469
          },
          {
            "text": "\t}",
            "lineNumber": 470
          },
          {
            "text": "}",
            "lineNumber": 471,
            "isSignature": true
          },
          {
            "lineNumber": 472
          },
          {
            "text": "/** Remove the Green output node and its output edge for a given source node; mutates data and saves. */",
            "lineNumber": 473
          }
        ]
      },
      "score": 0.370586633682251
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 88,
            "column": 1
          },
          "endPosition": {
            "line": 122,
            "column": 93
          }
        },
        "contents": "function topologicalSort(\n\tdata: CanvasData,\n\texecEdges: CanvasEdgeData[],\n\tnodeIds: Set&lt;string&gt;\n): string[] {\n\tconst inDegree = new Map&lt;string, number&gt;();\n\tfor (const id of nodeIds) inDegree.set(id, 0);\n\tfor (const e of execEdges) {\n\t\tif (nodeIds.has(e.fromNode) &amp;&amp; nodeIds.has(e.toNode)) {\n\t\t\tinDegree.set(e.toNode, (inDegree.get(e.toNode) ?? 0) + 1);\n\t\t}\n\t}\n\tconst order: string[] = [];\n\tconst queue = [...nodeIds].filter((id) =&gt; inDegree.get(id) === 0).sort((a, b) =&gt; {\n\t\tconst na = getNodeById(data, a);\n\t\tconst nb = getNodeById(data, b);\n\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);\n\t});\n\twhile (queue.length &gt; 0) {\n\t\tconst id = queue.shift()!;\n\t\torder.push(id);\n\t\tfor (const e of execEdges) {\n\t\t\tif (e.fromNode === id &amp;&amp; nodeIds.has(e.toNode)) {\n\t\t\t\tconst d = (inDegree.get(e.toNode) ?? 0) - 1;\n\t\t\t\tinDegree.set(e.toNode, d);\n\t\t\t\tif (d === 0) queue.push(e.toNode);\n\t\t\t}\n\t\t}\n\t}\n\treturn order;\n}\n\n/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function topologicalSort(",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 92,
            "isSignature": true
          },
          {
            "text": "\texecEdges: CanvasEdgeData[],",
            "lineNumber": 93,
            "isSignature": true
          },
          {
            "text": "\tnodeIds: Set&lt;string&gt;",
            "lineNumber": 94,
            "isSignature": true
          },
          {
            "text": "): string[] {",
            "lineNumber": 95,
            "isSignature": true
          },
          {
            "text": "\tconst inDegree = new Map&lt;string, number&gt;();",
            "lineNumber": 96
          },
          {
            "text": "\tfor (const id of nodeIds) inDegree.set(id, 0);",
            "lineNumber": 97
          },
          {
            "text": "\tfor (const e of execEdges) {",
            "lineNumber": 98
          },
          {
            "text": "\t\tif (nodeIds.has(e.fromNode) &amp;&amp; nodeIds.has(e.toNode)) {",
            "lineNumber": 99
          },
          {
            "text": "\t\t\tinDegree.set(e.toNode, (inDegree.get(e.toNode) ?? 0) + 1);",
            "lineNumber": 100
          },
          {
            "text": "\t\t}",
            "lineNumber": 101
          },
          {
            "text": "\t}",
            "lineNumber": 102
          },
          {
            "text": "\tconst order: string[] = [];",
            "lineNumber": 103
          },
          {
            "text": "\tconst queue = [...nodeIds].filter((id) =&gt; inDegree.get(id) === 0).sort((a, b) =&gt; {",
            "lineNumber": 104
          },
          {
            "text": "\t\tconst na = getNodeById(data, a);",
            "lineNumber": 105
          },
          {
            "text": "\t\tconst nb = getNodeById(data, b);",
            "lineNumber": 106
          },
          {
            "text": "\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);",
            "lineNumber": 107
          },
          {
            "text": "\t});",
            "lineNumber": 108
          },
          {
            "text": "\twhile (queue.length &gt; 0) {",
            "lineNumber": 109
          },
          {
            "text": "\t\tconst id = queue.shift()!;",
            "lineNumber": 110
          },
          {
            "text": "\t\torder.push(id);",
            "lineNumber": 111
          },
          {
            "text": "\t\tfor (const e of execEdges) {",
            "lineNumber": 112
          },
          {
            "text": "\t\t\tif (e.fromNode === id &amp;&amp; nodeIds.has(e.toNode)) {",
            "lineNumber": 113
          },
          {
            "text": "\t\t\t\tconst d = (inDegree.get(e.toNode) ?? 0) - 1;",
            "lineNumber": 114
          },
          {
            "text": "\t\t\t\tinDegree.set(e.toNode, d);",
            "lineNumber": 115
          },
          {
            "text": "\t\t\t\tif (d === 0) queue.push(e.toNode);",
            "lineNumber": 116
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 117
          },
          {
            "text": "\t\t}",
            "lineNumber": 118
          },
          {
            "text": "\t}",
            "lineNumber": 119
          },
          {
            "text": "\treturn order;",
            "lineNumber": 120
          },
          {
            "text": "}",
            "lineNumber": 121,
            "isSignature": true
          },
          {
            "lineNumber": 122
          },
          {
            "text": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
            "lineNumber": 123
          }
        ]
      },
      "score": 0.3617713451385498
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 69,
            "column": 1
          },
          "endPosition": {
            "line": 120,
            "column": 1
          }
        },
        "contents": "/** Topological order of all nodes reachable from any root (ignores output edges). */\nfunction topologicalOrderFull(data: CanvasData): string[] {\n\tconst roots = getRootIds(data);\n\tconst execEdges = data.edges.filter((e) =&gt; !isOutputEdge(e));\n\tconst nodeIds = new Set&lt;string&gt;();\n\tfor (const rootId of roots) {\n\t\tconst stack = [rootId];\n\t\twhile (stack.length &gt; 0) {\n\t\t\tconst id = stack.pop()!;\n\t\t\tif (nodeIds.has(id)) continue;\n\t\t\tnodeIds.add(id);\n\t\t\tfor (const e of execEdges) {\n\t\t\t\tif (e.fromNode === id) stack.push(e.toNode);\n\t\t\t}\n\t\t}\n\t}\n\treturn topologicalSort(data, execEdges, nodeIds);\n}\n\nfunction topologicalSort(\n\tdata: CanvasData,\n\texecEdges: CanvasEdgeData[],\n\tnodeIds: Set&lt;string&gt;\n): string[] {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Topological order of all nodes reachable from any root (ignores output edges). */",
            "lineNumber": 72
          },
          {
            "text": "function topologicalOrderFull(data: CanvasData): string[] {",
            "lineNumber": 73,
            "isSignature": true
          },
          {
            "text": "\tconst roots = getRootIds(data);",
            "lineNumber": 74
          },
          {
            "text": "\tconst execEdges = data.edges.filter((e) =&gt; !isOutputEdge(e));",
            "lineNumber": 75
          },
          {
            "text": "\tconst nodeIds = new Set&lt;string&gt;();",
            "lineNumber": 76
          },
          {
            "text": "\tfor (const rootId of roots) {",
            "lineNumber": 77
          },
          {
            "text": "\t\tconst stack = [rootId];",
            "lineNumber": 78
          },
          {
            "text": "\t\twhile (stack.length &gt; 0) {",
            "lineNumber": 79
          },
          {
            "text": "\t\t\tconst id = stack.pop()!;",
            "lineNumber": 80
          },
          {
            "text": "\t\t\tif (nodeIds.has(id)) continue;",
            "lineNumber": 81
          },
          {
            "text": "\t\t\tnodeIds.add(id);",
            "lineNumber": 82
          },
          {
            "text": "\t\t\tfor (const e of execEdges) {",
            "lineNumber": 83
          },
          {
            "text": "\t\t\t\tif (e.fromNode === id) stack.push(e.toNode);",
            "lineNumber": 84
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 85
          },
          {
            "text": "\t\t}",
            "lineNumber": 86
          },
          {
            "text": "\t}",
            "lineNumber": 87
          },
          {
            "text": "\treturn topologicalSort(data, execEdges, nodeIds);",
            "lineNumber": 88
          },
          {
            "text": "}",
            "lineNumber": 89,
            "isSignature": true
          },
          {
            "lineNumber": 90
          },
          {
            "text": "function topologicalSort(",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 92,
            "isSignature": true
          },
          {
            "text": "\texecEdges: CanvasEdgeData[],",
            "lineNumber": 93,
            "isSignature": true
          },
          {
            "text": "\tnodeIds: Set&lt;string&gt;",
            "lineNumber": 94,
            "isSignature": true
          },
          {
            "text": "): string[] {",
            "lineNumber": 95,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 96
          },
          {
            "text": "}",
            "lineNumber": 121,
            "isSignature": true
          }
        ]
      },
      "score": 0.35834193229675293
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 381,
            "column": 1
          },
          "endPosition": {
            "line": 440,
            "column": 1
          }
        },
        "contents": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */\nexport async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return { ok: false, message: \"Node not found.\" };\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };\n\tconst parentIds = getParentIdsSortedByY(nodeId, data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tfor (const pid of parentIds) {\n\t\tif (getNodeResult(canvasKey, pid) == null) {\n\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);\n\t\t}\n\t}\n\ttry {\n\t\tsetRunningNodeId(canvasKey, nodeId);\n\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t} finally {\n\t\tsetRunningNodeId(canvasKey, null);\n\t}\n}\n\n/** Run all nodes reachable from any root, in topological order. */\nexport async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 384
          },
          {
            "text": "export async function runNode(",
            "lineNumber": 385,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 386,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 387,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 388,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 389,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 390,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 391,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 392
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 393
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 394
          },
          {
            "text": "\tif (!node) return { ok: false, message: \"Node not found.\" };",
            "lineNumber": 395
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 396
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 397
          },
          {
            "text": "\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };",
            "lineNumber": 398
          },
          {
            "text": "\tconst parentIds = getParentIdsSortedByY(nodeId, data);",
            "lineNumber": 399
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 400
          },
          {
            "text": "\tfor (const pid of parentIds) {",
            "lineNumber": 401
          },
          {
            "text": "\t\tif (getNodeResult(canvasKey, pid) == null) {",
            "lineNumber": 402
          },
          {
            "text": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);",
            "lineNumber": 403
          },
          {
            "text": "\t\t}",
            "lineNumber": 404
          },
          {
            "text": "\t}",
            "lineNumber": 405
          },
          {
            "text": "\ttry {",
            "lineNumber": 406
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, nodeId);",
            "lineNumber": 407
          },
          {
            "text": "\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);",
            "lineNumber": 408
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 409
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 410
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 411
          },
          {
            "text": "\t} finally {",
            "lineNumber": 412
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 413
          },
          {
            "text": "\t}",
            "lineNumber": 414
          },
          {
            "text": "}",
            "lineNumber": 415,
            "isSignature": true
          },
          {
            "lineNumber": 416
          },
          {
            "text": "/** Run all nodes reachable from any root, in topological order. */",
            "lineNumber": 417
          },
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 418,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 419,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 420,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 421,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 422,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 423,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 424
          },
          {
            "text": "}",
            "lineNumber": 441,
            "isSignature": true
          }
        ]
      },
      "score": 0.3524476885795593
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 414,
            "column": 1
          },
          "endPosition": {
            "line": 470,
            "column": 1
          }
        },
        "contents": "/** Run all nodes reachable from any root, in topological order. */\nexport async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst order = topologicalOrderFull(data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\ttry {\n\t\tfor (const nid of order) {\n\t\t\ttry {\n\t\t\t\tsetRunningNodeId(canvasKey, nid);\n\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);\n\t\t\t} finally {\n\t\t\t\tsetRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t}\n}\n\n/** Run chain from roots to the given node. */\nexport async function runChain(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run all nodes reachable from any root, in topological order. */",
            "lineNumber": 417
          },
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 418,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 419,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 420,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 421,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 422,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 423,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 424
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 425
          },
          {
            "text": "\tconst order = topologicalOrderFull(data);",
            "lineNumber": 426
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 427
          },
          {
            "text": "\ttry {",
            "lineNumber": 428
          },
          {
            "text": "\t\tfor (const nid of order) {",
            "lineNumber": 429
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 430
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, nid);",
            "lineNumber": 431
          },
          {
            "text": "\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);",
            "lineNumber": 432
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 433
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 434
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 435
          },
          {
            "text": "\t\t}",
            "lineNumber": 436
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 437
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 438
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 439
          },
          {
            "text": "\t}",
            "lineNumber": 440
          },
          {
            "text": "}",
            "lineNumber": 441,
            "isSignature": true
          },
          {
            "lineNumber": 442
          },
          {
            "text": "/** Run chain from roots to the given node. */",
            "lineNumber": 443
          },
          {
            "text": "export async function runChain(",
            "lineNumber": 444,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 445,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 446,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 447,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 448,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 449,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 450,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 451
          },
          {
            "text": "}",
            "lineNumber": 471,
            "isSignature": true
          }
        ]
      },
      "score": 0.3432654142379761
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 161
          },
          "endPosition": {
            "line": 247,
            "column": 1
          }
        },
        "contents": "async function updateEdgeLabelsAndSave(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tedgeModes: Map&lt;string, EdgeInputMode&gt;,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\n}\n\n/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */\nasync function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return \"\";\n\tconst role = getNodeRole(node, settings);\n\tif (!role || role === \"yellow\" || role === \"green\") {\n\t\t// Yellow: pass-through (use node content as result)\n\t\tif (role === \"yellow\") {\n\t\t\tconst content = await getNodeContent(node, app.vault);\n\t\t\tsetNodeResult(canvasKey, nodeId, content);\n\t\t\treturn content;\n\t\t}\n\t\treturn \"\";\n\t}\n\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\tconst nodeInput = await getNodeContent(node, app.vault);\n\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(\n\t\tcanvasKey,\n\t\tnodeInput,\n\t\tincoming\n\t);\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"purple\") {\n\t\tconst model = settings.ollamaPurpleModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"blue\") {\n\t\tconst kernel = getKernelForCanvas;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "async function updateEdgeLabelsAndSave(",
            "lineNumber": 162,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 163,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 164,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 165,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 166,
            "isSignature": true
          },
          {
            "text": "\tedgeModes: Map&lt;string, EdgeInputMode&gt;,",
            "lineNumber": 167,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 168,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 169,
            "isSignature": true
          },
          {
            "lineNumber": 188
          },
          {
            "text": "}",
            "lineNumber": 189,
            "isSignature": true
          },
          {
            "lineNumber": 190
          },
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 191
          },
          {
            "text": "async function runSingleNode(",
            "lineNumber": 192,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 195,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 196,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 197,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 198,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 199,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 200,
            "isSignature": true
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 201
          },
          {
            "text": "\tif (!node) return \"\";",
            "lineNumber": 202
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 203
          },
          {
            "text": "\tif (!role || role === \"yellow\" || role === \"green\") {",
            "lineNumber": 204
          },
          {
            "text": "\t\t// Yellow: pass-through (use node content as result)",
            "lineNumber": 205
          },
          {
            "text": "\t\tif (role === \"yellow\") {",
            "lineNumber": 206
          },
          {
            "text": "\t\t\tconst content = await getNodeContent(node, app.vault);",
            "lineNumber": 207
          },
          {
            "text": "\t\t\tsetNodeResult(canvasKey, nodeId, content);",
            "lineNumber": 208
          },
          {
            "text": "\t\t\treturn content;",
            "lineNumber": 209
          },
          {
            "text": "\t\t}",
            "lineNumber": 210
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 211
          },
          {
            "text": "\t}",
            "lineNumber": 212
          },
          {
            "text": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 213
          },
          {
            "text": "\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 214
          },
          {
            "text": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(",
            "lineNumber": 215
          },
          {
            "text": "\t\tcanvasKey,",
            "lineNumber": 216
          },
          {
            "text": "\t\tnodeInput,",
            "lineNumber": 217
          },
          {
            "text": "\t\tincoming",
            "lineNumber": 218
          },
          {
            "text": "\t);",
            "lineNumber": 219
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 220
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 221
          },
          {
            "lineNumber": 222
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 223
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 224
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 225
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 226
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 227
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 228
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 229
          },
          {
            "text": "\t}",
            "lineNumber": 230
          },
          {
            "text": "\tif (role === \"purple\") {",
            "lineNumber": 231
          },
          {
            "text": "\t\tconst model = settings.ollamaPurpleModel || \"llama2\";",
            "lineNumber": 232
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 233
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 234
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 235
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 236
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 237
          },
          {
            "text": "\t}",
            "lineNumber": 238
          },
          {
            "text": "\tif (role === \"blue\") {",
            "lineNumber": 239
          },
          {
            "text": "\t\tconst kernel = getKernelForCanvas;",
            "lineNumber": 240
          },
          {
            "text": "}",
            "lineNumber": 248,
            "isSignature": true
          }
        ]
      },
      "score": 0.3135577440261841
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 53,
            "column": 1
          },
          "endPosition": {
            "line": 71,
            "column": 85
          }
        },
        "contents": "/** Topological order of node ids (only nodes that are ancestors of target; ignores output edges). */\nfunction topologicalOrderToTarget(data: CanvasData, targetId: string): string[] {\n\tconst execEdges = data.edges.filter((e) =&gt; !isOutputEdge(e));\n\tconst nodeIds = new Set&lt;string&gt;();\n\tconst stack = [targetId];\n\twhile (stack.length &gt; 0) {\n\t\tconst id = stack.pop()!;\n\t\tif (nodeIds.has(id)) continue;\n\t\tnodeIds.add(id);\n\t\tfor (const e of execEdges) {\n\t\t\tif (e.toNode === id) stack.push(e.fromNode);\n\t\t}\n\t}\n\treturn topologicalSort(data, execEdges, nodeIds);\n}\n\n/** Topological order of all nodes reachable from any root (ignores output edges). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Topological order of node ids (only nodes that are ancestors of target; ignores output edges). */",
            "lineNumber": 56
          },
          {
            "text": "function topologicalOrderToTarget(data: CanvasData, targetId: string): string[] {",
            "lineNumber": 57,
            "isSignature": true
          },
          {
            "text": "\tconst execEdges = data.edges.filter((e) =&gt; !isOutputEdge(e));",
            "lineNumber": 58
          },
          {
            "text": "\tconst nodeIds = new Set&lt;string&gt;();",
            "lineNumber": 59
          },
          {
            "text": "\tconst stack = [targetId];",
            "lineNumber": 60
          },
          {
            "text": "\twhile (stack.length &gt; 0) {",
            "lineNumber": 61
          },
          {
            "text": "\t\tconst id = stack.pop()!;",
            "lineNumber": 62
          },
          {
            "text": "\t\tif (nodeIds.has(id)) continue;",
            "lineNumber": 63
          },
          {
            "text": "\t\tnodeIds.add(id);",
            "lineNumber": 64
          },
          {
            "text": "\t\tfor (const e of execEdges) {",
            "lineNumber": 65
          },
          {
            "text": "\t\t\tif (e.toNode === id) stack.push(e.fromNode);",
            "lineNumber": 66
          },
          {
            "text": "\t\t}",
            "lineNumber": 67
          },
          {
            "text": "\t}",
            "lineNumber": 68
          },
          {
            "text": "\treturn topologicalSort(data, execEdges, nodeIds);",
            "lineNumber": 69
          },
          {
            "text": "}",
            "lineNumber": 70,
            "isSignature": true
          },
          {
            "lineNumber": 71
          },
          {
            "text": "/** Topological order of all nodes reachable from any root (ignores output edges). */",
            "lineNumber": 72
          }
        ]
      },
      "score": 0.31067490577697754
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 75,
            "column": 1
          },
          "endPosition": {
            "line": 95,
            "column": 1
          }
        },
        "contents": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */\nexport function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));\n\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withY = fromIds\n\t\t.map((id) =&gt; {\n\t\t\tconst node = nodeMap.get(id);\n\t\t\treturn node ? { id, y: node.y } : null;\n\t\t})\n\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);\n\twithY.sort((a, b) =&gt; a.y - b.y);\n\treturn withY.map((x) =&gt; x.id);\n}\n\n/** Get node by id from canvas data. */\nexport function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */",
            "lineNumber": 78
          },
          {
            "text": "export function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {",
            "lineNumber": 79,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));",
            "lineNumber": 80
          },
          {
            "text": "\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];",
            "lineNumber": 81
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 82
          },
          {
            "text": "\tconst withY = fromIds",
            "lineNumber": 83
          },
          {
            "text": "\t\t.map((id) =&gt; {",
            "lineNumber": 84
          },
          {
            "text": "\t\t\tconst node = nodeMap.get(id);",
            "lineNumber": 85
          },
          {
            "text": "\t\t\treturn node ? { id, y: node.y } : null;",
            "lineNumber": 86
          },
          {
            "text": "\t\t})",
            "lineNumber": 87
          },
          {
            "text": "\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);",
            "lineNumber": 88
          },
          {
            "text": "\twithY.sort((a, b) =&gt; a.y - b.y);",
            "lineNumber": 89
          },
          {
            "text": "\treturn withY.map((x) =&gt; x.id);",
            "lineNumber": 90
          },
          {
            "text": "}",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "lineNumber": 92
          },
          {
            "text": "/** Get node by id from canvas data. */",
            "lineNumber": 93
          },
          {
            "text": "export function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {",
            "lineNumber": 94,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 95
          },
          {
            "text": "}",
            "lineNumber": 96,
            "isSignature": true
          }
        ]
      },
      "score": 0.2344847023487091
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 120,
            "column": 1
          },
          "endPosition": {
            "line": 160,
            "column": 107
          }
        },
        "contents": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */\nfunction buildInputWithVariables(\n\tcanvasKey: string,\n\tnodeInput: string,\n\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[]\n): { concatenatedPart: string; template: string; edgeModes: Map&lt;string, EdgeInputMode&gt; } {\n\tconst edgeModes = new Map&lt;string, EdgeInputMode&gt;();\n\tconst parentResults = new Map&lt;string, string&gt;();\n\tfor (const { parentId } of incoming) {\n\t\tconst r = getNodeResult(canvasKey, parentId);\n\t\tif (r != null) parentResults.set(parentId, r);\n\t}\n\tlet concatenatedPart = \"\";\n\tconst varValues: Record&lt;string, string&gt; = {};\n\tfor (const { parentId, edge, variableName } of incoming) {\n\t\tconst result = parentResults.get(parentId);\n\t\tif (result == null) continue;\n\t\tconst usedAsVar =\n\t\t\tvariableName.length &gt; 0 &amp;&amp; nodeInput.includes(&#96;{{var:${variableName}}}&#96;);\n\t\tif (usedAsVar) {\n\t\t\tedgeModes.set(edge.id, \"inject\");\n\t\t\tvarValues[variableName] = result;\n\t\t} else {\n\t\t\tedgeModes.set(edge.id, \"concatenate\");\n\t\t\tconcatenatedPart += result + \"\\n\\n\";\n\t\t}\n\t}\n\tlet template = nodeInput;\n\tfor (const [name, value] of Object.entries(varValues)) {\n\t\ttemplate = template.split(&#96;{{var:${name}}}&#96;).join(value);\n\t}\n\treturn {\n\t\tconcatenatedPart: concatenatedPart.trim(),\n\t\ttemplate,\n\t\tedgeModes,\n\t};\n}\n\n/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
            "lineNumber": 123
          },
          {
            "text": "function buildInputWithVariables(",
            "lineNumber": 124,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 125,
            "isSignature": true
          },
          {
            "text": "\tnodeInput: string,",
            "lineNumber": 126,
            "isSignature": true
          },
          {
            "text": "\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[]",
            "lineNumber": 127,
            "isSignature": true
          },
          {
            "text": "): { concatenatedPart: string; template: string; edgeModes: Map&lt;string, EdgeInputMode&gt; } {",
            "lineNumber": 128,
            "isSignature": true
          },
          {
            "text": "\tconst edgeModes = new Map&lt;string, EdgeInputMode&gt;();",
            "lineNumber": 129
          },
          {
            "text": "\tconst parentResults = new Map&lt;string, string&gt;();",
            "lineNumber": 130
          },
          {
            "text": "\tfor (const { parentId } of incoming) {",
            "lineNumber": 131
          },
          {
            "text": "\t\tconst r = getNodeResult(canvasKey, parentId);",
            "lineNumber": 132
          },
          {
            "text": "\t\tif (r != null) parentResults.set(parentId, r);",
            "lineNumber": 133
          },
          {
            "text": "\t}",
            "lineNumber": 134
          },
          {
            "text": "\tlet concatenatedPart = \"\";",
            "lineNumber": 135
          },
          {
            "text": "\tconst varValues: Record&lt;string, string&gt; = {};",
            "lineNumber": 136
          },
          {
            "text": "\tfor (const { parentId, edge, variableName } of incoming) {",
            "lineNumber": 137
          },
          {
            "text": "\t\tconst result = parentResults.get(parentId);",
            "lineNumber": 138
          },
          {
            "text": "\t\tif (result == null) continue;",
            "lineNumber": 139
          },
          {
            "text": "\t\tconst usedAsVar =",
            "lineNumber": 140
          },
          {
            "text": "\t\t\tvariableName.length &gt; 0 &amp;&amp; nodeInput.includes(&#96;{{var:${variableName}}}&#96;);",
            "lineNumber": 141
          },
          {
            "text": "\t\tif (usedAsVar) {",
            "lineNumber": 142
          },
          {
            "text": "\t\t\tedgeModes.set(edge.id, \"inject\");",
            "lineNumber": 143
          },
          {
            "text": "\t\t\tvarValues[variableName] = result;",
            "lineNumber": 144
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 145
          },
          {
            "text": "\t\t\tedgeModes.set(edge.id, \"concatenate\");",
            "lineNumber": 146
          },
          {
            "text": "\t\t\tconcatenatedPart += result + \"\\n\\n\";",
            "lineNumber": 147
          },
          {
            "text": "\t\t}",
            "lineNumber": 148
          },
          {
            "text": "\t}",
            "lineNumber": 149
          },
          {
            "text": "\tlet template = nodeInput;",
            "lineNumber": 150
          },
          {
            "text": "\tfor (const [name, value] of Object.entries(varValues)) {",
            "lineNumber": 151
          },
          {
            "text": "\t\ttemplate = template.split(&#96;{{var:${name}}}&#96;).join(value);",
            "lineNumber": 152
          },
          {
            "text": "\t}",
            "lineNumber": 153
          },
          {
            "text": "\treturn {",
            "lineNumber": 154
          },
          {
            "text": "\t\tconcatenatedPart: concatenatedPart.trim(),",
            "lineNumber": 155
          },
          {
            "text": "\t\ttemplate,",
            "lineNumber": 156
          },
          {
            "text": "\t\tedgeModes,",
            "lineNumber": 157
          },
          {
            "text": "\t};",
            "lineNumber": 158
          },
          {
            "text": "}",
            "lineNumber": 159,
            "isSignature": true
          },
          {
            "lineNumber": 160
          },
          {
            "text": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
            "lineNumber": 161
          }
        ]
      },
      "score": 0.2198803424835205
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 305,
            "column": 1
          },
          "endPosition": {
            "line": 383,
            "column": 107
          }
        },
        "contents": "/** Create or replace the Green output node and ensure an edge labeled \"output\" from source. Mutates data only. */\nfunction ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings\n): void {\n\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);\n\tconst y = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;\n\tconst width = Math.max(320, sourceNode.width);\n\tconst height = 180;\n\tconst defaultX = sourceNode.x;\n\tconst chosenX = chooseOutputPosition(\n\t\tdata,\n\t\tsourceNode.id,\n\t\toutId,\n\t\tdefaultX,\n\t\ty,\n\t\twidth,\n\t\theight,\n\t\tOUTPUT_COLLISION_MAX_RADIUS,\n\t\tOUTPUT_COLLISION_STEP\n\t);\n\tconst greenColor = settings.colorGreen;\n\n\tif (outId) {\n\t\tconst outNode = getNodeById(data, outId);\n\t\tif (outNode &amp;&amp; isTextNode(outNode)) {\n\t\t\tconst updated = {\n\t\t\t\t...(outNode as CanvasTextData),\n\t\t\t\ttext,\n\t\t\t\tx: chosenX,\n\t\t\t\ty,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t};\n\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);\n\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t} else if (outNode) {\n\t\t\t(outNode as { x: number; y: number }).x = chosenX;\n\t\t\t(outNode as { x: number; y: number }).y = y;\n\t\t}\n\t\tconst hasOutputEdge = data.edges.some(\n\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t\t);\n\t\tif (!hasOutputEdge) {\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: outId,\n\t\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tconst newNodeId = randomId();\n\tconst newTextNode: CanvasTextData = {\n\t\tid: newNodeId,\n\t\ttype: \"text\",\n\t\ttext,\n\t\tx: chosenX,\n\t\ty,\n\t\twidth,\n\t\theight,\n\t\tcolor: greenColor,\n\t};\n\tdata.nodes.push(newTextNode);\n\tdata.edges.push({\n\t\tid: randomId(),\n\t\tfromNode: sourceNode.id,\n\t\ttoNode: newNodeId,\n\t\tlabel: EDGE_LABEL_OUTPUT,\n\t});\n}\n\n/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Create or replace the Green output node and ensure an edge labeled \"output\" from source. Mutates data only. */",
            "lineNumber": 308
          },
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 309,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 310,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 311,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 312,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 313,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 314,
            "isSignature": true
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);",
            "lineNumber": 315
          },
          {
            "text": "\tconst y = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;",
            "lineNumber": 316
          },
          {
            "text": "\tconst width = Math.max(320, sourceNode.width);",
            "lineNumber": 317
          },
          {
            "text": "\tconst height = 180;",
            "lineNumber": 318
          },
          {
            "text": "\tconst defaultX = sourceNode.x;",
            "lineNumber": 319
          },
          {
            "text": "\tconst chosenX = chooseOutputPosition(",
            "lineNumber": 320
          },
          {
            "text": "\t\tdata,",
            "lineNumber": 321
          },
          {
            "text": "\t\tsourceNode.id,",
            "lineNumber": 322
          },
          {
            "text": "\t\toutId,",
            "lineNumber": 323
          },
          {
            "text": "\t\tdefaultX,",
            "lineNumber": 324
          },
          {
            "text": "\t\ty,",
            "lineNumber": 325
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 326
          },
          {
            "text": "\t\theight,",
            "lineNumber": 327
          },
          {
            "text": "\t\tOUTPUT_COLLISION_MAX_RADIUS,",
            "lineNumber": 328
          },
          {
            "text": "\t\tOUTPUT_COLLISION_STEP",
            "lineNumber": 329
          },
          {
            "text": "\t);",
            "lineNumber": 330
          },
          {
            "text": "\tconst greenColor = settings.colorGreen;",
            "lineNumber": 331
          },
          {
            "lineNumber": 332
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 333
          },
          {
            "text": "\t\tconst outNode = getNodeById(data, outId);",
            "lineNumber": 334
          },
          {
            "text": "\t\tif (outNode &amp;&amp; isTextNode(outNode)) {",
            "lineNumber": 335
          },
          {
            "text": "\t\t\tconst updated = {",
            "lineNumber": 336
          },
          {
            "text": "\t\t\t\t...(outNode as CanvasTextData),",
            "lineNumber": 337
          },
          {
            "text": "\t\t\t\ttext,",
            "lineNumber": 338
          },
          {
            "text": "\t\t\t\tx: chosenX,",
            "lineNumber": 339
          },
          {
            "text": "\t\t\t\ty,",
            "lineNumber": 340
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 341
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 342
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 343
          },
          {
            "text": "\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);",
            "lineNumber": 344
          },
          {
            "text": "\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 345
          },
          {
            "text": "\t\t} else if (outNode) {",
            "lineNumber": 346
          },
          {
            "text": "\t\t\t(outNode as { x: number; y: number }).x = chosenX;",
            "lineNumber": 347
          },
          {
            "text": "\t\t\t(outNode as { x: number; y: number }).y = y;",
            "lineNumber": 348
          },
          {
            "text": "\t\t}",
            "lineNumber": 349
          },
          {
            "text": "\t\tconst hasOutputEdge = data.edges.some(",
            "lineNumber": 350
          },
          {
            "text": "\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 351
          },
          {
            "text": "\t\t);",
            "lineNumber": 352
          },
          {
            "text": "\t\tif (!hasOutputEdge) {",
            "lineNumber": 353
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 354
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 355
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 356
          },
          {
            "text": "\t\t\t\ttoNode: outId,",
            "lineNumber": 357
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 358
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 359
          },
          {
            "text": "\t\t}",
            "lineNumber": 360
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 361
          },
          {
            "text": "\t}",
            "lineNumber": 362
          },
          {
            "lineNumber": 363
          },
          {
            "text": "\tconst newNodeId = randomId();",
            "lineNumber": 364
          },
          {
            "text": "\tconst newTextNode: CanvasTextData = {",
            "lineNumber": 365
          },
          {
            "text": "\t\tid: newNodeId,",
            "lineNumber": 366
          },
          {
            "text": "\t\ttype: \"text\",",
            "lineNumber": 367
          },
          {
            "text": "\t\ttext,",
            "lineNumber": 368
          },
          {
            "text": "\t\tx: chosenX,",
            "lineNumber": 369
          },
          {
            "text": "\t\ty,",
            "lineNumber": 370
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 371
          },
          {
            "text": "\t\theight,",
            "lineNumber": 372
          },
          {
            "text": "\t\tcolor: greenColor,",
            "lineNumber": 373
          },
          {
            "text": "\t};",
            "lineNumber": 374
          },
          {
            "text": "\tdata.nodes.push(newTextNode);",
            "lineNumber": 375
          },
          {
            "text": "\tdata.edges.push({",
            "lineNumber": 376
          },
          {
            "text": "\t\tid: randomId(),",
            "lineNumber": 377
          },
          {
            "text": "\t\tfromNode: sourceNode.id,",
            "lineNumber": 378
          },
          {
            "text": "\t\ttoNode: newNodeId,",
            "lineNumber": 379
          },
          {
            "text": "\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 380
          },
          {
            "text": "\t});",
            "lineNumber": 381
          },
          {
            "text": "}",
            "lineNumber": 382,
            "isSignature": true
          },
          {
            "lineNumber": 383
          },
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 384
          }
        ]
      },
      "score": 0.21232159435749054
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 264,
            "column": 1
          },
          "endPosition": {
            "line": 305,
            "column": 1
          }
        },
        "contents": "/** Choose an x for the output box to avoid overlapping other nodes; tries defaultX then right then left within maxRadius. */\nfunction chooseOutputPosition(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\toutNodeId: string | null,\n\tdefaultX: number,\n\ty: number,\n\twidth: number,\n\theight: number,\n\tmaxRadius: number,\n\tstep: number\n): number {\n\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);\n\tif (outNodeId) excludeIds.add(outNodeId);\n\tconst box = { x: 0, y, width, height };\n\tfunction tryX(x: number): boolean {\n\t\tbox.x = x;\n\t\tfor (const node of data.nodes) {\n\t\t\tif (excludeIds.has(node.id)) continue;\n\t\t\tif (rectanglesOverlap(box, { x: node.x, y: node.y, width: node.width, height: node.height })) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tif (tryX(defaultX)) return defaultX;\n\tfor (let offset = step; offset &lt;= maxRadius; offset += step) {\n\t\tif (tryX(defaultX + offset)) return defaultX + offset;\n\t\tif (tryX(defaultX - offset)) return defaultX - offset;\n\t}\n\treturn defaultX;\n}\n\n/** Generate a unique id for new canvas nodes/edges. */\nfunction randomId(): string {\n\tif\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Choose an x for the output box to avoid overlapping other nodes; tries defaultX then right then left within maxRadius. */",
            "lineNumber": 267
          },
          {
            "text": "function chooseOutputPosition(",
            "lineNumber": 268,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 269,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 270,
            "isSignature": true
          },
          {
            "text": "\toutNodeId: string | null,",
            "lineNumber": 271,
            "isSignature": true
          },
          {
            "text": "\tdefaultX: number,",
            "lineNumber": 272,
            "isSignature": true
          },
          {
            "text": "\ty: number,",
            "lineNumber": 273,
            "isSignature": true
          },
          {
            "text": "\twidth: number,",
            "lineNumber": 274,
            "isSignature": true
          },
          {
            "text": "\theight: number,",
            "lineNumber": 275,
            "isSignature": true
          },
          {
            "text": "\tmaxRadius: number,",
            "lineNumber": 276,
            "isSignature": true
          },
          {
            "text": "\tstep: number",
            "lineNumber": 277,
            "isSignature": true
          },
          {
            "text": "): number {",
            "lineNumber": 278,
            "isSignature": true
          },
          {
            "text": "\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);",
            "lineNumber": 279
          },
          {
            "text": "\tif (outNodeId) excludeIds.add(outNodeId);",
            "lineNumber": 280
          },
          {
            "text": "\tconst box = { x: 0, y, width, height };",
            "lineNumber": 281
          },
          {
            "text": "\tfunction tryX(x: number): boolean {",
            "lineNumber": 282,
            "isSignature": true
          },
          {
            "text": "\t\tbox.x = x;",
            "lineNumber": 283
          },
          {
            "text": "\t\tfor (const node of data.nodes) {",
            "lineNumber": 284
          },
          {
            "text": "\t\t\tif (excludeIds.has(node.id)) continue;",
            "lineNumber": 285
          },
          {
            "text": "\t\t\tif (rectanglesOverlap(box, { x: node.x, y: node.y, width: node.width, height: node.height })) {",
            "lineNumber": 286
          },
          {
            "text": "\t\t\t\treturn false;",
            "lineNumber": 287
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 288
          },
          {
            "text": "\t\t}",
            "lineNumber": 289
          },
          {
            "text": "\t\treturn true;",
            "lineNumber": 290
          },
          {
            "text": "\t}",
            "lineNumber": 291,
            "isSignature": true
          },
          {
            "text": "\tif (tryX(defaultX)) return defaultX;",
            "lineNumber": 292
          },
          {
            "text": "\tfor (let offset = step; offset &lt;= maxRadius; offset += step) {",
            "lineNumber": 293
          },
          {
            "text": "\t\tif (tryX(defaultX + offset)) return defaultX + offset;",
            "lineNumber": 294
          },
          {
            "text": "\t\tif (tryX(defaultX - offset)) return defaultX - offset;",
            "lineNumber": 295
          },
          {
            "text": "\t}",
            "lineNumber": 296
          },
          {
            "text": "\treturn defaultX;",
            "lineNumber": 297
          },
          {
            "text": "}",
            "lineNumber": 298,
            "isSignature": true
          },
          {
            "lineNumber": 299
          },
          {
            "text": "/** Generate a unique id for new canvas nodes/edges. */",
            "lineNumber": 300
          },
          {
            "text": "function randomId(): string {",
            "lineNumber": 301,
            "isSignature": true
          },
          {
            "text": "\tif",
            "lineNumber": 302
          },
          {
            "text": "}",
            "lineNumber": 306,
            "isSignature": true
          }
        ]
      },
      "score": 0.21155565977096558
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 37,
            "column": 1
          }
        },
        "contents": "import type {App} from \"obsidian\";\nimport {\n\tEDGE_LABEL_OUTPUT,\n\tfindOutputNodeForSource,\n\tgetNodeById,\n\tgetNodeContent,\n\tgetNodeRole,\n\tgetIncomingEdgesWithLabels,\n\tgetParentIdsSortedByY,\n\tGREEN_NODE_PADDING,\n\tisOutputEdge,\n\tloadCanvasData,\n\tsaveCanvasData,\n} from \"../canvas/nodes\";\nimport type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";\nimport { parseEdgeVariableName } from \"../canvas/types\";\nimport {isTextNode} from \"../canvas/types\";\nimport type {LiveCanvas} from \"./canvasApi\";\nimport {getKernelForCanvas} from \"./kernelManager\";\nimport {ollamaGenerate} from \"./ollama\";\nimport {\n\tgetCanvasKey,\n\tgetNodeResult,\n\tsetNodeResult,\n\tsetEdgeModes,\n\tsetRunningNodeId,\n} from \"./state\";\nimport type {ZettelPluginSettings} from \"../settings\";\n\ntype EdgeInputMode = \"inject\" | \"concatenate\";\n\n/** Get all root node ids (no incoming non-output edges). */\nfunction getRootIds(data: CanvasData): string[] {\n\tconst hasIncoming = new Set\n;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {App} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {",
            "lineNumber": 2
          },
          {
            "text": "\tEDGE_LABEL_OUTPUT,",
            "lineNumber": 3
          },
          {
            "text": "\tfindOutputNodeForSource,",
            "lineNumber": 4
          },
          {
            "text": "\tgetNodeById,",
            "lineNumber": 5
          },
          {
            "text": "\tgetNodeContent,",
            "lineNumber": 6
          },
          {
            "text": "\tgetNodeRole,",
            "lineNumber": 7
          },
          {
            "text": "\tgetIncomingEdgesWithLabels,",
            "lineNumber": 8
          },
          {
            "text": "\tgetParentIdsSortedByY,",
            "lineNumber": 9
          },
          {
            "text": "\tGREEN_NODE_PADDING,",
            "lineNumber": 10
          },
          {
            "text": "\tisOutputEdge,",
            "lineNumber": 11
          },
          {
            "text": "\tloadCanvasData,",
            "lineNumber": 12
          },
          {
            "text": "\tsaveCanvasData,",
            "lineNumber": 13
          },
          {
            "text": "} from \"../canvas/nodes\";",
            "lineNumber": 14
          },
          {
            "text": "import type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";",
            "lineNumber": 15
          },
          {
            "text": "import { parseEdgeVariableName } from \"../canvas/types\";",
            "lineNumber": 16
          },
          {
            "text": "import {isTextNode} from \"../canvas/types\";",
            "lineNumber": 17
          },
          {
            "text": "import type {LiveCanvas} from \"./canvasApi\";",
            "lineNumber": 18
          },
          {
            "text": "import {getKernelForCanvas} from \"./kernelManager\";",
            "lineNumber": 19
          },
          {
            "text": "import {ollamaGenerate} from \"./ollama\";",
            "lineNumber": 20
          },
          {
            "text": "import {",
            "lineNumber": 21
          },
          {
            "text": "\tgetCanvasKey,",
            "lineNumber": 22
          },
          {
            "text": "\tgetNodeResult,",
            "lineNumber": 23
          },
          {
            "text": "\tsetNodeResult,",
            "lineNumber": 24
          },
          {
            "text": "\tsetEdgeModes,",
            "lineNumber": 25
          },
          {
            "text": "\tsetRunningNodeId,",
            "lineNumber": 26
          },
          {
            "text": "} from \"./state\";",
            "lineNumber": 27
          },
          {
            "text": "import type {ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "type EdgeInputMode = \"inject\" | \"concatenate\";",
            "lineNumber": 30,
            "isSignature": true
          },
          {
            "lineNumber": 31
          },
          {
            "text": "/** Get all root node ids (no incoming non-output edges). */",
            "lineNumber": 32
          },
          {
            "text": "function getRootIds(data: CanvasData): string[] {",
            "lineNumber": 33,
            "isSignature": true
          },
          {
            "text": "\tconst hasIncoming = new Set",
            "lineNumber": 34
          },
          {
            "text": ";",
            "lineNumber": 36
          },
          {
            "text": "}",
            "lineNumber": 38,
            "isSignature": true
          }
        ]
      },
      "score": 0.2065192461013794
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 29,
            "column": 46
          },
          "endPosition": {
            "line": 53,
            "column": 1
          }
        },
        "contents": "/** Get all root node ids (no incoming non-output edges). */\nfunction getRootIds(data: CanvasData): string[] {\n\tconst hasIncoming = new Set(\n\t\tdata.edges.filter((e) =&gt; !isOutputEdge(e)).map((e) =&gt; e.toNode)\n\t);\n\treturn data.nodes.filter((n) =&gt; !hasIncoming.has(n.id)).map((n) =&gt; n.id);\n}\n\n/** Check if there is a path from fromId to toId (ignoring output edges). */\nfunction canReach(data: CanvasData, fromId: string, toId: string): boolean {\n\tconst visited = new Set&lt;string&gt;();\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get all root node ids (no incoming non-output edges). */",
            "lineNumber": 32
          },
          {
            "text": "function getRootIds(data: CanvasData): string[] {",
            "lineNumber": 33,
            "isSignature": true
          },
          {
            "text": "\tconst hasIncoming = new Set(",
            "lineNumber": 34
          },
          {
            "text": "\t\tdata.edges.filter((e) =&gt; !isOutputEdge(e)).map((e) =&gt; e.toNode)",
            "lineNumber": 35
          },
          {
            "text": "\t);",
            "lineNumber": 36
          },
          {
            "text": "\treturn data.nodes.filter((n) =&gt; !hasIncoming.has(n.id)).map((n) =&gt; n.id);",
            "lineNumber": 37
          },
          {
            "text": "}",
            "lineNumber": 38,
            "isSignature": true
          },
          {
            "lineNumber": 39
          },
          {
            "text": "/** Check if there is a path from fromId to toId (ignoring output edges). */",
            "lineNumber": 40
          },
          {
            "text": "function canReach(data: CanvasData, fromId: string, toId: string): boolean {",
            "lineNumber": 41,
            "isSignature": true
          },
          {
            "text": "\tconst visited = new Set&lt;string&gt;();",
            "lineNumber": 42
          },
          {
            "text": "}",
            "lineNumber": 54,
            "isSignature": true
          }
        ]
      },
      "score": 0.19723105430603027
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 191
          },
          "endPosition": {
            "line": 249,
            "column": 99
          }
        },
        "contents": "async function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\n\tif (role === \"blue\") {\n\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);\n\t\tconst result = await kernel.run(template, concatenatedPart);\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\treturn \"\";\n}\n\n/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 192,
                "column": 1
              },
              "endPosition": {
                "line": 201,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "async function runSingleNode(",
            "lineNumber": 192,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 195,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 196,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 197,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 198,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 199,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 200,
            "isSignature": true
          },
          {
            "lineNumber": 238
          },
          {
            "text": "\tif (role === \"blue\") {",
            "lineNumber": 239
          },
          {
            "text": "\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);",
            "lineNumber": 240
          },
          {
            "text": "\t\tconst result = await kernel.run(template, concatenatedPart);",
            "lineNumber": 241
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 242
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 243
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 244
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 245
          },
          {
            "text": "\t}",
            "lineNumber": 246
          },
          {
            "text": "\treturn \"\";",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 248,
            "isSignature": true
          },
          {
            "lineNumber": 249
          },
          {
            "text": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
            "lineNumber": 250
          }
        ]
      },
      "score": 0.18993419408798218
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\n\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js).\n\t\t\tconst addNodeMenuItems = (menu: Menu, node: unknown): void =&gt; {\n\t\t\t\tdebugNodeMenuFired = true;\n\t\t\t\tconst nodeId = resolveCanvasNodeId(node);\n\t\t\t\tif (!nodeId) return;\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Dismiss output\").setIcon(\"trash\").onClick(() =&gt; this.dismissOutput(nodeId))\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst registerCanvasNodeMenu = () =&gt; {\n\t\t\t\ttry {\n\t\t\t\t\tconst on = this.app.workspace.on.bind(this.app.workspace) as (\n\t\t\t\t\t\tname: string,\n\t\t\t\t\t\tcallback: (menu: Menu, node: unknown) =&gt; void\n\t\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;\n\t\t\t\t\t// Try documented-style event name first; some Obsidian builds use \"canvas:node-menu\".\n\t\t\t\t\tthis.registerEvent(on(\"canvas:node-menu\", addNodeMenuItems));\n\t\t\t\t\t// Fallback: try hyphenated name in case the app triggers a different event.\n\t\t\t\t\tthis.registerEvent(on(\"canvas-node-menu\", addNodeMenuItems));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas node menu.\", e);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst timeoutId = window.setTimeout(registerCanvasNodeMenu, 0);\n\t\t\tthis.register(() =&gt; window.clearTimeout(timeoutId));\n\n\t\t\t// Canvas background context menu: use undocumented \"canvas:edge-menu\" (Obsidian broadcasts it;\n\t\t\t// when right-click is on empty area, edge is null). Same pattern as canvas:node-menu: addItem with setTitle, setIcon, onClick.\n\t\t\tconst addCanvasMenuItems = (menu: Menu): void =&gt; {\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Dismiss all output\").setIcon(\"trash\").onClick(() =&gt; this.dismissAllOutput())\n\t\t\t\t);\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace)\n;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 37,
                "column": 2
              },
              "endPosition": {
                "line": 38,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 37
          },
          {
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 90
          },
          {
            "text": "\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js).",
            "lineNumber": 91
          },
          {
            "text": "\t\t\tconst addNodeMenuItems = (menu: Menu, node: unknown): void =&gt; {",
            "lineNumber": 92
          },
          {
            "text": "\t\t\t\tdebugNodeMenuFired = true;",
            "lineNumber": 93
          },
          {
            "text": "\t\t\t\tconst nodeId = resolveCanvasNodeId(node);",
            "lineNumber": 94
          },
          {
            "text": "\t\t\t\tif (!nodeId) return;",
            "lineNumber": 95
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 96
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))",
            "lineNumber": 97
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 98
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 99
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))",
            "lineNumber": 100
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 101
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 102
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Dismiss output\").setIcon(\"trash\").onClick(() =&gt; this.dismissOutput(nodeId))",
            "lineNumber": 103
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 104
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 105
          },
          {
            "text": "\t\t\tconst registerCanvasNodeMenu = () =&gt; {",
            "lineNumber": 106
          },
          {
            "text": "\t\t\t\ttry {",
            "lineNumber": 107
          },
          {
            "text": "\t\t\t\t\tconst on = this.app.workspace.on.bind(this.app.workspace) as (",
            "lineNumber": 108
          },
          {
            "text": "\t\t\t\t\t\tname: string,",
            "lineNumber": 109
          },
          {
            "text": "\t\t\t\t\t\tcallback: (menu: Menu, node: unknown) =&gt; void",
            "lineNumber": 110
          },
          {
            "text": "\t\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;",
            "lineNumber": 111
          },
          {
            "text": "\t\t\t\t\t// Try documented-style event name first; some Obsidian builds use \"canvas:node-menu\".",
            "lineNumber": 112
          },
          {
            "text": "\t\t\t\t\tthis.registerEvent(on(\"canvas:node-menu\", addNodeMenuItems));",
            "lineNumber": 113
          },
          {
            "text": "\t\t\t\t\t// Fallback: try hyphenated name in case the app triggers a different event.",
            "lineNumber": 114
          },
          {
            "text": "\t\t\t\t\tthis.registerEvent(on(\"canvas-node-menu\", addNodeMenuItems));",
            "lineNumber": 115
          },
          {
            "text": "\t\t\t\t} catch (e) {",
            "lineNumber": 116
          },
          {
            "text": "\t\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas node menu.\", e);",
            "lineNumber": 117
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 118
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 119
          },
          {
            "text": "\t\t\tconst timeoutId = window.setTimeout(registerCanvasNodeMenu, 0);",
            "lineNumber": 120
          },
          {
            "text": "\t\t\tthis.register(() =&gt; window.clearTimeout(timeoutId));",
            "lineNumber": 121
          },
          {
            "lineNumber": 122
          },
          {
            "text": "\t\t\t// Canvas background context menu: use undocumented \"canvas:edge-menu\" (Obsidian broadcasts it;",
            "lineNumber": 123
          },
          {
            "text": "\t\t\t// when right-click is on empty area, edge is null). Same pattern as canvas:node-menu: addItem with setTitle, setIcon, onClick.",
            "lineNumber": 124
          },
          {
            "text": "\t\t\tconst addCanvasMenuItems = (menu: Menu): void =&gt; {",
            "lineNumber": 125
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 126
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())",
            "lineNumber": 127
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 128
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 129
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Dismiss all output\").setIcon(\"trash\").onClick(() =&gt; this.dismissAllOutput())",
            "lineNumber": 130
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 131
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 132
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 133
          },
          {
            "text": "\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace)",
            "lineNumber": 134
          },
          {
            "text": ";",
            "lineNumber": 137
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.18725180625915527
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 28,
            "column": 1
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */\nlet debugNodeMenuFired = false;\n\nexport default class ZettelThinkingBoardPlugin extends Plugin {\n\tsettings: ZettelPluginSettings;\n\n\tasync onload() {\n\t\ttry {\n\t\t\tawait this.loadSettings();\n\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));\n\n\t\t\tthis.registerView(\n\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,\n\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)\n\t\t\t);\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"open-zettel-controls\",\n\t\t\t\tname: \"Open Zettel Controls\",\n\t\t\t\tcallback: () =&gt; this.activateZettelControls(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-node\",\n\t\t\t\tname: \"Run node\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-chain\",\n\t\t\t\tname: \"Run chain\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"dismiss-output\",\n\t\t\t\tname: \"Dismiss output\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 31
          },
          {
            "text": "let debugNodeMenuFired = false;",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings;",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "\tasync onload() {",
            "lineNumber": 37
          },
          {
            "text": "\t\ttry {",
            "lineNumber": 38
          },
          {
            "text": "\t\t\tawait this.loadSettings();",
            "lineNumber": 39
          },
          {
            "text": "\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));",
            "lineNumber": 40
          },
          {
            "lineNumber": 41
          },
          {
            "text": "\t\t\tthis.registerView(",
            "lineNumber": 42
          },
          {
            "text": "\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,",
            "lineNumber": 43
          },
          {
            "text": "\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)",
            "lineNumber": 44
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 47
          },
          {
            "text": "\t\t\t\tid: \"open-zettel-controls\",",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\tname: \"Open Zettel Controls\",",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.activateZettelControls(),",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 51
          },
          {
            "lineNumber": 52
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 53
          },
          {
            "text": "\t\t\t\tid: \"run-node\",",
            "lineNumber": 54
          },
          {
            "text": "\t\t\t\tname: \"Run node\",",
            "lineNumber": 55
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 56
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 57
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 58
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 59
          },
          {
            "text": "\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu",
            "lineNumber": 60
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");",
            "lineNumber": 61
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 62
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 63
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 64
          },
          {
            "lineNumber": 65
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 66
          },
          {
            "text": "\t\t\t\tid: \"run-chain\",",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t\tname: \"Run chain\",",
            "lineNumber": 68
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 69
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 70
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 71
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 72
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");",
            "lineNumber": 73
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 74
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 75
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 76
          },
          {
            "lineNumber": 77
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 78
          },
          {
            "text": "\t\t\t\tid: \"dismiss-output\",",
            "lineNumber": 79
          },
          {
            "text": "\t\t\t\tname: \"Dismiss output\",",
            "lineNumber": 80
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 81
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 82
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 83
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 84
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");",
            "lineNumber": 85
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 86
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 87
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 90
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.18451476097106934
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 57,
            "column": 1
          },
          "endPosition": {
            "line": 77,
            "column": 90
          }
        },
        "contents": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y. Excludes output edges. */\nexport function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withY = edges.map((e) =&gt; {\n\t\tconst parent = nodeMap.get(e.fromNode);\n\t\tconst y = parent?.y ?? 0;\n\t\treturn {\n\t\t\tparentId: e.fromNode,\n\t\t\tedge: e,\n\t\t\tvariableName: parseEdgeVariableName(e.label),\n\t\t\ty,\n\t\t};\n\t});\n\twithY.sort((a, b) =&gt; a.y - b.y);\n\treturn withY.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));\n}\n\n/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y. Excludes output edges. */",
            "lineNumber": 60
          },
          {
            "text": "export function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {",
            "lineNumber": 61,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));",
            "lineNumber": 62
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 63
          },
          {
            "text": "\tconst withY = edges.map((e) =&gt; {",
            "lineNumber": 64
          },
          {
            "text": "\t\tconst parent = nodeMap.get(e.fromNode);",
            "lineNumber": 65
          },
          {
            "text": "\t\tconst y = parent?.y ?? 0;",
            "lineNumber": 66
          },
          {
            "text": "\t\treturn {",
            "lineNumber": 67
          },
          {
            "text": "\t\t\tparentId: e.fromNode,",
            "lineNumber": 68
          },
          {
            "text": "\t\t\tedge: e,",
            "lineNumber": 69
          },
          {
            "text": "\t\t\tvariableName: parseEdgeVariableName(e.label),",
            "lineNumber": 70
          },
          {
            "text": "\t\t\ty,",
            "lineNumber": 71
          },
          {
            "text": "\t\t};",
            "lineNumber": 72
          },
          {
            "text": "\t});",
            "lineNumber": 73
          },
          {
            "text": "\twithY.sort((a, b) =&gt; a.y - b.y);",
            "lineNumber": 74
          },
          {
            "text": "\treturn withY.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));",
            "lineNumber": 75
          },
          {
            "text": "}",
            "lineNumber": 76,
            "isSignature": true
          },
          {
            "lineNumber": 77
          },
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */",
            "lineNumber": 78
          }
        ]
      },
      "score": 0.1808468997478485
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/state.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 25,
            "column": 1
          }
        },
        "contents": "/** Per-canvas state: NodeID -&gt; last output result string. */\nconst canvasState = new Map&lt;string, Map&lt;string, string&gt;&gt;();\n\n/** Per-canvas edge mode: EdgeID -&gt; \"inject\" | \"concatenate\" (shown in floating label under edge). */\nconst edgeModeState = new Map&lt;string, Map&lt;string, \"inject\" | \"concatenate\"&gt;&gt;();\n\n/** Node currently running (waiting for AI/kernel) per canvas; used to show \"running\" on incoming edges. */\nconst runningNodeState = new Map&lt;string, string | null&gt;();\n\nfunction getCanvasState(canvasKey: string): Map&lt;string, string&gt; {\n\tlet map = canvasState.get(canvasKey);\n\tif (!map) {\n\t\tmap = new Map();\n\t\tcanvasState.set(canvasKey, map);\n\t}\n\treturn map;\n}\n\nfunction getEdgeModeState(canvasKey: string): Map&lt;string, \"inject\" | \"concatenate\"&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Per-canvas state: NodeID -&gt; last output result string. */",
            "lineNumber": 1
          },
          {
            "text": "const canvasState = new Map&lt;string, Map&lt;string, string&gt;&gt;();",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "/** Per-canvas edge mode: EdgeID -&gt; \"inject\" | \"concatenate\" (shown in floating label under edge). */",
            "lineNumber": 4
          },
          {
            "text": "const edgeModeState = new Map&lt;string, Map&lt;string, \"inject\" | \"concatenate\"&gt;&gt;();",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "/** Node currently running (waiting for AI/kernel) per canvas; used to show \"running\" on incoming edges. */",
            "lineNumber": 7
          },
          {
            "text": "const runningNodeState = new Map&lt;string, string | null&gt;();",
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "function getCanvasState(canvasKey: string): Map&lt;string, string&gt; {",
            "lineNumber": 10,
            "isSignature": true
          },
          {
            "text": "\tlet map = canvasState.get(canvasKey);",
            "lineNumber": 11
          },
          {
            "text": "\tif (!map) {",
            "lineNumber": 12
          },
          {
            "text": "\t\tmap = new Map();",
            "lineNumber": 13
          },
          {
            "text": "\t\tcanvasState.set(canvasKey, map);",
            "lineNumber": 14
          },
          {
            "text": "\t}",
            "lineNumber": 15
          },
          {
            "text": "\treturn map;",
            "lineNumber": 16
          },
          {
            "text": "}",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "lineNumber": 18
          },
          {
            "text": "function getEdgeModeState(canvasKey: string): Map&lt;string, \"inject\" | \"concatenate\"&gt; {",
            "lineNumber": 19,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 20
          },
          {
            "text": "}",
            "lineNumber": 26,
            "isSignature": true
          }
        ]
      },
      "score": 0.17560109496116638
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 118,
            "column": 37
          },
          "endPosition": {
            "line": 145,
            "column": 1
          }
        },
        "contents": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */\nexport function findOutputNodeForSource(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\tsettings: ZettelPluginSettings\n): string | null {\n\tconst outputEdge = data.edges.find(\n\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t);\n\tif (outputEdge) return outputEdge.toNode;\n\tconst source = getNodeById(data, sourceNodeId);\n\tif (!source) return null;\n\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);\n\tif (!greenColor) return null;\n\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;\n\tconst tolerance = 30; // allow small layout drift\n\tfor (const node of data.nodes) {\n\t\tif (node.id === sourceNodeId) continue;\n\t\tif (normalizeColor(node.color) !== greenColor) continue;\n\t\t// Same x (or close), and y at or near expected\n\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;\n\t\tif (node.y &lt; expectedY - tolerance || node.y &gt; expectedY + tolerance) continue;\n\t\treturn node.id;\n\t}\n\treturn null;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
            "lineNumber": 121
          },
          {
            "text": "export function findOutputNodeForSource(",
            "lineNumber": 122,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 123,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 124,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 125,
            "isSignature": true
          },
          {
            "text": "): string | null {",
            "lineNumber": 126,
            "isSignature": true
          },
          {
            "text": "\tconst outputEdge = data.edges.find(",
            "lineNumber": 127
          },
          {
            "text": "\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 128
          },
          {
            "text": "\t);",
            "lineNumber": 129
          },
          {
            "text": "\tif (outputEdge) return outputEdge.toNode;",
            "lineNumber": 130
          },
          {
            "text": "\tconst source = getNodeById(data, sourceNodeId);",
            "lineNumber": 131
          },
          {
            "text": "\tif (!source) return null;",
            "lineNumber": 132
          },
          {
            "text": "\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);",
            "lineNumber": 133
          },
          {
            "text": "\tif (!greenColor) return null;",
            "lineNumber": 134
          },
          {
            "text": "\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;",
            "lineNumber": 135
          },
          {
            "text": "\tconst tolerance = 30; // allow small layout drift",
            "lineNumber": 136
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 137
          },
          {
            "text": "\t\tif (node.id === sourceNodeId) continue;",
            "lineNumber": 138
          },
          {
            "text": "\t\tif (normalizeColor(node.color) !== greenColor) continue;",
            "lineNumber": 139
          },
          {
            "text": "\t\t// Same x (or close), and y at or near expected",
            "lineNumber": 140
          },
          {
            "text": "\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;",
            "lineNumber": 141
          },
          {
            "text": "\t\tif (node.y &lt; expectedY - tolerance || node.y &gt; expectedY + tolerance) continue;",
            "lineNumber": 142
          },
          {
            "text": "\t\treturn node.id;",
            "lineNumber": 143
          },
          {
            "text": "\t}",
            "lineNumber": 144
          },
          {
            "text": "\treturn null;",
            "lineNumber": 145
          },
          {
            "text": "}",
            "lineNumber": 146,
            "isSignature": true
          }
        ]
      },
      "score": 0.17360630631446838
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "column": 71
          },
          "endPosition": {
            "line": 30,
            "column": 108
          }
        },
        "contents": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";\nimport {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";\nimport {\n\tdismissAllOutput as runnerDismissAllOutput,\n\tdismissOutput as runnerDismissOutput,\n\trunChain as runnerRunChain,\n\trunEntireCanvas as runnerRunEntireCanvas,\n\trunNode as runnerRunNode,\n} from \"./engine/runner\";\nimport {\n\tclearCanvasEdgeModeLabels,\n\tclearCanvasLegend,\n\tclearCanvasRoleLabels,\n\tsyncCanvasEdgeModeLabels,\n\tsyncCanvasRoleLabels,\n} from \"./canvas/canvasNodeLabels\";\nimport {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";\n\n/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */\nfunction resolveCanvasNodeId(node: unknown): string | undefined {\n\tif (!node || typeof node !== \"object\") return undefined;\n\tconst n = node as Record&lt;string, unknown&gt;;\n\tif (typeof n.id === \"string\") return n.id;\n\tconst inner = n.node as Record&lt;string, unknown&gt; | undefined;\n\tif (inner &amp;&amp; typeof inner.id === \"string\") return inner.id;\n\tconst data = typeof n.getData === \"function\" ? (n.getData as () =&gt; { id?: string })() : undefined;\n\treturn data?.id;\n}\n\n/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";",
            "lineNumber": 2
          },
          {
            "text": "import {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";",
            "lineNumber": 3
          },
          {
            "text": "import {",
            "lineNumber": 4
          },
          {
            "text": "\tdismissAllOutput as runnerDismissAllOutput,",
            "lineNumber": 5
          },
          {
            "text": "\tdismissOutput as runnerDismissOutput,",
            "lineNumber": 6
          },
          {
            "text": "\trunChain as runnerRunChain,",
            "lineNumber": 7
          },
          {
            "text": "\trunEntireCanvas as runnerRunEntireCanvas,",
            "lineNumber": 8
          },
          {
            "text": "\trunNode as runnerRunNode,",
            "lineNumber": 9
          },
          {
            "text": "} from \"./engine/runner\";",
            "lineNumber": 10
          },
          {
            "text": "import {",
            "lineNumber": 11
          },
          {
            "text": "\tclearCanvasEdgeModeLabels,",
            "lineNumber": 12
          },
          {
            "text": "\tclearCanvasLegend,",
            "lineNumber": 13
          },
          {
            "text": "\tclearCanvasRoleLabels,",
            "lineNumber": 14
          },
          {
            "text": "\tsyncCanvasEdgeModeLabels,",
            "lineNumber": 15
          },
          {
            "text": "\tsyncCanvasRoleLabels,",
            "lineNumber": 16
          },
          {
            "text": "} from \"./canvas/canvasNodeLabels\";",
            "lineNumber": 17
          },
          {
            "text": "import {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";",
            "lineNumber": 18
          },
          {
            "lineNumber": 19
          },
          {
            "text": "/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */",
            "lineNumber": 20
          },
          {
            "text": "function resolveCanvasNodeId(node: unknown): string | undefined {",
            "lineNumber": 21,
            "isSignature": true
          },
          {
            "text": "\tif (!node || typeof node !== \"object\") return undefined;",
            "lineNumber": 22
          },
          {
            "text": "\tconst n = node as Record&lt;string, unknown&gt;;",
            "lineNumber": 23
          },
          {
            "text": "\tif (typeof n.id === \"string\") return n.id;",
            "lineNumber": 24
          },
          {
            "text": "\tconst inner = n.node as Record&lt;string, unknown&gt; | undefined;",
            "lineNumber": 25
          },
          {
            "text": "\tif (inner &amp;&amp; typeof inner.id === \"string\") return inner.id;",
            "lineNumber": 26
          },
          {
            "text": "\tconst data = typeof n.getData === \"function\" ? (n.getData as () =&gt; { id?: string })() : undefined;",
            "lineNumber": 27
          },
          {
            "text": "\treturn data?.id;",
            "lineNumber": 28
          },
          {
            "text": "}",
            "lineNumber": 29,
            "isSignature": true
          },
          {
            "lineNumber": 30
          },
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 31
          }
        ]
      },
      "score": 0.16839289665222168
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/settings.ts",
        "range": {
          "startPosition": {
            "line": 175
          },
          "endPosition": {
            "line": 312,
            "column": 1
          }
        },
        "contents": "export class ZettelSettingTab extends PluginSettingTab {\n\n\n\tdisplay(): void {\n\t\tconst {containerEl} = this;\n\t\tcontainerEl.empty();\n\t\tconst s = this.plugin.settings;\n\n\t\t// How to run: one-line hint (per UX suggestion)\n\t\tconst hint = containerEl.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });\n\t\thint.setText(\"Right-click a node on the canvas and choose Run node or Run chain.\");\n\n\t\t// Execution: what runs (primary model, secondary model, Python path)\n\t\tconst executionSection = containerEl.createDiv({ cls: \"ztb-settings-section\" });\n\t\texecutionSection.createEl(\"h4\", { text: \"Execution\", cls: \"ztb-section-title\" });\n\t\tconst ollamaContainer = executionSection.createDiv({ cls: \"ztb-ollama-settings\" });\n\t\tconst loadingEl = ollamaContainer.createDiv({ cls: \"ztb-ollama-loading\" });\n\t\tloadingEl.setText(\"Loading Ollama models\");\n\t\t(async () =&gt; {\n\t\t\tconst models = await fetchOllamaModels();\n\t\t\tloadingEl.remove();\n\t\t\tif (models.length === 0) {\n\t\t\t\tconst fallback = ollamaContainer.createDiv({ cls: \"ztb-ollama-fallback\" });\n\t\t\t\tfallback.createEl(\"p\", { text: \"Ollama not reachable or no models. Enter model names manually.\" });\n\t\t\t\tnew Setting(ollamaContainer)\n\t\t\t\t\t.setName(\"Model node (primary)\")\n\t\t\t\t\t.setDesc(\"Ollama model used when you run a primary model node (e.g. llama2)\")\n\t\t\t\t\t.addText((text) =&gt; text\n\t\t\t\t\t\t.setPlaceholder(\"e.g. llama2\")\n\t\t\t\t\t\t.setValue(s.ollamaOrangeModel)\n\t\t\t\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t\t\t\tthis.plugin.settings.ollamaOrangeModel = value;\n\t\t\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t\t\t}));\n\t\t\t\tnew Setting(ollamaContainer)\n\t\t\t\t\t.setName(\"Model node (secondary)\")\n\t\t\t\t\t.setDesc(\"Ollama model used when you run a secondary model node\")\n\t\t\t\t\t.addText((text) =&gt; text\n\t\t\t\t\t\t.setPlaceholder(\"e.g. mistral\")\n\t\t\t\t\t\t.setValue(s.ollamaPurpleModel)\n\t\t\t\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t\t\t\ts.ollamaPurpleModel = value;\n\t\t\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnew Setting(ollamaContainer)\n\t\t\t\t.setName(\"Model node (primary)\")\n\t\t\t\t.setDesc\n\n\t\t}\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 176,
                "column": 1
              },
              "endPosition": {
                "line": 176,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 176,
                "column": 8
              },
              "endPosition": {
                "line": 177,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export class ZettelSettingTab extends PluginSettingTab {",
            "lineNumber": 176,
            "isSignature": true
          },
          {
            "lineNumber": 182
          },
          {
            "lineNumber": 183
          },
          {
            "text": "\tdisplay(): void {",
            "lineNumber": 184
          },
          {
            "text": "\t\tconst {containerEl} = this;",
            "lineNumber": 185
          },
          {
            "text": "\t\tcontainerEl.empty();",
            "lineNumber": 186
          },
          {
            "text": "\t\tconst s = this.plugin.settings;",
            "lineNumber": 187
          },
          {
            "lineNumber": 188
          },
          {
            "text": "\t\t// How to run: one-line hint (per UX suggestion)",
            "lineNumber": 189
          },
          {
            "text": "\t\tconst hint = containerEl.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });",
            "lineNumber": 190
          },
          {
            "text": "\t\thint.setText(\"Right-click a node on the canvas and choose Run node or Run chain.\");",
            "lineNumber": 191
          },
          {
            "lineNumber": 192
          },
          {
            "text": "\t\t// Execution: what runs (primary model, secondary model, Python path)",
            "lineNumber": 193
          },
          {
            "text": "\t\tconst executionSection = containerEl.createDiv({ cls: \"ztb-settings-section\" });",
            "lineNumber": 194
          },
          {
            "text": "\t\texecutionSection.createEl(\"h4\", { text: \"Execution\", cls: \"ztb-section-title\" });",
            "lineNumber": 195
          },
          {
            "text": "\t\tconst ollamaContainer = executionSection.createDiv({ cls: \"ztb-ollama-settings\" });",
            "lineNumber": 196
          },
          {
            "text": "\t\tconst loadingEl = ollamaContainer.createDiv({ cls: \"ztb-ollama-loading\" });",
            "lineNumber": 197
          },
          {
            "text": "\t\tloadingEl.setText(\"Loading Ollama models\");",
            "lineNumber": 198
          },
          {
            "text": "\t\t(async () =&gt; {",
            "lineNumber": 199
          },
          {
            "text": "\t\t\tconst models = await fetchOllamaModels();",
            "lineNumber": 200
          },
          {
            "text": "\t\t\tloadingEl.remove();",
            "lineNumber": 201
          },
          {
            "text": "\t\t\tif (models.length === 0) {",
            "lineNumber": 202
          },
          {
            "text": "\t\t\t\tconst fallback = ollamaContainer.createDiv({ cls: \"ztb-ollama-fallback\" });",
            "lineNumber": 203
          },
          {
            "text": "\t\t\t\tfallback.createEl(\"p\", { text: \"Ollama not reachable or no models. Enter model names manually.\" });",
            "lineNumber": 204
          },
          {
            "text": "\t\t\t\tnew Setting(ollamaContainer)",
            "lineNumber": 205
          },
          {
            "text": "\t\t\t\t\t.setName(\"Model node (primary)\")",
            "lineNumber": 206
          },
          {
            "text": "\t\t\t\t\t.setDesc(\"Ollama model used when you run a primary model node (e.g. llama2)\")",
            "lineNumber": 207
          },
          {
            "text": "\t\t\t\t\t.addText((text) =&gt; text",
            "lineNumber": 208
          },
          {
            "text": "\t\t\t\t\t\t.setPlaceholder(\"e.g. llama2\")",
            "lineNumber": 209
          },
          {
            "text": "\t\t\t\t\t\t.setValue(s.ollamaOrangeModel)",
            "lineNumber": 210
          },
          {
            "text": "\t\t\t\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 211
          },
          {
            "text": "\t\t\t\t\t\t\tthis.plugin.settings.ollamaOrangeModel = value;",
            "lineNumber": 212
          },
          {
            "text": "\t\t\t\t\t\t\tawait this.plugin.saveSettings();",
            "lineNumber": 213
          },
          {
            "text": "\t\t\t\t\t\t}));",
            "lineNumber": 214
          },
          {
            "text": "\t\t\t\tnew Setting(ollamaContainer)",
            "lineNumber": 215
          },
          {
            "text": "\t\t\t\t\t.setName(\"Model node (secondary)\")",
            "lineNumber": 216
          },
          {
            "text": "\t\t\t\t\t.setDesc(\"Ollama model used when you run a secondary model node\")",
            "lineNumber": 217
          },
          {
            "text": "\t\t\t\t\t.addText((text) =&gt; text",
            "lineNumber": 218
          },
          {
            "text": "\t\t\t\t\t\t.setPlaceholder(\"e.g. mistral\")",
            "lineNumber": 219
          },
          {
            "text": "\t\t\t\t\t\t.setValue(s.ollamaPurpleModel)",
            "lineNumber": 220
          },
          {
            "text": "\t\t\t\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 221
          },
          {
            "text": "\t\t\t\t\t\t\ts.ollamaPurpleModel = value;",
            "lineNumber": 222
          },
          {
            "text": "\t\t\t\t\t\t\tawait this.plugin.saveSettings();",
            "lineNumber": 223
          },
          {
            "text": "\t\t\t\t\t\t}));",
            "lineNumber": 224
          },
          {
            "text": "\t\t\t\treturn;",
            "lineNumber": 225
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 226
          },
          {
            "text": "\t\t\tnew Setting(ollamaContainer)",
            "lineNumber": 227
          },
          {
            "text": "\t\t\t\t.setName(\"Model node (primary)\")",
            "lineNumber": 228
          },
          {
            "text": "\t\t\t\t.setDesc",
            "lineNumber": 229
          },
          {
            "lineNumber": 238
          },
          {
            "text": "\t\t}",
            "lineNumber": 251
          },
          {
            "text": "\t}",
            "lineNumber": 312
          },
          {
            "text": "}",
            "lineNumber": 313,
            "isSignature": true
          }
        ]
      },
      "score": 0.14656640589237213
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 18,
            "column": 1
          },
          "endPosition": {
            "line": 34,
            "column": 49
          }
        },
        "contents": "/** Classify node role by comparing node color to settings. */\nexport function getNodeRole(node: { color?: CanvasColor }, settings: ZettelPluginSettings): NodeRole | null {\n\tconst nodeColor = normalizeColor(node.color);\n\tif (!nodeColor) return null;\n\tconst roles: NodeRole[] = [\"orange\", \"purple\", \"blue\", \"yellow\", \"green\"];\n\tfor (const role of roles) {\n\t\tconst key = &#96;color${role.charAt(0).toUpperCase() + role.slice(1)}&#96; as keyof ZettelPluginSettings;\n\t\tconst settingColor = normalizeColor(settings[key] as CanvasColor | undefined);\n\t\tif (settingColor &amp;&amp; nodeColor === settingColor) return role;\n\t}\n\treturn null;\n}\n\n/** Suffixes we add to edge labels after run to show inject vs concatenate. */\nexport const EDGE_LABEL_INJECTED = \" (injected)\";",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Classify node role by comparing node color to settings. */",
            "lineNumber": 21
          },
          {
            "text": "export function getNodeRole(node: { color?: CanvasColor }, settings: ZettelPluginSettings): NodeRole | null {",
            "lineNumber": 22,
            "isSignature": true
          },
          {
            "text": "\tconst nodeColor = normalizeColor(node.color);",
            "lineNumber": 23
          },
          {
            "text": "\tif (!nodeColor) return null;",
            "lineNumber": 24
          },
          {
            "text": "\tconst roles: NodeRole[] = [\"orange\", \"purple\", \"blue\", \"yellow\", \"green\"];",
            "lineNumber": 25
          },
          {
            "text": "\tfor (const role of roles) {",
            "lineNumber": 26
          },
          {
            "text": "\t\tconst key = &#96;color${role.charAt(0).toUpperCase() + role.slice(1)}&#96; as keyof ZettelPluginSettings;",
            "lineNumber": 27
          },
          {
            "text": "\t\tconst settingColor = normalizeColor(settings[key] as CanvasColor | undefined);",
            "lineNumber": 28
          },
          {
            "text": "\t\tif (settingColor &amp;&amp; nodeColor === settingColor) return role;",
            "lineNumber": 29
          },
          {
            "text": "\t}",
            "lineNumber": 30
          },
          {
            "text": "\treturn null;",
            "lineNumber": 31
          },
          {
            "text": "}",
            "lineNumber": 32,
            "isSignature": true
          },
          {
            "lineNumber": 33
          },
          {
            "text": "/** Suffixes we add to edge labels after run to show inject vs concatenate. */",
            "lineNumber": 34
          },
          {
            "text": "export const EDGE_LABEL_INJECTED = \" (injected)\";",
            "lineNumber": 35
          }
        ]
      },
      "score": 0.14215080440044403
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\n\n\n\t/** Run chain from roots to the given node (call from context menu with node id). */\n\tasync runChain(nodeId: string): Promise&lt;void&gt; {\n\t\tconst view = this.getActiveCanvasView();\n\t\tif (!view) return;\n\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;\n\t\tconst result = await runnerRunChain(this.app, this.settings, view.file.path, nodeId, liveCanvas);\n\t\tif (!result.ok) new Notice(result.message ?? \"Run chain failed.\");\n\t}\n\n\t/** Dismiss the Green output node for the given source node (call from context menu with node id). */\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "lineNumber": 348
          },
          {
            "lineNumber": 349
          },
          {
            "text": "\t/** Run chain from roots to the given node (call from context menu with node id). */",
            "lineNumber": 350
          },
          {
            "text": "\tasync runChain(nodeId: string): Promise&lt;void&gt; {",
            "lineNumber": 351
          },
          {
            "text": "\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 352
          },
          {
            "text": "\t\tif (!view) return;",
            "lineNumber": 353
          },
          {
            "text": "\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;",
            "lineNumber": 354
          },
          {
            "text": "\t\tconst result = await runnerRunChain(this.app, this.settings, view.file.path, nodeId, liveCanvas);",
            "lineNumber": 355
          },
          {
            "text": "\t\tif (!result.ok) new Notice(result.message ?? \"Run chain failed.\");",
            "lineNumber": 356
          },
          {
            "text": "\t}",
            "lineNumber": 357
          },
          {
            "lineNumber": 358
          },
          {
            "text": "\t/** Dismiss the Green output node for the given source node (call from context menu with node id). */",
            "lineNumber": 359
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.13683709502220154
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 37,
            "column": 1
          },
          "endPosition": {
            "line": 55,
            "column": 101
          }
        },
        "contents": "/** Check if there is a path from fromId to toId (ignoring output edges). */\nfunction canReach(data: CanvasData, fromId: string, toId: string): boolean {\n\tconst visited = new Set&lt;string&gt;();\n\tconst stack = [fromId];\n\twhile (stack.length &gt; 0) {\n\t\tconst id = stack.pop()!;\n\t\tif (id === toId) return true;\n\t\tif (visited.has(id)) continue;\n\t\tvisited.add(id);\n\t\tfor (const e of data.edges) {\n\t\t\tif (!isOutputEdge(e) &amp;&amp; e.fromNode === id) stack.push(e.toNode);\n\t\t}\n\t}\n\treturn false;\n}\n\n/** Topological order of node ids (only nodes that are ancestors of target; ignores output edges). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Check if there is a path from fromId to toId (ignoring output edges). */",
            "lineNumber": 40
          },
          {
            "text": "function canReach(data: CanvasData, fromId: string, toId: string): boolean {",
            "lineNumber": 41,
            "isSignature": true
          },
          {
            "text": "\tconst visited = new Set&lt;string&gt;();",
            "lineNumber": 42
          },
          {
            "text": "\tconst stack = [fromId];",
            "lineNumber": 43
          },
          {
            "text": "\twhile (stack.length &gt; 0) {",
            "lineNumber": 44
          },
          {
            "text": "\t\tconst id = stack.pop()!;",
            "lineNumber": 45
          },
          {
            "text": "\t\tif (id === toId) return true;",
            "lineNumber": 46
          },
          {
            "text": "\t\tif (visited.has(id)) continue;",
            "lineNumber": 47
          },
          {
            "text": "\t\tvisited.add(id);",
            "lineNumber": 48
          },
          {
            "text": "\t\tfor (const e of data.edges) {",
            "lineNumber": 49
          },
          {
            "text": "\t\t\tif (!isOutputEdge(e) &amp;&amp; e.fromNode === id) stack.push(e.toNode);",
            "lineNumber": 50
          },
          {
            "text": "\t\t}",
            "lineNumber": 51
          },
          {
            "text": "\t}",
            "lineNumber": 52
          },
          {
            "text": "\treturn false;",
            "lineNumber": 53
          },
          {
            "text": "}",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "lineNumber": 55
          },
          {
            "text": "/** Topological order of node ids (only nodes that are ancestors of target; ignores output edges). */",
            "lineNumber": 56
          }
        ]
      },
      "score": 0.12824580073356628
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\n\n\n\t/** Run a single node (call from context menu with node id). */\n\tasync runNode(nodeId: string): Promise&lt;void&gt; {\n\t\tconst view = this.getActiveCanvasView();\n\t\tif (!view) return;\n\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;\n\t\tconst result = await runnerRunNode(this.app, this.settings, view.file.path, nodeId, liveCanvas);\n\t\tif (!result.ok) new Notice(result.message ?? \"Run node failed.\");\n\t}\n\n\t/** Run chain from roots to the given node (call from context menu with node id). */\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "lineNumber": 339
          },
          {
            "lineNumber": 340
          },
          {
            "text": "\t/** Run a single node (call from context menu with node id). */",
            "lineNumber": 341
          },
          {
            "text": "\tasync runNode(nodeId: string): Promise&lt;void&gt; {",
            "lineNumber": 342
          },
          {
            "text": "\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 343
          },
          {
            "text": "\t\tif (!view) return;",
            "lineNumber": 344
          },
          {
            "text": "\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;",
            "lineNumber": 345
          },
          {
            "text": "\t\tconst result = await runnerRunNode(this.app, this.settings, view.file.path, nodeId, liveCanvas);",
            "lineNumber": 346
          },
          {
            "text": "\t\tif (!result.ok) new Notice(result.message ?? \"Run node failed.\");",
            "lineNumber": 347
          },
          {
            "text": "\t}",
            "lineNumber": 348
          },
          {
            "lineNumber": 349
          },
          {
            "text": "\t/** Run chain from roots to the given node (call from context menu with node id). */",
            "lineNumber": 350
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.10444270074367523
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Canvas update or refresh that could cause flickering",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\n\n\t\t\ttry {\n\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace) as (\n\t\t\t\t\tname: string,\n\t\t\t\t\tcallback: (menu: Menu, edge: unknown) =&gt; void\n\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;\n\t\t\t\tthis.registerEvent(\n\t\t\t\t\tonWorkspace(\"canvas:edge-menu\", (menu: Menu, edge: unknown) =&gt; {\n\t\t\t\t\t\tif (edge == null) addCanvasMenuItems(menu);\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas background menu.\", e);\n\t\t\t}\n\n\t\t\t// Debug: command to test if we can affect the canvas and if canvas:node-menu ever fires.\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"zettel-debug-canvas-hook\",\n\t\t\t\tname: \"Debug canvas hook\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tconst canvasActive = this.getActiveCanvasView() != null;\n\t\t\t\t\tconst msg =\n\t\t\t\t\t\t\"Canvas active: \" +\n\t\t\t\t\t\t(canvasActive ? \"yes\" : \"no (focus a canvas first)\") +\n\t\t\t\t\t\t\". Node menu ever fired: \" +\n\t\t\t\t\t\t(debugNodeMenuFired ? \"yes\" : \"no (right-click a node to test).\");\n\t\t\t\t\tnew Notice(msg);\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Terminate kernel when a canvas is closed (one kernel per canvas)\n\t\t\tlet previousCanvasPaths = new Set&lt;string&gt;();\n\t\t\tthis.registerEvent(\n\t\t\t\tthis.app.workspace.on(\"layout-change\", () =&gt; {\n\t\t\t\t\tconst leaves = this.app.workspace.getLeavesOfType(\"canvas\");\n\t\t\t\t\tconst openPaths = new Set&lt;string&gt;();\n\t\t\t\t\tfor (const leaf of leaves) {\n\t\t\t\t\t\tconst v = leaf.view as { file?: { path: string } };\n\t\t\t\t\t\tif (v?.file?.path) openPaths.add(v.file.path);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const path of previousCanvasPaths) {\n\t\t\t\t\t\tif (!openPaths.has(path)) terminateKernel(path);\n\t\t\t\t\t}\n\t\t\t\t\tpreviousCanvasPaths = openPaths;\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Floating role labels on canvas: sync when active leaf is a canvas, clear when not\n\t\t\tlet roleLabelsContainerEl: HTMLElement | null = null;\n\t\t\tlet roleLabelsIntervalId: number | null = null;\n\t\t\tconst runSyncLabels = (): void =&gt; {\n\t\t\t\tconst view = this.getActiveCanvasView();\n;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 37,
                "column": 2
              },
              "endPosition": {
                "line": 38,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 37
          },
          {
            "lineNumber": 132
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 133
          },
          {
            "text": "\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace) as (",
            "lineNumber": 134
          },
          {
            "text": "\t\t\t\t\tname: string,",
            "lineNumber": 135
          },
          {
            "text": "\t\t\t\t\tcallback: (menu: Menu, edge: unknown) =&gt; void",
            "lineNumber": 136
          },
          {
            "text": "\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;",
            "lineNumber": 137
          },
          {
            "text": "\t\t\t\tthis.registerEvent(",
            "lineNumber": 138
          },
          {
            "text": "\t\t\t\t\tonWorkspace(\"canvas:edge-menu\", (menu: Menu, edge: unknown) =&gt; {",
            "lineNumber": 139
          },
          {
            "text": "\t\t\t\t\t\tif (edge == null) addCanvasMenuItems(menu);",
            "lineNumber": 140
          },
          {
            "text": "\t\t\t\t\t})",
            "lineNumber": 141
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 142
          },
          {
            "text": "\t\t\t} catch (e) {",
            "lineNumber": 143
          },
          {
            "text": "\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas background menu.\", e);",
            "lineNumber": 144
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 145
          },
          {
            "lineNumber": 146
          },
          {
            "text": "\t\t\t// Debug: command to test if we can affect the canvas and if canvas:node-menu ever fires.",
            "lineNumber": 147
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 148
          },
          {
            "text": "\t\t\t\tid: \"zettel-debug-canvas-hook\",",
            "lineNumber": 149
          },
          {
            "text": "\t\t\t\tname: \"Debug canvas hook\",",
            "lineNumber": 150
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 151
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 152
          },
          {
            "text": "\t\t\t\t\tconst canvasActive = this.getActiveCanvasView() != null;",
            "lineNumber": 153
          },
          {
            "text": "\t\t\t\t\tconst msg =",
            "lineNumber": 154
          },
          {
            "text": "\t\t\t\t\t\t\"Canvas active: \" +",
            "lineNumber": 155
          },
          {
            "text": "\t\t\t\t\t\t(canvasActive ? \"yes\" : \"no (focus a canvas first)\") +",
            "lineNumber": 156
          },
          {
            "text": "\t\t\t\t\t\t\". Node menu ever fired: \" +",
            "lineNumber": 157
          },
          {
            "text": "\t\t\t\t\t\t(debugNodeMenuFired ? \"yes\" : \"no (right-click a node to test).\");",
            "lineNumber": 158
          },
          {
            "text": "\t\t\t\t\tnew Notice(msg);",
            "lineNumber": 159
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 160
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 161
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 162
          },
          {
            "lineNumber": 163
          },
          {
            "text": "\t\t\t// Terminate kernel when a canvas is closed (one kernel per canvas)",
            "lineNumber": 164
          },
          {
            "text": "\t\t\tlet previousCanvasPaths = new Set&lt;string&gt;();",
            "lineNumber": 165
          },
          {
            "text": "\t\t\tthis.registerEvent(",
            "lineNumber": 166
          },
          {
            "text": "\t\t\t\tthis.app.workspace.on(\"layout-change\", () =&gt; {",
            "lineNumber": 167
          },
          {
            "text": "\t\t\t\t\tconst leaves = this.app.workspace.getLeavesOfType(\"canvas\");",
            "lineNumber": 168
          },
          {
            "text": "\t\t\t\t\tconst openPaths = new Set&lt;string&gt;();",
            "lineNumber": 169
          },
          {
            "text": "\t\t\t\t\tfor (const leaf of leaves) {",
            "lineNumber": 170
          },
          {
            "text": "\t\t\t\t\t\tconst v = leaf.view as { file?: { path: string } };",
            "lineNumber": 171
          },
          {
            "text": "\t\t\t\t\t\tif (v?.file?.path) openPaths.add(v.file.path);",
            "lineNumber": 172
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 173
          },
          {
            "text": "\t\t\t\t\tfor (const path of previousCanvasPaths) {",
            "lineNumber": 174
          },
          {
            "text": "\t\t\t\t\t\tif (!openPaths.has(path)) terminateKernel(path);",
            "lineNumber": 175
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 176
          },
          {
            "text": "\t\t\t\t\tpreviousCanvasPaths = openPaths;",
            "lineNumber": 177
          },
          {
            "text": "\t\t\t\t})",
            "lineNumber": 178
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 179
          },
          {
            "lineNumber": 180
          },
          {
            "text": "\t\t\t// Floating role labels on canvas: sync when active leaf is a canvas, clear when not",
            "lineNumber": 181
          },
          {
            "text": "\t\t\tlet roleLabelsContainerEl: HTMLElement | null = null;",
            "lineNumber": 182
          },
          {
            "text": "\t\t\tlet roleLabelsIntervalId: number | null = null;",
            "lineNumber": 183
          },
          {
            "text": "\t\t\tconst runSyncLabels = (): void =&gt; {",
            "lineNumber": 184
          },
          {
            "text": "\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 185
          },
          {
            "text": ";",
            "lineNumber": 240
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.29777973890304565
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\nconst runSyncLabels = \n\n\t\t\t\tif (leaf?.view) {\n\t\t\t\t\tconst itemView = leaf.view as ViewWithFlag;\n\t\t\t\t\tif (itemView._ztbTitleBarActionsAdded) {\n\t\t\t\t\t\taddedToTitleBar = true;\n\t\t\t\t\t} else if (typeof itemView.addAction === \"function\") {\n\t\t\t\t\t\titemView.addAction(\"play\", \"Run entire canvas\", () =&gt; this.runEntireCanvas());\n\t\t\t\t\t\titemView.addAction(\"trash\", \"Dismiss all output\", () =&gt; this.dismissAllOutput());\n\t\t\t\t\t\titemView._ztbTitleBarActionsAdded = true;\n\t\t\t\t\t\taddedToTitleBar = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addedToTitleBar) this.addCanvasToolbarToContainer(view.containerEl);\n\t\t\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;\n\t\t\t\tconst isStillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;\n\t\t\t\tsyncCanvasRoleLabels(this.app.vault, view.file.path, view.containerEl, this.settings, liveCanvas, isStillActive);\n\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, view.file.path, view.containerEl, liveCanvas, isStillActive);\n\t\t\t\tif (roleLabelsIntervalId == null) {\n\t\t\t\t\troleLabelsIntervalId = window.setInterval(() =&gt; {\n\t\t\t\t\t\tconst v = this.getActiveCanvasView();\n\t\t\t\t\t\tif (v != null &amp;&amp; v.containerEl === roleLabelsContainerEl) {\n\t\t\t\t\t\t\tconst stillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;\n\t\t\t\t\t\t\tsyncCanvasRoleLabels(this.app.vault, v.file.path, v.containerEl, this.settings, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);\n\t\t\t\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, v.file.path, v.containerEl, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 2000);\n\t\t\t\t\t(this as unknown as { _roleLabelsIntervalId: number })._roleLabelsIntervalId = roleLabelsIntervalId;\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.registerEvent(this.app.workspace.on(\"active-leaf-change\", runSyncLabels));\n\t\t\trunSyncLabels();\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Zettel Thinking Board onload error:\", e);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tonunload() {\n\t\tterminateAllKernels();\n\t\tconst id = (;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 37,
                "column": 2
              },
              "endPosition": {
                "line": 38,
                "column": 3
              }
            },
            {
              "startPosition": {
                "line": 184,
                "column": 4
              },
              "endPosition": {
                "line": 184,
                "column": 10
              }
            },
            {
              "startPosition": {
                "line": 184,
                "column": 10
              },
              "endPosition": {
                "line": 184,
                "column": 26
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 37
          },
          {
            "text": "const runSyncLabels = ",
            "lineNumber": 184
          },
          {
            "lineNumber": 212
          },
          {
            "text": "\t\t\t\tif (leaf?.view) {",
            "lineNumber": 213
          },
          {
            "text": "\t\t\t\t\tconst itemView = leaf.view as ViewWithFlag;",
            "lineNumber": 214
          },
          {
            "text": "\t\t\t\t\tif (itemView._ztbTitleBarActionsAdded) {",
            "lineNumber": 215
          },
          {
            "text": "\t\t\t\t\t\taddedToTitleBar = true;",
            "lineNumber": 216
          },
          {
            "text": "\t\t\t\t\t} else if (typeof itemView.addAction === \"function\") {",
            "lineNumber": 217
          },
          {
            "text": "\t\t\t\t\t\titemView.addAction(\"play\", \"Run entire canvas\", () =&gt; this.runEntireCanvas());",
            "lineNumber": 218
          },
          {
            "text": "\t\t\t\t\t\titemView.addAction(\"trash\", \"Dismiss all output\", () =&gt; this.dismissAllOutput());",
            "lineNumber": 219
          },
          {
            "text": "\t\t\t\t\t\titemView._ztbTitleBarActionsAdded = true;",
            "lineNumber": 220
          },
          {
            "text": "\t\t\t\t\t\taddedToTitleBar = true;",
            "lineNumber": 221
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 222
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 223
          },
          {
            "text": "\t\t\t\tif (!addedToTitleBar) this.addCanvasToolbarToContainer(view.containerEl);",
            "lineNumber": 224
          },
          {
            "text": "\t\t\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;",
            "lineNumber": 225
          },
          {
            "text": "\t\t\t\tconst isStillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;",
            "lineNumber": 226
          },
          {
            "text": "\t\t\t\tsyncCanvasRoleLabels(this.app.vault, view.file.path, view.containerEl, this.settings, liveCanvas, isStillActive);",
            "lineNumber": 227
          },
          {
            "text": "\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, view.file.path, view.containerEl, liveCanvas, isStillActive);",
            "lineNumber": 228
          },
          {
            "text": "\t\t\t\tif (roleLabelsIntervalId == null) {",
            "lineNumber": 229
          },
          {
            "text": "\t\t\t\t\troleLabelsIntervalId = window.setInterval(() =&gt; {",
            "lineNumber": 230
          },
          {
            "text": "\t\t\t\t\t\tconst v = this.getActiveCanvasView();",
            "lineNumber": 231
          },
          {
            "text": "\t\t\t\t\t\tif (v != null &amp;&amp; v.containerEl === roleLabelsContainerEl) {",
            "lineNumber": 232
          },
          {
            "text": "\t\t\t\t\t\t\tconst stillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;",
            "lineNumber": 233
          },
          {
            "text": "\t\t\t\t\t\t\tsyncCanvasRoleLabels(this.app.vault, v.file.path, v.containerEl, this.settings, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);",
            "lineNumber": 234
          },
          {
            "text": "\t\t\t\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, v.file.path, v.containerEl, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);",
            "lineNumber": 235
          },
          {
            "text": "\t\t\t\t\t\t}",
            "lineNumber": 236
          },
          {
            "text": "\t\t\t\t\t}, 2000);",
            "lineNumber": 237
          },
          {
            "text": "\t\t\t\t\t(this as unknown as { _roleLabelsIntervalId: number })._roleLabelsIntervalId = roleLabelsIntervalId;",
            "lineNumber": 238
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 239
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 240
          },
          {
            "text": "\t\t\tthis.registerEvent(this.app.workspace.on(\"active-leaf-change\", runSyncLabels));",
            "lineNumber": 241
          },
          {
            "text": "\t\t\trunSyncLabels();",
            "lineNumber": 242
          },
          {
            "text": "\t\t} catch (e) {",
            "lineNumber": 243
          },
          {
            "text": "\t\t\tconsole.error(\"Zettel Thinking Board onload error:\", e);",
            "lineNumber": 244
          },
          {
            "text": "\t\t\tthrow e;",
            "lineNumber": 245
          },
          {
            "text": "\t\t}",
            "lineNumber": 246
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "lineNumber": 248
          },
          {
            "text": "\tonunload() {",
            "lineNumber": 249
          },
          {
            "text": "\t\tterminateAllKernels();",
            "lineNumber": 250
          },
          {
            "text": "\t\tconst id = (;",
            "lineNumber": 251
          },
          {
            "text": "\t}",
            "lineNumber": 253
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.2944011688232422
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 414,
            "column": 1
          },
          "endPosition": {
            "line": 470,
            "column": 1
          }
        },
        "contents": "/** Run all nodes reachable from any root, in topological order. */\nexport async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst order = topologicalOrderFull(data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\ttry {\n\t\tfor (const nid of order) {\n\t\t\ttry {\n\t\t\t\tsetRunningNodeId(canvasKey, nid);\n\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);\n\t\t\t} finally {\n\t\t\t\tsetRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t}\n}\n\n/** Run chain from roots to the given node. */\nexport async function runChain(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run all nodes reachable from any root, in topological order. */",
            "lineNumber": 417
          },
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 418,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 419,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 420,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 421,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 422,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 423,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 424
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 425
          },
          {
            "text": "\tconst order = topologicalOrderFull(data);",
            "lineNumber": 426
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 427
          },
          {
            "text": "\ttry {",
            "lineNumber": 428
          },
          {
            "text": "\t\tfor (const nid of order) {",
            "lineNumber": 429
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 430
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, nid);",
            "lineNumber": 431
          },
          {
            "text": "\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);",
            "lineNumber": 432
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 433
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 434
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 435
          },
          {
            "text": "\t\t}",
            "lineNumber": 436
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 437
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 438
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 439
          },
          {
            "text": "\t}",
            "lineNumber": 440
          },
          {
            "text": "}",
            "lineNumber": 441,
            "isSignature": true
          },
          {
            "lineNumber": 442
          },
          {
            "text": "/** Run chain from roots to the given node. */",
            "lineNumber": 443
          },
          {
            "text": "export async function runChain(",
            "lineNumber": 444,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 445,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 446,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 447,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 448,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 449,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 450,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 451
          },
          {
            "text": "}",
            "lineNumber": 471,
            "isSignature": true
          }
        ]
      },
      "score": 0.24593353271484375
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\n\n\t\t\tconst runSyncLabels = (): void =&gt; {\n\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\tif (!view) {\n\t\t\t\t\tif (roleLabelsIntervalId != null) {\n\t\t\t\t\t\tclearInterval(roleLabelsIntervalId);\n\t\t\t\t\t\troleLabelsIntervalId = null;\n\t\t\t\t\t\tdelete (this as unknown as Record&lt;string, unknown&gt;)._roleLabelsIntervalId;\n\t\t\t\t\t}\n\t\t\t\t\tif (roleLabelsContainerEl != null) {\n\t\t\t\t\t\tclearCanvasRoleLabels(roleLabelsContainerEl);\n\t\t\t\t\t\tclearCanvasLegend(roleLabelsContainerEl);\n\t\t\t\t\t\tclearCanvasEdgeModeLabels(roleLabelsContainerEl);\n\t\t\t\t\t\tthis.clearCanvasToolbar(roleLabelsContainerEl);\n\t\t\t\t\t\troleLabelsContainerEl = null;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (roleLabelsContainerEl != null &amp;&amp; roleLabelsContainerEl !== view.containerEl) {\n\t\t\t\t\tclearCanvasRoleLabels(roleLabelsContainerEl);\n\t\t\t\t\tclearCanvasLegend(roleLabelsContainerEl);\n\t\t\t\t\tclearCanvasEdgeModeLabels(roleLabelsContainerEl);\n\t\t\t\t\tthis.clearCanvasToolbar(roleLabelsContainerEl);\n\t\t\t\t}\n\t\t\t\troleLabelsContainerEl = view.containerEl;\n\t\t\t\t// Add \"Run entire canvas\" and \"Dismiss all output\" to the canvas (title bar if supported, else toolbar in container).\n\t\t\t\t// Use a property on the view so we only add once even after plugin hot-reload (WeakSet would be cleared on reload).\n\t\t\t\tconst leaf = this.app.workspace.activeLeaf;\n\t\t\t\tlet addedToTitleBar = false;\n\t\t\t\ttype ViewWithFlag = ItemView &amp; { addAction?: (icon: string, title: string, callback: (evt: MouseEvent) =&gt; void) =&gt; HTMLElement; _ztbTitleBarActionsAdded?: boolean };\n\t\t\t\tif (leaf?.view) {\n\t\t\t\t\tconst itemView = leaf.view as ViewWithFlag;\n;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 37,
                "column": 2
              },
              "endPosition": {
                "line": 38,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 37
          },
          {
            "lineNumber": 183
          },
          {
            "text": "\t\t\tconst runSyncLabels = (): void =&gt; {",
            "lineNumber": 184
          },
          {
            "text": "\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 185
          },
          {
            "text": "\t\t\t\tif (!view) {",
            "lineNumber": 186
          },
          {
            "text": "\t\t\t\t\tif (roleLabelsIntervalId != null) {",
            "lineNumber": 187
          },
          {
            "text": "\t\t\t\t\t\tclearInterval(roleLabelsIntervalId);",
            "lineNumber": 188
          },
          {
            "text": "\t\t\t\t\t\troleLabelsIntervalId = null;",
            "lineNumber": 189
          },
          {
            "text": "\t\t\t\t\t\tdelete (this as unknown as Record&lt;string, unknown&gt;)._roleLabelsIntervalId;",
            "lineNumber": 190
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 191
          },
          {
            "text": "\t\t\t\t\tif (roleLabelsContainerEl != null) {",
            "lineNumber": 192
          },
          {
            "text": "\t\t\t\t\t\tclearCanvasRoleLabels(roleLabelsContainerEl);",
            "lineNumber": 193
          },
          {
            "text": "\t\t\t\t\t\tclearCanvasLegend(roleLabelsContainerEl);",
            "lineNumber": 194
          },
          {
            "text": "\t\t\t\t\t\tclearCanvasEdgeModeLabels(roleLabelsContainerEl);",
            "lineNumber": 195
          },
          {
            "text": "\t\t\t\t\t\tthis.clearCanvasToolbar(roleLabelsContainerEl);",
            "lineNumber": 196
          },
          {
            "text": "\t\t\t\t\t\troleLabelsContainerEl = null;",
            "lineNumber": 197
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 198
          },
          {
            "text": "\t\t\t\t\treturn;",
            "lineNumber": 199
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 200
          },
          {
            "text": "\t\t\t\tif (roleLabelsContainerEl != null &amp;&amp; roleLabelsContainerEl !== view.containerEl) {",
            "lineNumber": 201
          },
          {
            "text": "\t\t\t\t\tclearCanvasRoleLabels(roleLabelsContainerEl);",
            "lineNumber": 202
          },
          {
            "text": "\t\t\t\t\tclearCanvasLegend(roleLabelsContainerEl);",
            "lineNumber": 203
          },
          {
            "text": "\t\t\t\t\tclearCanvasEdgeModeLabels(roleLabelsContainerEl);",
            "lineNumber": 204
          },
          {
            "text": "\t\t\t\t\tthis.clearCanvasToolbar(roleLabelsContainerEl);",
            "lineNumber": 205
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 206
          },
          {
            "text": "\t\t\t\troleLabelsContainerEl = view.containerEl;",
            "lineNumber": 207
          },
          {
            "text": "\t\t\t\t// Add \"Run entire canvas\" and \"Dismiss all output\" to the canvas (title bar if supported, else toolbar in container).",
            "lineNumber": 208
          },
          {
            "text": "\t\t\t\t// Use a property on the view so we only add once even after plugin hot-reload (WeakSet would be cleared on reload).",
            "lineNumber": 209
          },
          {
            "text": "\t\t\t\tconst leaf = this.app.workspace.activeLeaf;",
            "lineNumber": 210
          },
          {
            "text": "\t\t\t\tlet addedToTitleBar = false;",
            "lineNumber": 211
          },
          {
            "text": "\t\t\t\ttype ViewWithFlag = ItemView &amp; { addAction?: (icon: string, title: string, callback: (evt: MouseEvent) =&gt; void) =&gt; HTMLElement; _ztbTitleBarActionsAdded?: boolean };",
            "lineNumber": 212
          },
          {
            "text": "\t\t\t\tif (leaf?.view) {",
            "lineNumber": 213
          },
          {
            "text": "\t\t\t\t\tconst itemView = leaf.view as ViewWithFlag;",
            "lineNumber": 214
          },
          {
            "text": ";",
            "lineNumber": 240
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.23659470677375793
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/state.ts",
        "range": {
          "startPosition": {
            "line": 51,
            "column": 1
          },
          "endPosition": {
            "line": 62,
            "column": 1
          }
        },
        "contents": "export function clearCanvasState(canvasKey: string): void {\n\tcanvasState.delete(canvasKey);\n\tedgeModeState.delete(canvasKey);\n\trunningNodeState.delete(canvasKey);\n}\n\n/** Canvas key = file path for the canvas file. */\nexport function getCanvasKey(filePath: string): string {\n\treturn filePath;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export function clearCanvasState(canvasKey: string): void {",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "text": "\tcanvasState.delete(canvasKey);",
            "lineNumber": 55
          },
          {
            "text": "\tedgeModeState.delete(canvasKey);",
            "lineNumber": 56
          },
          {
            "text": "\trunningNodeState.delete(canvasKey);",
            "lineNumber": 57
          },
          {
            "text": "}",
            "lineNumber": 58,
            "isSignature": true
          },
          {
            "lineNumber": 59
          },
          {
            "text": "/** Canvas key = file path for the canvas file. */",
            "lineNumber": 60
          },
          {
            "text": "export function getCanvasKey(filePath: string): string {",
            "lineNumber": 61,
            "isSignature": true
          },
          {
            "text": "\treturn filePath;",
            "lineNumber": 62
          },
          {
            "text": "}",
            "lineNumber": 63,
            "isSignature": true
          }
        ]
      },
      "score": 0.23424269258975983
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/canvasApi.ts",
        "range": {
          "startPosition": {
            "column": 86
          },
          "endPosition": {
            "line": 15,
            "column": 1
          }
        },
        "contents": "export interface LiveCanvas {\n\tcreateTextNode(options: {\n\t\ttext: string;\n\t\tpos: { x: number; y: number };\n\t\tsize: { width: number; height: number };\n\t\tsave?: boolean;\n\t\tfocus?: boolean;\n\t}): { id: string; x: number; y: number; width: number; height: number; moveTo: (pos: { x: number; y: number }) =&gt; void; resize: (size: { width: number; height: number }) =&gt; void };\n\taddNode(node: unknown): void;\n\trequestSave?: () =&gt; void;\n\tremoveNode?(node: unknown): void;\n\tnodes?: Map&lt;string, unknown&gt; | Iterable&lt;unknown&gt;;\n\t/** If present, used to refresh canvas after edge label updates (Obsidian canvas view). */\n\tsetData?(data: unknown): void;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export interface LiveCanvas {",
            "lineNumber": 2,
            "isSignature": true
          },
          {
            "text": "\tcreateTextNode(options: {",
            "lineNumber": 3
          },
          {
            "text": "\t\ttext: string;",
            "lineNumber": 4
          },
          {
            "text": "\t\tpos: { x: number; y: number };",
            "lineNumber": 5
          },
          {
            "text": "\t\tsize: { width: number; height: number };",
            "lineNumber": 6
          },
          {
            "text": "\t\tsave?: boolean;",
            "lineNumber": 7
          },
          {
            "text": "\t\tfocus?: boolean;",
            "lineNumber": 8
          },
          {
            "text": "\t}): { id: string; x: number; y: number; width: number; height: number; moveTo: (pos: { x: number; y: number }) =&gt; void; resize: (size: { width: number; height: number }) =&gt; void };",
            "lineNumber": 9
          },
          {
            "text": "\taddNode(node: unknown): void;",
            "lineNumber": 10
          },
          {
            "text": "\trequestSave?: () =&gt; void;",
            "lineNumber": 11
          },
          {
            "text": "\tremoveNode?(node: unknown): void;",
            "lineNumber": 12
          },
          {
            "text": "\tnodes?: Map&lt;string, unknown&gt; | Iterable&lt;unknown&gt;;",
            "lineNumber": 13
          },
          {
            "text": "\t/** If present, used to refresh canvas after edge label updates (Obsidian canvas view). */",
            "lineNumber": 14
          },
          {
            "text": "\tsetData?(data: unknown): void;",
            "lineNumber": 15,
            "isSignature": true
          },
          {
            "text": "}",
            "lineNumber": 16,
            "isSignature": true
          }
        ]
      },
      "score": 0.2330426573753357
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\n\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js).\n\t\t\tconst addNodeMenuItems = (menu: Menu, node: unknown): void =&gt; {\n\t\t\t\tdebugNodeMenuFired = true;\n\t\t\t\tconst nodeId = resolveCanvasNodeId(node);\n\t\t\t\tif (!nodeId) return;\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Dismiss output\").setIcon(\"trash\").onClick(() =&gt; this.dismissOutput(nodeId))\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst registerCanvasNodeMenu = () =&gt; {\n\t\t\t\ttry {\n\t\t\t\t\tconst on = this.app.workspace.on.bind(this.app.workspace) as (\n\t\t\t\t\t\tname: string,\n\t\t\t\t\t\tcallback: (menu: Menu, node: unknown) =&gt; void\n\t\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;\n\t\t\t\t\t// Try documented-style event name first; some Obsidian builds use \"canvas:node-menu\".\n\t\t\t\t\tthis.registerEvent(on(\"canvas:node-menu\", addNodeMenuItems));\n\t\t\t\t\t// Fallback: try hyphenated name in case the app triggers a different event.\n\t\t\t\t\tthis.registerEvent(on(\"canvas-node-menu\", addNodeMenuItems));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas node menu.\", e);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst timeoutId = window.setTimeout(registerCanvasNodeMenu, 0);\n\t\t\tthis.register(() =&gt; window.clearTimeout(timeoutId));\n\n\t\t\t// Canvas background context menu: use undocumented \"canvas:edge-menu\" (Obsidian broadcasts it;\n\t\t\t// when right-click is on empty area, edge is null). Same pattern as canvas:node-menu: addItem with setTitle, setIcon, onClick.\n\t\t\tconst addCanvasMenuItems = (menu: Menu): void =&gt; {\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Dismiss all output\").setIcon(\"trash\").onClick(() =&gt; this.dismissAllOutput())\n\t\t\t\t);\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace)\n;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 37,
                "column": 2
              },
              "endPosition": {
                "line": 38,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 37
          },
          {
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 90
          },
          {
            "text": "\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js).",
            "lineNumber": 91
          },
          {
            "text": "\t\t\tconst addNodeMenuItems = (menu: Menu, node: unknown): void =&gt; {",
            "lineNumber": 92
          },
          {
            "text": "\t\t\t\tdebugNodeMenuFired = true;",
            "lineNumber": 93
          },
          {
            "text": "\t\t\t\tconst nodeId = resolveCanvasNodeId(node);",
            "lineNumber": 94
          },
          {
            "text": "\t\t\t\tif (!nodeId) return;",
            "lineNumber": 95
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 96
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))",
            "lineNumber": 97
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 98
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 99
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))",
            "lineNumber": 100
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 101
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 102
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Dismiss output\").setIcon(\"trash\").onClick(() =&gt; this.dismissOutput(nodeId))",
            "lineNumber": 103
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 104
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 105
          },
          {
            "text": "\t\t\tconst registerCanvasNodeMenu = () =&gt; {",
            "lineNumber": 106
          },
          {
            "text": "\t\t\t\ttry {",
            "lineNumber": 107
          },
          {
            "text": "\t\t\t\t\tconst on = this.app.workspace.on.bind(this.app.workspace) as (",
            "lineNumber": 108
          },
          {
            "text": "\t\t\t\t\t\tname: string,",
            "lineNumber": 109
          },
          {
            "text": "\t\t\t\t\t\tcallback: (menu: Menu, node: unknown) =&gt; void",
            "lineNumber": 110
          },
          {
            "text": "\t\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;",
            "lineNumber": 111
          },
          {
            "text": "\t\t\t\t\t// Try documented-style event name first; some Obsidian builds use \"canvas:node-menu\".",
            "lineNumber": 112
          },
          {
            "text": "\t\t\t\t\tthis.registerEvent(on(\"canvas:node-menu\", addNodeMenuItems));",
            "lineNumber": 113
          },
          {
            "text": "\t\t\t\t\t// Fallback: try hyphenated name in case the app triggers a different event.",
            "lineNumber": 114
          },
          {
            "text": "\t\t\t\t\tthis.registerEvent(on(\"canvas-node-menu\", addNodeMenuItems));",
            "lineNumber": 115
          },
          {
            "text": "\t\t\t\t} catch (e) {",
            "lineNumber": 116
          },
          {
            "text": "\t\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas node menu.\", e);",
            "lineNumber": 117
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 118
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 119
          },
          {
            "text": "\t\t\tconst timeoutId = window.setTimeout(registerCanvasNodeMenu, 0);",
            "lineNumber": 120
          },
          {
            "text": "\t\t\tthis.register(() =&gt; window.clearTimeout(timeoutId));",
            "lineNumber": 121
          },
          {
            "lineNumber": 122
          },
          {
            "text": "\t\t\t// Canvas background context menu: use undocumented \"canvas:edge-menu\" (Obsidian broadcasts it;",
            "lineNumber": 123
          },
          {
            "text": "\t\t\t// when right-click is on empty area, edge is null). Same pattern as canvas:node-menu: addItem with setTitle, setIcon, onClick.",
            "lineNumber": 124
          },
          {
            "text": "\t\t\tconst addCanvasMenuItems = (menu: Menu): void =&gt; {",
            "lineNumber": 125
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 126
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())",
            "lineNumber": 127
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 128
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 129
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Dismiss all output\").setIcon(\"trash\").onClick(() =&gt; this.dismissAllOutput())",
            "lineNumber": 130
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 131
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 132
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 133
          },
          {
            "text": "\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace)",
            "lineNumber": 134
          },
          {
            "text": ";",
            "lineNumber": 137
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.22817189991474152
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/state.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 25,
            "column": 1
          }
        },
        "contents": "/** Per-canvas state: NodeID -&gt; last output result string. */\nconst canvasState = new Map&lt;string, Map&lt;string, string&gt;&gt;();\n\n/** Per-canvas edge mode: EdgeID -&gt; \"inject\" | \"concatenate\" (shown in floating label under edge). */\nconst edgeModeState = new Map&lt;string, Map&lt;string, \"inject\" | \"concatenate\"&gt;&gt;();\n\n/** Node currently running (waiting for AI/kernel) per canvas; used to show \"running\" on incoming edges. */\nconst runningNodeState = new Map&lt;string, string | null&gt;();\n\nfunction getCanvasState(canvasKey: string): Map&lt;string, string&gt; {\n\tlet map = canvasState.get(canvasKey);\n\tif (!map) {\n\t\tmap = new Map();\n\t\tcanvasState.set(canvasKey, map);\n\t}\n\treturn map;\n}\n\nfunction getEdgeModeState(canvasKey: string): Map&lt;string, \"inject\" | \"concatenate\"&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Per-canvas state: NodeID -&gt; last output result string. */",
            "lineNumber": 1
          },
          {
            "text": "const canvasState = new Map&lt;string, Map&lt;string, string&gt;&gt;();",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "/** Per-canvas edge mode: EdgeID -&gt; \"inject\" | \"concatenate\" (shown in floating label under edge). */",
            "lineNumber": 4
          },
          {
            "text": "const edgeModeState = new Map&lt;string, Map&lt;string, \"inject\" | \"concatenate\"&gt;&gt;();",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "/** Node currently running (waiting for AI/kernel) per canvas; used to show \"running\" on incoming edges. */",
            "lineNumber": 7
          },
          {
            "text": "const runningNodeState = new Map&lt;string, string | null&gt;();",
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "function getCanvasState(canvasKey: string): Map&lt;string, string&gt; {",
            "lineNumber": 10,
            "isSignature": true
          },
          {
            "text": "\tlet map = canvasState.get(canvasKey);",
            "lineNumber": 11
          },
          {
            "text": "\tif (!map) {",
            "lineNumber": 12
          },
          {
            "text": "\t\tmap = new Map();",
            "lineNumber": 13
          },
          {
            "text": "\t\tcanvasState.set(canvasKey, map);",
            "lineNumber": 14
          },
          {
            "text": "\t}",
            "lineNumber": 15
          },
          {
            "text": "\treturn map;",
            "lineNumber": 16
          },
          {
            "text": "}",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "lineNumber": 18
          },
          {
            "text": "function getEdgeModeState(canvasKey: string): Map&lt;string, \"inject\" | \"concatenate\"&gt; {",
            "lineNumber": 19,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 20
          },
          {
            "text": "}",
            "lineNumber": 26,
            "isSignature": true
          }
        ]
      },
      "score": 0.2274159938097
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 125
          },
          "endPosition": {
            "line": 173,
            "column": 1
          }
        },
        "contents": "function createLabelEl(text: string): HTMLElement {\n\n\tel.setAttribute(LABEL_DATA_ATTR, \"1\");\n\tel.textContent = text;\n\treturn el;\n}\n\n/**\n * Sync floating role labels for the active canvas: for each node whose color maps to a role,\n * add a small label above the node (e.g. \"Comment\", \"Python\"). Removes existing labels first.\n * Uses the live canvas node map to find each node's DOM element (.canvas-node).\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasRoleLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tsettings: ZettelPluginSettings,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tif (!settings.showNodeRoleLabels) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.nodes) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\tclearCanvasRoleLabels(containerEl);\n\tsyncCanvasLegend(containerEl, settings);\n\tfor (const node of data.nodes) {\n\t\tconst role = getNodeRole(node, settings);\n\t\tif (!role) continue;\n\t\tconst labelText = getRoleLabel(role, settings);\n\t\tconst nodeEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||\n\t\t\tfindNodeElementByDataId(containerEl, node.id);\n\t\tif (!nodeEl) continue;\n\t\tconst label = createLabelEl(labelText);\n\t\t// Append after .canvas-node-container so it matches Obsidian file node label position\n\t\tnodeEl.append(label);\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function createLabelEl(text: string): HTMLElement {",
            "lineNumber": 126,
            "isSignature": true
          },
          {
            "lineNumber": 128
          },
          {
            "text": "\tel.setAttribute(LABEL_DATA_ATTR, \"1\");",
            "lineNumber": 129
          },
          {
            "text": "\tel.textContent = text;",
            "lineNumber": 130
          },
          {
            "text": "\treturn el;",
            "lineNumber": 131
          },
          {
            "text": "}",
            "lineNumber": 132,
            "isSignature": true
          },
          {
            "lineNumber": 133
          },
          {
            "text": "/**",
            "lineNumber": 134
          },
          {
            "text": " * Sync floating role labels for the active canvas: for each node whose color maps to a role,",
            "lineNumber": 135
          },
          {
            "text": " * add a small label above the node (e.g. \"Comment\", \"Python\"). Removes existing labels first.",
            "lineNumber": 136
          },
          {
            "text": " * Uses the live canvas node map to find each node's DOM element (.canvas-node).",
            "lineNumber": 137
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 138
          },
          {
            "text": " */",
            "lineNumber": 139
          },
          {
            "text": "export async function syncCanvasRoleLabels(",
            "lineNumber": 140,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 141,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 142,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 143,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 144,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 145,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 146,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 147,
            "isSignature": true
          },
          {
            "text": "\tif (!settings.showNodeRoleLabels) {",
            "lineNumber": 148
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 149
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 150
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 151
          },
          {
            "text": "\t}",
            "lineNumber": 152
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 153
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 154
          },
          {
            "text": "\tif (!data?.nodes) {",
            "lineNumber": 155
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 156
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 157
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 158
          },
          {
            "text": "\t}",
            "lineNumber": 159
          },
          {
            "text": "\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 160
          },
          {
            "text": "\tsyncCanvasLegend(containerEl, settings);",
            "lineNumber": 161
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 162
          },
          {
            "text": "\t\tconst role = getNodeRole(node, settings);",
            "lineNumber": 163
          },
          {
            "text": "\t\tif (!role) continue;",
            "lineNumber": 164
          },
          {
            "text": "\t\tconst labelText = getRoleLabel(role, settings);",
            "lineNumber": 165
          },
          {
            "text": "\t\tconst nodeEl =",
            "lineNumber": 166
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||",
            "lineNumber": 167
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, node.id);",
            "lineNumber": 168
          },
          {
            "text": "\t\tif (!nodeEl) continue;",
            "lineNumber": 169
          },
          {
            "text": "\t\tconst label = createLabelEl(labelText);",
            "lineNumber": 170
          },
          {
            "text": "\t\t// Append after .canvas-node-container so it matches Obsidian file node label position",
            "lineNumber": 171
          },
          {
            "text": "\t\tnodeEl.append(label);",
            "lineNumber": 172
          },
          {
            "text": "\t}",
            "lineNumber": 173
          },
          {
            "text": "}",
            "lineNumber": 174,
            "isSignature": true
          }
        ]
      },
      "score": 0.21677809953689575
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 440,
            "column": 1
          },
          "endPosition": {
            "line": 472,
            "column": 104
          }
        },
        "contents": "/** Run chain from roots to the given node. */\nexport async function runChain(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst roots = getRootIds(data);\n\tconst rootsReachingCurrent = roots.filter((r) =&gt; canReach(data, r, nodeId));\n\tif (rootsReachingCurrent.length === 0) return { ok: false, message: \"No root reaches this node.\" };\n\tconst order = topologicalOrderToTarget(data, nodeId);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\ttry {\n\t\tfor (const nid of order) {\n\t\t\ttry {\n\t\t\t\tsetRunningNodeId(canvasKey, nid);\n\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);\n\t\t\t} finally {\n\t\t\t\tsetRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t}\n}\n\n/** Remove the Green output node and its output edge for a given source node; mutates data and saves. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run chain from roots to the given node. */",
            "lineNumber": 443
          },
          {
            "text": "export async function runChain(",
            "lineNumber": 444,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 445,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 446,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 447,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 448,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 449,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 450,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 451
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 452
          },
          {
            "text": "\tconst roots = getRootIds(data);",
            "lineNumber": 453
          },
          {
            "text": "\tconst rootsReachingCurrent = roots.filter((r) =&gt; canReach(data, r, nodeId));",
            "lineNumber": 454
          },
          {
            "text": "\tif (rootsReachingCurrent.length === 0) return { ok: false, message: \"No root reaches this node.\" };",
            "lineNumber": 455
          },
          {
            "text": "\tconst order = topologicalOrderToTarget(data, nodeId);",
            "lineNumber": 456
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 457
          },
          {
            "text": "\ttry {",
            "lineNumber": 458
          },
          {
            "text": "\t\tfor (const nid of order) {",
            "lineNumber": 459
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 460
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, nid);",
            "lineNumber": 461
          },
          {
            "text": "\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);",
            "lineNumber": 462
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 463
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 464
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 465
          },
          {
            "text": "\t\t}",
            "lineNumber": 466
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 467
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 468
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 469
          },
          {
            "text": "\t}",
            "lineNumber": 470
          },
          {
            "text": "}",
            "lineNumber": 471,
            "isSignature": true
          },
          {
            "lineNumber": 472
          },
          {
            "text": "/** Remove the Green output node and its output edge for a given source node; mutates data and saves. */",
            "lineNumber": 473
          }
        ]
      },
      "score": 0.20132580399513245
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 158,
            "column": 1
          },
          "endPosition": {
            "line": 190,
            "column": 117
          }
        },
        "contents": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */\nasync function updateEdgeLabelsAndSave(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tedgeModes: Map&lt;string, EdgeInputMode&gt;,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tsetEdgeModes(canvasKey, edgeModes);\n\tlet changed = false;\n\tfor (const edge of data.edges) {\n\t\tif (edge.toNode !== nodeId) continue;\n\t\tif (isOutputEdge(edge)) continue;\n\t\tconst mode = edgeModes.get(edge.id);\n\t\tif (mode == null) continue;\n\t\tconst baseName = parseEdgeVariableName(edge.label);\n\t\tif (baseName.length === 0) continue;\n\t\t// Keep only the variable name in the stored label so the user can edit it without touching (injected)/(concatenated)\n\t\tif (edge.label !== baseName) {\n\t\t\tedge.label = baseName;\n\t\t\tchanged = true;\n\t\t}\n\t}\n\t// Always persist so output node/edge mutations from ensureOutputNodeAndEdge are saved\n\tliveCanvas?.setData?.(data);\n\tawait saveCanvasData(vault, canvasFilePath, data);\n}\n\n/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
            "lineNumber": 161
          },
          {
            "text": "async function updateEdgeLabelsAndSave(",
            "lineNumber": 162,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 163,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 164,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 165,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 166,
            "isSignature": true
          },
          {
            "text": "\tedgeModes: Map&lt;string, EdgeInputMode&gt;,",
            "lineNumber": 167,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 168,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 169,
            "isSignature": true
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 170
          },
          {
            "text": "\tsetEdgeModes(canvasKey, edgeModes);",
            "lineNumber": 171
          },
          {
            "text": "\tlet changed = false;",
            "lineNumber": 172
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 173
          },
          {
            "text": "\t\tif (edge.toNode !== nodeId) continue;",
            "lineNumber": 174
          },
          {
            "text": "\t\tif (isOutputEdge(edge)) continue;",
            "lineNumber": 175
          },
          {
            "text": "\t\tconst mode = edgeModes.get(edge.id);",
            "lineNumber": 176
          },
          {
            "text": "\t\tif (mode == null) continue;",
            "lineNumber": 177
          },
          {
            "text": "\t\tconst baseName = parseEdgeVariableName(edge.label);",
            "lineNumber": 178
          },
          {
            "text": "\t\tif (baseName.length === 0) continue;",
            "lineNumber": 179
          },
          {
            "text": "\t\t// Keep only the variable name in the stored label so the user can edit it without touching (injected)/(concatenated)",
            "lineNumber": 180
          },
          {
            "text": "\t\tif (edge.label !== baseName) {",
            "lineNumber": 181
          },
          {
            "text": "\t\t\tedge.label = baseName;",
            "lineNumber": 182
          },
          {
            "text": "\t\t\tchanged = true;",
            "lineNumber": 183
          },
          {
            "text": "\t\t}",
            "lineNumber": 184
          },
          {
            "text": "\t}",
            "lineNumber": 185
          },
          {
            "text": "\t// Always persist so output node/edge mutations from ensureOutputNodeAndEdge are saved",
            "lineNumber": 186
          },
          {
            "text": "\tliveCanvas?.setData?.(data);",
            "lineNumber": 187
          },
          {
            "text": "\tawait saveCanvasData(vault, canvasFilePath, data);",
            "lineNumber": 188
          },
          {
            "text": "}",
            "lineNumber": 189,
            "isSignature": true
          },
          {
            "lineNumber": 190
          },
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 191
          }
        ]
      },
      "score": 0.20100104808807373
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 381,
            "column": 1
          },
          "endPosition": {
            "line": 440,
            "column": 1
          }
        },
        "contents": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */\nexport async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return { ok: false, message: \"Node not found.\" };\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };\n\tconst parentIds = getParentIdsSortedByY(nodeId, data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tfor (const pid of parentIds) {\n\t\tif (getNodeResult(canvasKey, pid) == null) {\n\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);\n\t\t}\n\t}\n\ttry {\n\t\tsetRunningNodeId(canvasKey, nodeId);\n\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t} finally {\n\t\tsetRunningNodeId(canvasKey, null);\n\t}\n}\n\n/** Run all nodes reachable from any root, in topological order. */\nexport async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 384
          },
          {
            "text": "export async function runNode(",
            "lineNumber": 385,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 386,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 387,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 388,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 389,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 390,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 391,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 392
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 393
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 394
          },
          {
            "text": "\tif (!node) return { ok: false, message: \"Node not found.\" };",
            "lineNumber": 395
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 396
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 397
          },
          {
            "text": "\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };",
            "lineNumber": 398
          },
          {
            "text": "\tconst parentIds = getParentIdsSortedByY(nodeId, data);",
            "lineNumber": 399
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 400
          },
          {
            "text": "\tfor (const pid of parentIds) {",
            "lineNumber": 401
          },
          {
            "text": "\t\tif (getNodeResult(canvasKey, pid) == null) {",
            "lineNumber": 402
          },
          {
            "text": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);",
            "lineNumber": 403
          },
          {
            "text": "\t\t}",
            "lineNumber": 404
          },
          {
            "text": "\t}",
            "lineNumber": 405
          },
          {
            "text": "\ttry {",
            "lineNumber": 406
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, nodeId);",
            "lineNumber": 407
          },
          {
            "text": "\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);",
            "lineNumber": 408
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 409
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 410
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 411
          },
          {
            "text": "\t} finally {",
            "lineNumber": 412
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 413
          },
          {
            "text": "\t}",
            "lineNumber": 414
          },
          {
            "text": "}",
            "lineNumber": 415,
            "isSignature": true
          },
          {
            "lineNumber": 416
          },
          {
            "text": "/** Run all nodes reachable from any root, in topological order. */",
            "lineNumber": 417
          },
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 418,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 419,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 420,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 421,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 422,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 423,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 424
          },
          {
            "text": "}",
            "lineNumber": 441,
            "isSignature": true
          }
        ]
      },
      "score": 0.18720099329948425
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 491,
            "column": 1
          },
          "endPosition": {
            "line": 511,
            "column": 1
          }
        },
        "contents": "/** Remove all Green output nodes and their output edges on the canvas; mutates data and saves. */\nexport async function dismissAllOutput(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (!data) return;\n\tconst outputNodeIds = new Set(\n\t\tdata.edges\n\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT)\n\t\t\t.map((e) =&gt; e.toNode)\n\t);\n\tdata.nodes = data.nodes.filter((n) =&gt; !outputNodeIds.has(n.id));\n\tdata.edges = data.edges.filter((e) =&gt; parseEdgeVariableName(e.label) !== EDGE_LABEL_OUTPUT);\n\tliveCanvas?.setData?.(data);\n\tif (liveCanvas?.requestSave) liveCanvas.requestSave();\n\tawait saveCanvasData(vault, canvasFilePath, data);\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Remove all Green output nodes and their output edges on the canvas; mutates data and saves. */",
            "lineNumber": 494
          },
          {
            "text": "export async function dismissAllOutput(",
            "lineNumber": 495,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 496,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 497,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 498,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 499,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 500
          },
          {
            "text": "\tif (!data) return;",
            "lineNumber": 501
          },
          {
            "text": "\tconst outputNodeIds = new Set(",
            "lineNumber": 502
          },
          {
            "text": "\t\tdata.edges",
            "lineNumber": 503
          },
          {
            "text": "\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT)",
            "lineNumber": 504
          },
          {
            "text": "\t\t\t.map((e) =&gt; e.toNode)",
            "lineNumber": 505
          },
          {
            "text": "\t);",
            "lineNumber": 506
          },
          {
            "text": "\tdata.nodes = data.nodes.filter((n) =&gt; !outputNodeIds.has(n.id));",
            "lineNumber": 507
          },
          {
            "text": "\tdata.edges = data.edges.filter((e) =&gt; parseEdgeVariableName(e.label) !== EDGE_LABEL_OUTPUT);",
            "lineNumber": 508
          },
          {
            "text": "\tliveCanvas?.setData?.(data);",
            "lineNumber": 509
          },
          {
            "text": "\tif (liveCanvas?.requestSave) liveCanvas.requestSave();",
            "lineNumber": 510
          },
          {
            "text": "\tawait saveCanvasData(vault, canvasFilePath, data);",
            "lineNumber": 511
          },
          {
            "text": "}",
            "lineNumber": 512,
            "isSignature": true
          }
        ]
      },
      "score": 0.18556809425354004
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\n\n\n\t/**\n\t * Returns the active canvas view, or the first open canvas if the active leaf is not a canvas.\n\t * Use this when the user may be focused on the control panel (e.g. Restart kernel button).\n\t */\n\tgetActiveOrFirstCanvasView(): { canvas: unknown; file: { path: string }; containerEl: HTMLElement } | null {\n\t\tconst active = this.getActiveCanvasView();\n\t\tif (active) return active;\n\t\tconst leaves = this.app.workspace.getLeavesOfType(\"canvas\");\n\t\tconst leaf = leaves[0];\n\t\tif (!leaf?.view) return null;\n\t\tconst v = leaf.view as {\n\t\t\tgetViewType?: () =&gt; string;\n\t\t\tcanvas?: unknown;\n\t\t\tfile?: { path: string };\n\t\t\tcontainerEl?: HTMLElement;\n\t\t};\n\t\tif (v.getViewType?.() !== \"canvas\") return null;\n\t\tif (v.canvas == null || v.file == null || !v.containerEl) return null;\n\t\treturn { canvas: v.canvas, file: v.file, containerEl: v.containerEl };\n\t}\n\n\tprivate static readonly ZTB_TOOLBAR_CLASS = \"ztb-canvas-toolbar\";\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "lineNumber": 295
          },
          {
            "lineNumber": 296
          },
          {
            "text": "\t/**",
            "lineNumber": 297
          },
          {
            "text": "\t * Returns the active canvas view, or the first open canvas if the active leaf is not a canvas.",
            "lineNumber": 298
          },
          {
            "text": "\t * Use this when the user may be focused on the control panel (e.g. Restart kernel button).",
            "lineNumber": 299
          },
          {
            "text": "\t */",
            "lineNumber": 300
          },
          {
            "text": "\tgetActiveOrFirstCanvasView(): { canvas: unknown; file: { path: string }; containerEl: HTMLElement } | null {",
            "lineNumber": 301
          },
          {
            "text": "\t\tconst active = this.getActiveCanvasView();",
            "lineNumber": 302
          },
          {
            "text": "\t\tif (active) return active;",
            "lineNumber": 303
          },
          {
            "text": "\t\tconst leaves = this.app.workspace.getLeavesOfType(\"canvas\");",
            "lineNumber": 304
          },
          {
            "text": "\t\tconst leaf = leaves[0];",
            "lineNumber": 305
          },
          {
            "text": "\t\tif (!leaf?.view) return null;",
            "lineNumber": 306
          },
          {
            "text": "\t\tconst v = leaf.view as {",
            "lineNumber": 307
          },
          {
            "text": "\t\t\tgetViewType?: () =&gt; string;",
            "lineNumber": 308
          },
          {
            "text": "\t\t\tcanvas?: unknown;",
            "lineNumber": 309
          },
          {
            "text": "\t\t\tfile?: { path: string };",
            "lineNumber": 310
          },
          {
            "text": "\t\t\tcontainerEl?: HTMLElement;",
            "lineNumber": 311
          },
          {
            "text": "\t\t};",
            "lineNumber": 312
          },
          {
            "text": "\t\tif (v.getViewType?.() !== \"canvas\") return null;",
            "lineNumber": 313
          },
          {
            "text": "\t\tif (v.canvas == null || v.file == null || !v.containerEl) return null;",
            "lineNumber": 314
          },
          {
            "text": "\t\treturn { canvas: v.canvas, file: v.file, containerEl: v.containerEl };",
            "lineNumber": 315
          },
          {
            "text": "\t}",
            "lineNumber": 316
          },
          {
            "lineNumber": 317
          },
          {
            "text": "\tprivate static readonly ZTB_TOOLBAR_CLASS = \"ztb-canvas-toolbar\";",
            "lineNumber": 318
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.17020553350448608
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 203
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "function findPathForEdge(containerEl: HTMLElement, targetViewportX: number, targetViewportY: number): SVGPathElement | null {\n\n\t\tif (d &lt; bestDist) {\n\t\t\tbestDist = d;\n\t\t\tbest = p;\n\t\t}\n\t}\n\treturn best;\n}\n\n/**\n * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,\n * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG\n * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tclearCanvasEdgeModeLabels(containerEl);\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.edges) return;\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tconst runningNodeId = getRunningNodeId(canvasKey);\n\tconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\tconst FO_WIDTH = 110;\n\tconst FO_HEIGHT = 28;\n\tconst Y_OFFSET_BELOW_PATH = 12;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function findPathForEdge(containerEl: HTMLElement, targetViewportX: number, targetViewportY: number): SVGPathElement | null {",
            "lineNumber": 204,
            "isSignature": true
          },
          {
            "lineNumber": 213
          },
          {
            "text": "\t\tif (d &lt; bestDist) {",
            "lineNumber": 214
          },
          {
            "text": "\t\t\tbestDist = d;",
            "lineNumber": 215
          },
          {
            "text": "\t\t\tbest = p;",
            "lineNumber": 216
          },
          {
            "text": "\t\t}",
            "lineNumber": 217
          },
          {
            "text": "\t}",
            "lineNumber": 218
          },
          {
            "text": "\treturn best;",
            "lineNumber": 219
          },
          {
            "text": "}",
            "lineNumber": 220,
            "isSignature": true
          },
          {
            "lineNumber": 221
          },
          {
            "text": "/**",
            "lineNumber": 222
          },
          {
            "text": " * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,",
            "lineNumber": 223
          },
          {
            "text": " * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG",
            "lineNumber": 224
          },
          {
            "text": " * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.",
            "lineNumber": 225
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 226
          },
          {
            "text": " */",
            "lineNumber": 227
          },
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 228,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "\tclearCanvasEdgeModeLabels(containerEl);",
            "lineNumber": 235
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 236
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 237
          },
          {
            "text": "\tif (!data?.edges) return;",
            "lineNumber": 238
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 239
          },
          {
            "text": "\tconst runningNodeId = getRunningNodeId(canvasKey);",
            "lineNumber": 240
          },
          {
            "text": "\tconst SVG_NS = \"http://www.w3.org/2000/svg\";",
            "lineNumber": 241
          },
          {
            "text": "\tconst FO_WIDTH = 110;",
            "lineNumber": 242
          },
          {
            "text": "\tconst FO_HEIGHT = 28;",
            "lineNumber": 243
          },
          {
            "text": "\tconst Y_OFFSET_BELOW_PATH = 12;",
            "lineNumber": 244
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.16843676567077637
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 161
          },
          "endPosition": {
            "line": 247,
            "column": 1
          }
        },
        "contents": "async function updateEdgeLabelsAndSave(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tedgeModes: Map&lt;string, EdgeInputMode&gt;,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\n}\n\n/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */\nasync function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return \"\";\n\tconst role = getNodeRole(node, settings);\n\tif (!role || role === \"yellow\" || role === \"green\") {\n\t\t// Yellow: pass-through (use node content as result)\n\t\tif (role === \"yellow\") {\n\t\t\tconst content = await getNodeContent(node, app.vault);\n\t\t\tsetNodeResult(canvasKey, nodeId, content);\n\t\t\treturn content;\n\t\t}\n\t\treturn \"\";\n\t}\n\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\tconst nodeInput = await getNodeContent(node, app.vault);\n\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(\n\t\tcanvasKey,\n\t\tnodeInput,\n\t\tincoming\n\t);\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"purple\") {\n\t\tconst model = settings.ollamaPurpleModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"blue\") {\n\t\tconst kernel = getKernelForCanvas;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "async function updateEdgeLabelsAndSave(",
            "lineNumber": 162,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 163,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 164,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 165,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 166,
            "isSignature": true
          },
          {
            "text": "\tedgeModes: Map&lt;string, EdgeInputMode&gt;,",
            "lineNumber": 167,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 168,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 169,
            "isSignature": true
          },
          {
            "lineNumber": 188
          },
          {
            "text": "}",
            "lineNumber": 189,
            "isSignature": true
          },
          {
            "lineNumber": 190
          },
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 191
          },
          {
            "text": "async function runSingleNode(",
            "lineNumber": 192,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 195,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 196,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 197,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 198,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 199,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 200,
            "isSignature": true
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 201
          },
          {
            "text": "\tif (!node) return \"\";",
            "lineNumber": 202
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 203
          },
          {
            "text": "\tif (!role || role === \"yellow\" || role === \"green\") {",
            "lineNumber": 204
          },
          {
            "text": "\t\t// Yellow: pass-through (use node content as result)",
            "lineNumber": 205
          },
          {
            "text": "\t\tif (role === \"yellow\") {",
            "lineNumber": 206
          },
          {
            "text": "\t\t\tconst content = await getNodeContent(node, app.vault);",
            "lineNumber": 207
          },
          {
            "text": "\t\t\tsetNodeResult(canvasKey, nodeId, content);",
            "lineNumber": 208
          },
          {
            "text": "\t\t\treturn content;",
            "lineNumber": 209
          },
          {
            "text": "\t\t}",
            "lineNumber": 210
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 211
          },
          {
            "text": "\t}",
            "lineNumber": 212
          },
          {
            "text": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 213
          },
          {
            "text": "\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 214
          },
          {
            "text": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(",
            "lineNumber": 215
          },
          {
            "text": "\t\tcanvasKey,",
            "lineNumber": 216
          },
          {
            "text": "\t\tnodeInput,",
            "lineNumber": 217
          },
          {
            "text": "\t\tincoming",
            "lineNumber": 218
          },
          {
            "text": "\t);",
            "lineNumber": 219
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 220
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 221
          },
          {
            "lineNumber": 222
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 223
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 224
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 225
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 226
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 227
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 228
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 229
          },
          {
            "text": "\t}",
            "lineNumber": 230
          },
          {
            "text": "\tif (role === \"purple\") {",
            "lineNumber": 231
          },
          {
            "text": "\t\tconst model = settings.ollamaPurpleModel || \"llama2\";",
            "lineNumber": 232
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 233
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 234
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 235
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 236
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 237
          },
          {
            "text": "\t}",
            "lineNumber": 238
          },
          {
            "text": "\tif (role === \"blue\") {",
            "lineNumber": 239
          },
          {
            "text": "\t\tconst kernel = getKernelForCanvas;",
            "lineNumber": 240
          },
          {
            "text": "}",
            "lineNumber": 248,
            "isSignature": true
          }
        ]
      },
      "score": 0.16074790060520172
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "column": 71
          },
          "endPosition": {
            "line": 30,
            "column": 108
          }
        },
        "contents": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";\nimport {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";\nimport {\n\tdismissAllOutput as runnerDismissAllOutput,\n\tdismissOutput as runnerDismissOutput,\n\trunChain as runnerRunChain,\n\trunEntireCanvas as runnerRunEntireCanvas,\n\trunNode as runnerRunNode,\n} from \"./engine/runner\";\nimport {\n\tclearCanvasEdgeModeLabels,\n\tclearCanvasLegend,\n\tclearCanvasRoleLabels,\n\tsyncCanvasEdgeModeLabels,\n\tsyncCanvasRoleLabels,\n} from \"./canvas/canvasNodeLabels\";\nimport {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";\n\n/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */\nfunction resolveCanvasNodeId(node: unknown): string | undefined {\n\tif (!node || typeof node !== \"object\") return undefined;\n\tconst n = node as Record&lt;string, unknown&gt;;\n\tif (typeof n.id === \"string\") return n.id;\n\tconst inner = n.node as Record&lt;string, unknown&gt; | undefined;\n\tif (inner &amp;&amp; typeof inner.id === \"string\") return inner.id;\n\tconst data = typeof n.getData === \"function\" ? (n.getData as () =&gt; { id?: string })() : undefined;\n\treturn data?.id;\n}\n\n/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";",
            "lineNumber": 2
          },
          {
            "text": "import {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";",
            "lineNumber": 3
          },
          {
            "text": "import {",
            "lineNumber": 4
          },
          {
            "text": "\tdismissAllOutput as runnerDismissAllOutput,",
            "lineNumber": 5
          },
          {
            "text": "\tdismissOutput as runnerDismissOutput,",
            "lineNumber": 6
          },
          {
            "text": "\trunChain as runnerRunChain,",
            "lineNumber": 7
          },
          {
            "text": "\trunEntireCanvas as runnerRunEntireCanvas,",
            "lineNumber": 8
          },
          {
            "text": "\trunNode as runnerRunNode,",
            "lineNumber": 9
          },
          {
            "text": "} from \"./engine/runner\";",
            "lineNumber": 10
          },
          {
            "text": "import {",
            "lineNumber": 11
          },
          {
            "text": "\tclearCanvasEdgeModeLabels,",
            "lineNumber": 12
          },
          {
            "text": "\tclearCanvasLegend,",
            "lineNumber": 13
          },
          {
            "text": "\tclearCanvasRoleLabels,",
            "lineNumber": 14
          },
          {
            "text": "\tsyncCanvasEdgeModeLabels,",
            "lineNumber": 15
          },
          {
            "text": "\tsyncCanvasRoleLabels,",
            "lineNumber": 16
          },
          {
            "text": "} from \"./canvas/canvasNodeLabels\";",
            "lineNumber": 17
          },
          {
            "text": "import {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";",
            "lineNumber": 18
          },
          {
            "lineNumber": 19
          },
          {
            "text": "/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */",
            "lineNumber": 20
          },
          {
            "text": "function resolveCanvasNodeId(node: unknown): string | undefined {",
            "lineNumber": 21,
            "isSignature": true
          },
          {
            "text": "\tif (!node || typeof node !== \"object\") return undefined;",
            "lineNumber": 22
          },
          {
            "text": "\tconst n = node as Record&lt;string, unknown&gt;;",
            "lineNumber": 23
          },
          {
            "text": "\tif (typeof n.id === \"string\") return n.id;",
            "lineNumber": 24
          },
          {
            "text": "\tconst inner = n.node as Record&lt;string, unknown&gt; | undefined;",
            "lineNumber": 25
          },
          {
            "text": "\tif (inner &amp;&amp; typeof inner.id === \"string\") return inner.id;",
            "lineNumber": 26
          },
          {
            "text": "\tconst data = typeof n.getData === \"function\" ? (n.getData as () =&gt; { id?: string })() : undefined;",
            "lineNumber": 27
          },
          {
            "text": "\treturn data?.id;",
            "lineNumber": 28
          },
          {
            "text": "}",
            "lineNumber": 29,
            "isSignature": true
          },
          {
            "lineNumber": 30
          },
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 31
          }
        ]
      },
      "score": 0.1584767997264862
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\n\n\n\t/** Add \"Run entire canvas\" and \"Dismiss all output\" buttons into the canvas container (fallback when view has no addAction). */\n\taddCanvasToolbarToContainer(containerEl: HTMLElement): void {\n\t\tif (containerEl.querySelector(&#96;.${ZettelThinkingBoardPlugin.ZTB_TOOLBAR_CLASS}&#96;)) return;\n\t\tconst bar = containerEl.createDiv({ cls: ZettelThinkingBoardPlugin.ZTB_TOOLBAR_CLASS });\n\t\tconst runBtn = bar.createEl(\"button\", { cls: \"ztb-toolbar-btn\" });\n\t\trunBtn.setAttribute(\"aria-label\", \"Run entire canvas\");\n\t\trunBtn.createSpan({ cls: \"ztb-toolbar-icon\", text: \"\" });\n\t\trunBtn.createSpan({ cls: \"ztb-toolbar-label\", text: \"Run entire canvas\" });\n\t\trunBtn.addEventListener(\"click\", () =&gt; this.runEntireCanvas());\n\t\tconst dismissBtn = bar.createEl(\"button\", { cls: \"ztb-toolbar-btn\" });\n\t\tdismissBtn.setAttribute(\"aria-label\", \"Dismiss all output\");\n\t\tdismissBtn.createSpan({ cls: \"ztb-toolbar-icon\", text: \"\" });\n\t\tdismissBtn.createSpan({ cls: \"ztb-toolbar-label\", text: \"Dismiss all output\" });\n\t\tdismissBtn.addEventListener(\"click\", () =&gt; this.dismissAllOutput());\n\t}\n\n\t/** Run a single node (call from context menu with node id). */\n\tasync runNode(nodeId: string): Promise&lt;void&gt; {\n\t\tconst view = this.getActiveCanvasView();\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "lineNumber": 323
          },
          {
            "lineNumber": 324
          },
          {
            "text": "\t/** Add \"Run entire canvas\" and \"Dismiss all output\" buttons into the canvas container (fallback when view has no addAction). */",
            "lineNumber": 325
          },
          {
            "text": "\taddCanvasToolbarToContainer(containerEl: HTMLElement): void {",
            "lineNumber": 326
          },
          {
            "text": "\t\tif (containerEl.querySelector(&#96;.${ZettelThinkingBoardPlugin.ZTB_TOOLBAR_CLASS}&#96;)) return;",
            "lineNumber": 327
          },
          {
            "text": "\t\tconst bar = containerEl.createDiv({ cls: ZettelThinkingBoardPlugin.ZTB_TOOLBAR_CLASS });",
            "lineNumber": 328
          },
          {
            "text": "\t\tconst runBtn = bar.createEl(\"button\", { cls: \"ztb-toolbar-btn\" });",
            "lineNumber": 329
          },
          {
            "text": "\t\trunBtn.setAttribute(\"aria-label\", \"Run entire canvas\");",
            "lineNumber": 330
          },
          {
            "text": "\t\trunBtn.createSpan({ cls: \"ztb-toolbar-icon\", text: \"\" });",
            "lineNumber": 331
          },
          {
            "text": "\t\trunBtn.createSpan({ cls: \"ztb-toolbar-label\", text: \"Run entire canvas\" });",
            "lineNumber": 332
          },
          {
            "text": "\t\trunBtn.addEventListener(\"click\", () =&gt; this.runEntireCanvas());",
            "lineNumber": 333
          },
          {
            "text": "\t\tconst dismissBtn = bar.createEl(\"button\", { cls: \"ztb-toolbar-btn\" });",
            "lineNumber": 334
          },
          {
            "text": "\t\tdismissBtn.setAttribute(\"aria-label\", \"Dismiss all output\");",
            "lineNumber": 335
          },
          {
            "text": "\t\tdismissBtn.createSpan({ cls: \"ztb-toolbar-icon\", text: \"\" });",
            "lineNumber": 336
          },
          {
            "text": "\t\tdismissBtn.createSpan({ cls: \"ztb-toolbar-label\", text: \"Dismiss all output\" });",
            "lineNumber": 337
          },
          {
            "text": "\t\tdismissBtn.addEventListener(\"click\", () =&gt; this.dismissAllOutput());",
            "lineNumber": 338
          },
          {
            "text": "\t}",
            "lineNumber": 339
          },
          {
            "lineNumber": 340
          },
          {
            "text": "\t/** Run a single node (call from context menu with node id). */",
            "lineNumber": 341
          },
          {
            "text": "\tasync runNode(nodeId: string): Promise&lt;void&gt; {",
            "lineNumber": 342
          },
          {
            "text": "\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 343
          },
          {
            "text": "\t}",
            "lineNumber": 348
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.15738080441951752
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 227
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "export async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\n\tconst FO_HEIGHT = 28;\n\tconst Y_OFFSET_BELOW_PATH = 12;\n\tfor (const edge of data.edges) {\n\t\tif (isOutputEdge(edge)) continue;\n\t\tconst isRunning = runningNodeId != null &amp;&amp; edge.toNode === runningNodeId;\n\t\tconst mode = getEdgeMode(canvasKey, edge.id);\n\t\tconst state: EdgeDisplayState | null = isRunning\n\t\t\t? \"running\"\n\t\t\t: mode === \"inject\"\n\t\t\t\t? \"inject\"\n\t\t\t\t: mode === \"concatenate\"\n\t\t\t\t\t? \"concatenate\"\n\t\t\t\t\t: null;\n\t\tif (!state) continue;\n\t\tconst fromEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);\n\t\tconst toEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);\n\t\tif (!fromEl || !toEl) continue;\n\t\tconst fromCenter = getElCenter(fromEl);\n\t\tconst toCenter = getElCenter(toEl);\n\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;\n\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;\n\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);\n\t\tif (!pathEl) continue;\n\t\tconst group = pathEl.closest(\"g\");\n\t\tif (!group) continue;\n\t\tconst mid = getPathMidpointSvg(pathEl);\n\t\tconst label = document.createElement(\"div\");\n\t\tlabel.setAttribute(\"class\", EDGE_MODE_LABEL_CLASS);\n\t\tlabel.setAttribute(EDGE_MODE_DATA_ATTR, edge.id);\n\t\tlabel.setAttribute(EDGE_MODE_STATE_ATTR, state);\n\t\tif (state === \"running\") {\n\t\t\tconst icon = document.createElement(\"span\");\n\t\t\ticon.setAttribute(\"class\", EDGE_MODE_ICON_CLASS);\n\t\t\tlabel.appendChild(icon);\n\t\t}\n\t\tconst text = document.createElement(\"span\");\n\t\ttext.textContent =\n\t\t\tstate === \"running\" ? \"\" : state === \"inject\" ? \"(injected)\" : \"(concatenated)\";\n\t\tlabel.appendChild(text);\n\t\tconst fo = document.createElementNS(SVG_NS, \"foreignObject\");\n\t\tfo.setAttribute(\"class\", EDGE_MODE_FOREIGN_CLASS);\n\t\tfo.setAttribute(\"x\", String(mid.x - FO_WIDTH / 2));\n\t\tfo.setAttribute(\"y\", String(mid.y + Y_OFFSET_BELOW_PATH));\n\t\tfo.setAttribute(\"width\", String(FO_WIDTH));\n\t\tfo.setAttribute(\"height\", String(FO_HEIGHT));\n\t\tfo.appendChild(label);\n\t\tgroup.appendChild(fo);\n\t}\n\t// Mark output edges so their label can be styled smaller/grayed\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 226,
                "column": 1
              },
              "endPosition": {
                "line": 226,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 226,
                "column": 8
              },
              "endPosition": {
                "line": 233,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 228,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "lineNumber": 242
          },
          {
            "text": "\tconst FO_HEIGHT = 28;",
            "lineNumber": 243
          },
          {
            "text": "\tconst Y_OFFSET_BELOW_PATH = 12;",
            "lineNumber": 244
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 245
          },
          {
            "text": "\t\tif (isOutputEdge(edge)) continue;",
            "lineNumber": 246
          },
          {
            "text": "\t\tconst isRunning = runningNodeId != null &amp;&amp; edge.toNode === runningNodeId;",
            "lineNumber": 247
          },
          {
            "text": "\t\tconst mode = getEdgeMode(canvasKey, edge.id);",
            "lineNumber": 248
          },
          {
            "text": "\t\tconst state: EdgeDisplayState | null = isRunning",
            "lineNumber": 249
          },
          {
            "text": "\t\t\t? \"running\"",
            "lineNumber": 250
          },
          {
            "text": "\t\t\t: mode === \"inject\"",
            "lineNumber": 251
          },
          {
            "text": "\t\t\t\t? \"inject\"",
            "lineNumber": 252
          },
          {
            "text": "\t\t\t\t: mode === \"concatenate\"",
            "lineNumber": 253
          },
          {
            "text": "\t\t\t\t\t? \"concatenate\"",
            "lineNumber": 254
          },
          {
            "text": "\t\t\t\t\t: null;",
            "lineNumber": 255
          },
          {
            "text": "\t\tif (!state) continue;",
            "lineNumber": 256
          },
          {
            "text": "\t\tconst fromEl =",
            "lineNumber": 257
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||",
            "lineNumber": 258
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);",
            "lineNumber": 259
          },
          {
            "text": "\t\tconst toEl =",
            "lineNumber": 260
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||",
            "lineNumber": 261
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);",
            "lineNumber": 262
          },
          {
            "text": "\t\tif (!fromEl || !toEl) continue;",
            "lineNumber": 263
          },
          {
            "text": "\t\tconst fromCenter = getElCenter(fromEl);",
            "lineNumber": 264
          },
          {
            "text": "\t\tconst toCenter = getElCenter(toEl);",
            "lineNumber": 265
          },
          {
            "text": "\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;",
            "lineNumber": 266
          },
          {
            "text": "\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;",
            "lineNumber": 267
          },
          {
            "text": "\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);",
            "lineNumber": 268
          },
          {
            "text": "\t\tif (!pathEl) continue;",
            "lineNumber": 269
          },
          {
            "text": "\t\tconst group = pathEl.closest(\"g\");",
            "lineNumber": 270
          },
          {
            "text": "\t\tif (!group) continue;",
            "lineNumber": 271
          },
          {
            "text": "\t\tconst mid = getPathMidpointSvg(pathEl);",
            "lineNumber": 272
          },
          {
            "text": "\t\tconst label = document.createElement(\"div\");",
            "lineNumber": 273
          },
          {
            "text": "\t\tlabel.setAttribute(\"class\", EDGE_MODE_LABEL_CLASS);",
            "lineNumber": 274
          },
          {
            "text": "\t\tlabel.setAttribute(EDGE_MODE_DATA_ATTR, edge.id);",
            "lineNumber": 275
          },
          {
            "text": "\t\tlabel.setAttribute(EDGE_MODE_STATE_ATTR, state);",
            "lineNumber": 276
          },
          {
            "text": "\t\tif (state === \"running\") {",
            "lineNumber": 277
          },
          {
            "text": "\t\t\tconst icon = document.createElement(\"span\");",
            "lineNumber": 278
          },
          {
            "text": "\t\t\ticon.setAttribute(\"class\", EDGE_MODE_ICON_CLASS);",
            "lineNumber": 279
          },
          {
            "text": "\t\t\tlabel.appendChild(icon);",
            "lineNumber": 280
          },
          {
            "text": "\t\t}",
            "lineNumber": 281
          },
          {
            "text": "\t\tconst text = document.createElement(\"span\");",
            "lineNumber": 282
          },
          {
            "text": "\t\ttext.textContent =",
            "lineNumber": 283
          },
          {
            "text": "\t\t\tstate === \"running\" ? \"\" : state === \"inject\" ? \"(injected)\" : \"(concatenated)\";",
            "lineNumber": 284
          },
          {
            "text": "\t\tlabel.appendChild(text);",
            "lineNumber": 285
          },
          {
            "text": "\t\tconst fo = document.createElementNS(SVG_NS, \"foreignObject\");",
            "lineNumber": 286
          },
          {
            "text": "\t\tfo.setAttribute(\"class\", EDGE_MODE_FOREIGN_CLASS);",
            "lineNumber": 287
          },
          {
            "text": "\t\tfo.setAttribute(\"x\", String(mid.x - FO_WIDTH / 2));",
            "lineNumber": 288
          },
          {
            "text": "\t\tfo.setAttribute(\"y\", String(mid.y + Y_OFFSET_BELOW_PATH));",
            "lineNumber": 289
          },
          {
            "text": "\t\tfo.setAttribute(\"width\", String(FO_WIDTH));",
            "lineNumber": 290
          },
          {
            "text": "\t\tfo.setAttribute(\"height\", String(FO_HEIGHT));",
            "lineNumber": 291
          },
          {
            "text": "\t\tfo.appendChild(label);",
            "lineNumber": 292
          },
          {
            "text": "\t\tgroup.appendChild(fo);",
            "lineNumber": 293
          },
          {
            "text": "\t}",
            "lineNumber": 294
          },
          {
            "text": "\t// Mark output edges so their label can be styled smaller/grayed",
            "lineNumber": 295
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.15490029752254486
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\n\n\n\t/** Returns the active canvas view if the active leaf is a canvas. */\n\tgetActiveCanvasView(): { canvas: unknown; file: { path: string }; containerEl: HTMLElement } | null {\n\t\tconst leaf = this.app.workspace.activeLeaf;\n\t\tif (!leaf?.view) return null;\n\t\tconst v = leaf.view as {\n\t\t\tgetViewType?: () =&gt; string;\n\t\t\tcanvas?: unknown;\n\t\t\tfile?: { path: string };\n\t\t\tcontainerEl?: HTMLElement;\n\t\t};\n\t\tif (v.getViewType?.() !== \"canvas\") return null;\n\t\tif (v.canvas == null || v.file == null || !v.containerEl) return null;\n\t\treturn { canvas: v.canvas, file: v.file, containerEl: v.containerEl };\n\t}\n\n\t/**\n\t * Returns the active canvas view, or the first open canvas if the active leaf is not a canvas.\n\t * Use this when the user may be focused on the control panel (e.g. Restart kernel button).\n\t */\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "lineNumber": 280
          },
          {
            "lineNumber": 281
          },
          {
            "text": "\t/** Returns the active canvas view if the active leaf is a canvas. */",
            "lineNumber": 282
          },
          {
            "text": "\tgetActiveCanvasView(): { canvas: unknown; file: { path: string }; containerEl: HTMLElement } | null {",
            "lineNumber": 283
          },
          {
            "text": "\t\tconst leaf = this.app.workspace.activeLeaf;",
            "lineNumber": 284
          },
          {
            "text": "\t\tif (!leaf?.view) return null;",
            "lineNumber": 285
          },
          {
            "text": "\t\tconst v = leaf.view as {",
            "lineNumber": 286
          },
          {
            "text": "\t\t\tgetViewType?: () =&gt; string;",
            "lineNumber": 287
          },
          {
            "text": "\t\t\tcanvas?: unknown;",
            "lineNumber": 288
          },
          {
            "text": "\t\t\tfile?: { path: string };",
            "lineNumber": 289
          },
          {
            "text": "\t\t\tcontainerEl?: HTMLElement;",
            "lineNumber": 290
          },
          {
            "text": "\t\t};",
            "lineNumber": 291
          },
          {
            "text": "\t\tif (v.getViewType?.() !== \"canvas\") return null;",
            "lineNumber": 292
          },
          {
            "text": "\t\tif (v.canvas == null || v.file == null || !v.containerEl) return null;",
            "lineNumber": 293
          },
          {
            "text": "\t\treturn { canvas: v.canvas, file: v.file, containerEl: v.containerEl };",
            "lineNumber": 294
          },
          {
            "text": "\t}",
            "lineNumber": 295
          },
          {
            "lineNumber": 296
          },
          {
            "text": "\t/**",
            "lineNumber": 297
          },
          {
            "text": "\t * Returns the active canvas view, or the first open canvas if the active leaf is not a canvas.",
            "lineNumber": 298
          },
          {
            "text": "\t * Use this when the user may be focused on the control panel (e.g. Restart kernel button).",
            "lineNumber": 299
          },
          {
            "text": "\t */",
            "lineNumber": 300
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.15331166982650757
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/views/ZettelControlsView.ts",
        "range": {
          "startPosition": {
            "line": 9
          },
          "endPosition": {
            "line": 126,
            "column": 1
          }
        },
        "contents": "export class ZettelControlsView extends ItemView {\n\n\n\tasync onOpen(): Promise&lt;void&gt; {\n\t\tconst el = this.containerEl.createDiv({ cls: \"ztb-controls-container\" });\n\n\t\t// Model mapping (persisted; same as settings)\n\t\tel.createEl(\"h4\", { text: \"Model mapping\", cls: \"ztb-section-title\" });\n\t\tnew Setting(el)\n\t\t\t.setName(\"Model node (primary)\")\n\t\t\t.setDesc(\"Ollama model for primary model nodes\")\n\t\t\t.addText((text) =&gt;\n\t\t\t\ttext\n\t\t\t\t\t.setPlaceholder(\"e.g. llama2\")\n\t\t\t\t\t.setValue(this.plugin.settings.ollamaOrangeModel)\n\t\t\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t\t\tthis.plugin.settings.ollamaOrangeModel = value;\n\t\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t\t})\n\t\t\t);\n\t\tnew Setting(el)\n\t\t\t.setName(\"Model node (secondary)\")\n\t\t\t.setDesc(\"Ollama model for secondary model nodes\")\n\t\t\t.addText((text) =&gt;\n\t\t\t\ttext\n\t\t\t\t\t.setPlaceholder(\"e.g. mistral\")\n\t\t\t\t\t.setValue(this.plugin.settings.ollamaPurpleModel)\n\t\t\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t\t\tthis.plugin.settings.ollamaPurpleModel = value;\n\t\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t\t})\n\t\t\t);\n\n\t\t// Kernel controls\n\t\tel.createEl(\"h4\", { text: \"Kernel controls\", cls: \"ztb-section-title\" });\n\t\tnew Setting(el)\n\t\t\t.setName(\"Restart Python kernel\")\n\t\t\t.setDesc(\"Restart the kernel for the active canvas\")\n\t\t\t.addButton((btn) =&gt;\n\t\t\t\tbtn.setButtonText(\"Restart kernel\").onClick(() =&gt; {\n\t\t\t\t\tconst view = this.plugin.getActiveOrFirstCanvasView();\n\t\t\t\t\tif (!view) {\n\t\t\t\t\t\tnew Notice(\"Open a canvas first.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tterminateKernel(view.file.path);\n\t\t\t\t\tnew Notice(\"Kernel restarted for this canvas.\");\n\t\t\t\t})\n\t\t\t);\n\n\t\t// Environment variables (in-memory only)\n\t\tel.createEl(\"h4\", { text: \"Environment variables\", cls: \"ztb-section-title\" });\n\t\tconst envDesc = el.createEl(\"p\", { cls: \"ztb-env-desc\" });\n\t\tenvDesc.setText(\"Key-value pairs for Python (not persisted).\");\n\t\tconst envList = el.createDiv({ cls: \"ztb-env-list\" });\n\t\tconst addEnvRow = (key = \"\", value = \"\") =&gt; {\n\t\t\tconst row = envList.createDiv({ cls: \"ztb-env-row\" });\n;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 10,
                "column": 1
              },
              "endPosition": {
                "line": 10,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 10,
                "column": 8
              },
              "endPosition": {
                "line": 11,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export class ZettelControlsView extends ItemView {",
            "lineNumber": 10,
            "isSignature": true
          },
          {
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "\tasync onOpen(): Promise&lt;void&gt; {",
            "lineNumber": 27
          },
          {
            "text": "\t\tconst el = this.containerEl.createDiv({ cls: \"ztb-controls-container\" });",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "\t\t// Model mapping (persisted; same as settings)",
            "lineNumber": 30
          },
          {
            "text": "\t\tel.createEl(\"h4\", { text: \"Model mapping\", cls: \"ztb-section-title\" });",
            "lineNumber": 31
          },
          {
            "text": "\t\tnew Setting(el)",
            "lineNumber": 32
          },
          {
            "text": "\t\t\t.setName(\"Model node (primary)\")",
            "lineNumber": 33
          },
          {
            "text": "\t\t\t.setDesc(\"Ollama model for primary model nodes\")",
            "lineNumber": 34
          },
          {
            "text": "\t\t\t.addText((text) =&gt;",
            "lineNumber": 35
          },
          {
            "text": "\t\t\t\ttext",
            "lineNumber": 36
          },
          {
            "text": "\t\t\t\t\t.setPlaceholder(\"e.g. llama2\")",
            "lineNumber": 37
          },
          {
            "text": "\t\t\t\t\t.setValue(this.plugin.settings.ollamaOrangeModel)",
            "lineNumber": 38
          },
          {
            "text": "\t\t\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 39
          },
          {
            "text": "\t\t\t\t\t\tthis.plugin.settings.ollamaOrangeModel = value;",
            "lineNumber": 40
          },
          {
            "text": "\t\t\t\t\t\tawait this.plugin.saveSettings();",
            "lineNumber": 41
          },
          {
            "text": "\t\t\t\t\t})",
            "lineNumber": 42
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 43
          },
          {
            "text": "\t\tnew Setting(el)",
            "lineNumber": 44
          },
          {
            "text": "\t\t\t.setName(\"Model node (secondary)\")",
            "lineNumber": 45
          },
          {
            "text": "\t\t\t.setDesc(\"Ollama model for secondary model nodes\")",
            "lineNumber": 46
          },
          {
            "text": "\t\t\t.addText((text) =&gt;",
            "lineNumber": 47
          },
          {
            "text": "\t\t\t\ttext",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\t\t.setPlaceholder(\"e.g. mistral\")",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t\t\t.setValue(this.plugin.settings.ollamaPurpleModel)",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 51
          },
          {
            "text": "\t\t\t\t\t\tthis.plugin.settings.ollamaPurpleModel = value;",
            "lineNumber": 52
          },
          {
            "text": "\t\t\t\t\t\tawait this.plugin.saveSettings();",
            "lineNumber": 53
          },
          {
            "text": "\t\t\t\t\t})",
            "lineNumber": 54
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 55
          },
          {
            "lineNumber": 56
          },
          {
            "text": "\t\t// Kernel controls",
            "lineNumber": 57
          },
          {
            "text": "\t\tel.createEl(\"h4\", { text: \"Kernel controls\", cls: \"ztb-section-title\" });",
            "lineNumber": 58
          },
          {
            "text": "\t\tnew Setting(el)",
            "lineNumber": 59
          },
          {
            "text": "\t\t\t.setName(\"Restart Python kernel\")",
            "lineNumber": 60
          },
          {
            "text": "\t\t\t.setDesc(\"Restart the kernel for the active canvas\")",
            "lineNumber": 61
          },
          {
            "text": "\t\t\t.addButton((btn) =&gt;",
            "lineNumber": 62
          },
          {
            "text": "\t\t\t\tbtn.setButtonText(\"Restart kernel\").onClick(() =&gt; {",
            "lineNumber": 63
          },
          {
            "text": "\t\t\t\t\tconst view = this.plugin.getActiveOrFirstCanvasView();",
            "lineNumber": 64
          },
          {
            "text": "\t\t\t\t\tif (!view) {",
            "lineNumber": 65
          },
          {
            "text": "\t\t\t\t\t\tnew Notice(\"Open a canvas first.\");",
            "lineNumber": 66
          },
          {
            "text": "\t\t\t\t\t\treturn;",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 68
          },
          {
            "text": "\t\t\t\t\tterminateKernel(view.file.path);",
            "lineNumber": 69
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Kernel restarted for this canvas.\");",
            "lineNumber": 70
          },
          {
            "text": "\t\t\t\t})",
            "lineNumber": 71
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 72
          },
          {
            "lineNumber": 73
          },
          {
            "text": "\t\t// Environment variables (in-memory only)",
            "lineNumber": 74
          },
          {
            "text": "\t\tel.createEl(\"h4\", { text: \"Environment variables\", cls: \"ztb-section-title\" });",
            "lineNumber": 75
          },
          {
            "text": "\t\tconst envDesc = el.createEl(\"p\", { cls: \"ztb-env-desc\" });",
            "lineNumber": 76
          },
          {
            "text": "\t\tenvDesc.setText(\"Key-value pairs for Python (not persisted).\");",
            "lineNumber": 77
          },
          {
            "text": "\t\tconst envList = el.createDiv({ cls: \"ztb-env-list\" });",
            "lineNumber": 78
          },
          {
            "text": "\t\tconst addEnvRow = (key = \"\", value = \"\") =&gt; {",
            "lineNumber": 79
          },
          {
            "text": "\t\t\tconst row = envList.createDiv({ cls: \"ztb-env-row\" });",
            "lineNumber": 80
          },
          {
            "text": ";",
            "lineNumber": 98
          },
          {
            "text": "\t}",
            "lineNumber": 122
          },
          {
            "text": "}",
            "lineNumber": 127,
            "isSignature": true
          }
        ]
      },
      "score": 0.14705276489257812
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 470,
            "column": 1
          },
          "endPosition": {
            "line": 493,
            "column": 98
          }
        },
        "contents": "/** Remove the Green output node and its output edge for a given source node; mutates data and saves. */\nexport async function dismissOutput(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tsourceNodeId: string,\n\tsettings: ZettelPluginSettings,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (!data) return;\n\tconst outId = findOutputNodeForSource(data, sourceNodeId, settings);\n\tif (!outId) return;\n\tdata.nodes = data.nodes.filter((n) =&gt; n.id !== outId);\n\tdata.edges = data.edges.filter(\n\t\t(e) =&gt; !(e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT)\n\t);\n\tliveCanvas?.setData?.(data);\n\tif (liveCanvas?.requestSave) liveCanvas.requestSave();\n\tawait saveCanvasData(vault, canvasFilePath, data);\n}\n\n/** Remove all Green output nodes and their output edges on the canvas; mutates data and saves. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Remove the Green output node and its output edge for a given source node; mutates data and saves. */",
            "lineNumber": 473
          },
          {
            "text": "export async function dismissOutput(",
            "lineNumber": 474,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 475,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 476,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 477,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 478,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 479,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 480,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 481
          },
          {
            "text": "\tif (!data) return;",
            "lineNumber": 482
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNodeId, settings);",
            "lineNumber": 483
          },
          {
            "text": "\tif (!outId) return;",
            "lineNumber": 484
          },
          {
            "text": "\tdata.nodes = data.nodes.filter((n) =&gt; n.id !== outId);",
            "lineNumber": 485
          },
          {
            "text": "\tdata.edges = data.edges.filter(",
            "lineNumber": 486
          },
          {
            "text": "\t\t(e) =&gt; !(e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT)",
            "lineNumber": 487
          },
          {
            "text": "\t);",
            "lineNumber": 488
          },
          {
            "text": "\tliveCanvas?.setData?.(data);",
            "lineNumber": 489
          },
          {
            "text": "\tif (liveCanvas?.requestSave) liveCanvas.requestSave();",
            "lineNumber": 490
          },
          {
            "text": "\tawait saveCanvasData(vault, canvasFilePath, data);",
            "lineNumber": 491
          },
          {
            "text": "}",
            "lineNumber": 492,
            "isSignature": true
          },
          {
            "lineNumber": 493
          },
          {
            "text": "/** Remove all Green output nodes and their output edges on the canvas; mutates data and saves. */",
            "lineNumber": 494
          }
        ]
      },
      "score": 0.145620197057724
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/kernelManager.ts",
        "range": {
          "startPosition": {
            "column": 49
          },
          "endPosition": {
            "line": 21,
            "column": 1
          }
        },
        "contents": "import {createPythonKernel} from \"./pythonKernel\";\n\n/** One kernel per canvas (key = canvas file path). */\nconst kernels = new Map&lt;string, PythonKernel&gt;();\n\nexport function getKernelForCanvas(canvasKey: string, pythonPath: string): PythonKernel {\n\tlet k = kernels.get(canvasKey);\n\tif (!k) {\n\t\tk = createPythonKernel(pythonPath);\n\t\tkernels.set(canvasKey, k);\n\t}\n\treturn k;\n}\n\nexport function terminateKernel(canvasKey: string): void {\n\tconst k = kernels.get(canvasKey);\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import {createPythonKernel} from \"./pythonKernel\";",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "/** One kernel per canvas (key = canvas file path). */",
            "lineNumber": 4
          },
          {
            "text": "const kernels = new Map&lt;string, PythonKernel&gt;();",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "export function getKernelForCanvas(canvasKey: string, pythonPath: string): PythonKernel {",
            "lineNumber": 7,
            "isSignature": true
          },
          {
            "text": "\tlet k = kernels.get(canvasKey);",
            "lineNumber": 8
          },
          {
            "text": "\tif (!k) {",
            "lineNumber": 9
          },
          {
            "text": "\t\tk = createPythonKernel(pythonPath);",
            "lineNumber": 10
          },
          {
            "text": "\t\tkernels.set(canvasKey, k);",
            "lineNumber": 11
          },
          {
            "text": "\t}",
            "lineNumber": 12
          },
          {
            "text": "\treturn k;",
            "lineNumber": 13
          },
          {
            "text": "}",
            "lineNumber": 14,
            "isSignature": true
          },
          {
            "lineNumber": 15
          },
          {
            "text": "export function terminateKernel(canvasKey: string): void {",
            "lineNumber": 16,
            "isSignature": true
          },
          {
            "text": "\tconst k = kernels.get(canvasKey);",
            "lineNumber": 17
          },
          {
            "text": "}",
            "lineNumber": 22,
            "isSignature": true
          }
        ]
      },
      "score": 0.1448245644569397
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 28,
            "column": 1
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */\nlet debugNodeMenuFired = false;\n\nexport default class ZettelThinkingBoardPlugin extends Plugin {\n\tsettings: ZettelPluginSettings;\n\n\tasync onload() {\n\t\ttry {\n\t\t\tawait this.loadSettings();\n\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));\n\n\t\t\tthis.registerView(\n\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,\n\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)\n\t\t\t);\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"open-zettel-controls\",\n\t\t\t\tname: \"Open Zettel Controls\",\n\t\t\t\tcallback: () =&gt; this.activateZettelControls(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-node\",\n\t\t\t\tname: \"Run node\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-chain\",\n\t\t\t\tname: \"Run chain\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"dismiss-output\",\n\t\t\t\tname: \"Dismiss output\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 31
          },
          {
            "text": "let debugNodeMenuFired = false;",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings;",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "\tasync onload() {",
            "lineNumber": 37
          },
          {
            "text": "\t\ttry {",
            "lineNumber": 38
          },
          {
            "text": "\t\t\tawait this.loadSettings();",
            "lineNumber": 39
          },
          {
            "text": "\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));",
            "lineNumber": 40
          },
          {
            "lineNumber": 41
          },
          {
            "text": "\t\t\tthis.registerView(",
            "lineNumber": 42
          },
          {
            "text": "\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,",
            "lineNumber": 43
          },
          {
            "text": "\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)",
            "lineNumber": 44
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 47
          },
          {
            "text": "\t\t\t\tid: \"open-zettel-controls\",",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\tname: \"Open Zettel Controls\",",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.activateZettelControls(),",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 51
          },
          {
            "lineNumber": 52
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 53
          },
          {
            "text": "\t\t\t\tid: \"run-node\",",
            "lineNumber": 54
          },
          {
            "text": "\t\t\t\tname: \"Run node\",",
            "lineNumber": 55
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 56
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 57
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 58
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 59
          },
          {
            "text": "\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu",
            "lineNumber": 60
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");",
            "lineNumber": 61
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 62
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 63
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 64
          },
          {
            "lineNumber": 65
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 66
          },
          {
            "text": "\t\t\t\tid: \"run-chain\",",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t\tname: \"Run chain\",",
            "lineNumber": 68
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 69
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 70
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 71
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 72
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");",
            "lineNumber": 73
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 74
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 75
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 76
          },
          {
            "lineNumber": 77
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 78
          },
          {
            "text": "\t\t\t\tid: \"dismiss-output\",",
            "lineNumber": 79
          },
          {
            "text": "\t\t\t\tname: \"Dismiss output\",",
            "lineNumber": 80
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 81
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 82
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 83
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 84
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");",
            "lineNumber": 85
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 86
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 87
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 90
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.14290259778499603
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 88,
            "column": 1
          },
          "endPosition": {
            "line": 122,
            "column": 93
          }
        },
        "contents": "function topologicalSort(\n\tdata: CanvasData,\n\texecEdges: CanvasEdgeData[],\n\tnodeIds: Set&lt;string&gt;\n): string[] {\n\tconst inDegree = new Map&lt;string, number&gt;();\n\tfor (const id of nodeIds) inDegree.set(id, 0);\n\tfor (const e of execEdges) {\n\t\tif (nodeIds.has(e.fromNode) &amp;&amp; nodeIds.has(e.toNode)) {\n\t\t\tinDegree.set(e.toNode, (inDegree.get(e.toNode) ?? 0) + 1);\n\t\t}\n\t}\n\tconst order: string[] = [];\n\tconst queue = [...nodeIds].filter((id) =&gt; inDegree.get(id) === 0).sort((a, b) =&gt; {\n\t\tconst na = getNodeById(data, a);\n\t\tconst nb = getNodeById(data, b);\n\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);\n\t});\n\twhile (queue.length &gt; 0) {\n\t\tconst id = queue.shift()!;\n\t\torder.push(id);\n\t\tfor (const e of execEdges) {\n\t\t\tif (e.fromNode === id &amp;&amp; nodeIds.has(e.toNode)) {\n\t\t\t\tconst d = (inDegree.get(e.toNode) ?? 0) - 1;\n\t\t\t\tinDegree.set(e.toNode, d);\n\t\t\t\tif (d === 0) queue.push(e.toNode);\n\t\t\t}\n\t\t}\n\t}\n\treturn order;\n}\n\n/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function topologicalSort(",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 92,
            "isSignature": true
          },
          {
            "text": "\texecEdges: CanvasEdgeData[],",
            "lineNumber": 93,
            "isSignature": true
          },
          {
            "text": "\tnodeIds: Set&lt;string&gt;",
            "lineNumber": 94,
            "isSignature": true
          },
          {
            "text": "): string[] {",
            "lineNumber": 95,
            "isSignature": true
          },
          {
            "text": "\tconst inDegree = new Map&lt;string, number&gt;();",
            "lineNumber": 96
          },
          {
            "text": "\tfor (const id of nodeIds) inDegree.set(id, 0);",
            "lineNumber": 97
          },
          {
            "text": "\tfor (const e of execEdges) {",
            "lineNumber": 98
          },
          {
            "text": "\t\tif (nodeIds.has(e.fromNode) &amp;&amp; nodeIds.has(e.toNode)) {",
            "lineNumber": 99
          },
          {
            "text": "\t\t\tinDegree.set(e.toNode, (inDegree.get(e.toNode) ?? 0) + 1);",
            "lineNumber": 100
          },
          {
            "text": "\t\t}",
            "lineNumber": 101
          },
          {
            "text": "\t}",
            "lineNumber": 102
          },
          {
            "text": "\tconst order: string[] = [];",
            "lineNumber": 103
          },
          {
            "text": "\tconst queue = [...nodeIds].filter((id) =&gt; inDegree.get(id) === 0).sort((a, b) =&gt; {",
            "lineNumber": 104
          },
          {
            "text": "\t\tconst na = getNodeById(data, a);",
            "lineNumber": 105
          },
          {
            "text": "\t\tconst nb = getNodeById(data, b);",
            "lineNumber": 106
          },
          {
            "text": "\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);",
            "lineNumber": 107
          },
          {
            "text": "\t});",
            "lineNumber": 108
          },
          {
            "text": "\twhile (queue.length &gt; 0) {",
            "lineNumber": 109
          },
          {
            "text": "\t\tconst id = queue.shift()!;",
            "lineNumber": 110
          },
          {
            "text": "\t\torder.push(id);",
            "lineNumber": 111
          },
          {
            "text": "\t\tfor (const e of execEdges) {",
            "lineNumber": 112
          },
          {
            "text": "\t\t\tif (e.fromNode === id &amp;&amp; nodeIds.has(e.toNode)) {",
            "lineNumber": 113
          },
          {
            "text": "\t\t\t\tconst d = (inDegree.get(e.toNode) ?? 0) - 1;",
            "lineNumber": 114
          },
          {
            "text": "\t\t\t\tinDegree.set(e.toNode, d);",
            "lineNumber": 115
          },
          {
            "text": "\t\t\t\tif (d === 0) queue.push(e.toNode);",
            "lineNumber": 116
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 117
          },
          {
            "text": "\t\t}",
            "lineNumber": 118
          },
          {
            "text": "\t}",
            "lineNumber": 119
          },
          {
            "text": "\treturn order;",
            "lineNumber": 120
          },
          {
            "text": "}",
            "lineNumber": 121,
            "isSignature": true
          },
          {
            "lineNumber": 122
          },
          {
            "text": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
            "lineNumber": 123
          }
        ]
      },
      "score": 0.14206549525260925
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "chain|run everything|process.*first",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": true
}
```
Result:

```json
{
  "success": {
    "pattern": "chain|run everything|process.*first",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/main.ts",
              "matches": [
                {
                  "lineNumber": 7,
                  "content": "\trunChain as runnerRunChain,"
                },
                {
                  "lineNumber": 67,
                  "content": "\t\t\t\tid: \"run-chain\","
                },
                {
                  "lineNumber": 68,
                  "content": "\t\t\t\tname: \"Run chain\","
                },
                {
                  "lineNumber": 73,
                  "content": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");"
                },
                {
                  "lineNumber": 100,
                  "content": "\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))"
                },
                {
                  "lineNumber": 350,
                  "content": "\t/** Run chain from roots to the given node (call from context menu with node id). */"
                },
                {
                  "lineNumber": 351,
                  "content": "\tasync runChain(nodeId: string): Promise&lt;void&gt; {"
                },
                {
                  "lineNumber": 355,
                  "content": "\t\tconst result = await runnerRunChain(this.app, this.settings, view.file.path, nodeId, liveCanvas);"
                },
                {
                  "lineNumber": 356,
                  "content": "\t\tif (!result.ok) new Notice(result.message ?? \"Run chain failed.\");"
                }
              ]
            },
            {
              "file": "src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 384,
                  "content": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */"
                },
                {
                  "lineNumber": 403,
                  "content": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);"
                },
                {
                  "lineNumber": 443,
                  "content": "/** Run chain from roots to the given node. */"
                },
                {
                  "lineNumber": 444,
                  "content": "export async function runChain("
                }
              ]
            },
            {
              "file": "src/settings.ts",
              "matches": [
                {
                  "lineNumber": 191,
                  "content": "\t\thint.setText(\"Right-click a node on the canvas and choose Run node or Run chain.\");"
                }
              ]
            }
          ],
          "totalLines": 14,
          "totalMatchedLines": 14
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>
</tool-use>

---


Checking how `getNodeRole` works and where `topologicalSort` gets its data so we can add prioritization:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/nodes.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "setData|requestSave",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "setData|requestSave",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 187,
                  "content": "\tliveCanvas?.setData?.(data);"
                },
                {
                  "lineNumber": 489,
                  "content": "\tliveCanvas?.setData?.(data);"
                },
                {
                  "lineNumber": 490,
                  "content": "\tif (liveCanvas?.requestSave) liveCanvas.requestSave();"
                },
                {
                  "lineNumber": 509,
                  "content": "\tliveCanvas?.setData?.(data);"
                },
                {
                  "lineNumber": 510,
                  "content": "\tif (liveCanvas?.requestSave) liveCanvas.requestSave();"
                }
              ]
            },
            {
              "file": "src/engine/canvasApi.ts",
              "matches": [
                {
                  "lineNumber": 11,
                  "content": "\trequestSave?: () =&gt; void;"
                },
                {
                  "lineNumber": 15,
                  "content": "\tsetData?(data: unknown): void;"
                }
              ]
            }
          ],
          "totalLines": 7,
          "totalMatchedLines": 7
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---


Checking where `getNodeRole` is defined and its return type:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "getNodeRole|NodeRole",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts",
  "contextAfter": 1,
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "getNodeRole|NodeRole",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/canvas/types.ts",
              "matches": [
                {
                  "lineNumber": 9,
                  "content": "import type {CanvasColor, NodeRole, ZettelPluginSettings} from \"../settings\";"
                },
                {
                  "lineNumber": 10,
                  "isContextLine": true
                },
                {
                  "lineNumber": 22,
                  "content": "export function getNodeRole(node: { color?: CanvasColor }, settings: ZettelPluginSettings): NodeRole | null {"
                },
                {
                  "lineNumber": 23,
                  "content": "\tconst nodeColor = normalizeColor(node.color);",
                  "isContextLine": true
                },
                {
                  "lineNumber": 25,
                  "content": "\tconst roles: NodeRole[] = [\"orange\", \"purple\", \"blue\", \"yellow\", \"green\"];"
                },
                {
                  "lineNumber": 26,
                  "content": "\tfor (const role of roles) {",
                  "isContextLine": true
                }
              ]
            }
          ],
          "totalLines": 6,
          "totalMatchedLines": 3
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts</summary>

</details>
</tool-use>

---


Implementing both changes.


---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write**  Todo List</summary>

- [-] Prioritize non-AI (Python/yellow) nodes in topological sort
- [ ] Fix canvas label flicker (load before clear)

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/settings.ts</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---





---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write**  Todo List</summary>

- [x] Prioritize non-AI (Python/yellow) nodes in topological sort
- [-] Fix canvas label flicker (load before clear)

</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>

</tool-use>

---


Verifying runner imports and running tests:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts",
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts",
      "errors": [
        {
          "message": "Argument of type 'AllCanvasNodeData | undefined' is not assignable to parameter of type '{ color?: string | undefined; }'.\n  Type 'undefined' is not assignable to type '{ color?: string | undefined; }'.",
          "range": {
            "startPosition": {
              "line": 140,
              "column": 29
            },
            "endPosition": {
              "line": 140,
              "column": 31
            }
          },
          "source": "ts",
          "severity": "DIAGNOSTIC_SEVERITY_ERROR"
        },
        {
          "message": "Argument of type 'AllCanvasNodeData | undefined' is not assignable to parameter of type '{ color?: string | undefined; }'.\n  Type 'undefined' is not assignable to type '{ color?: string | undefined; }'.",
          "range": {
            "startPosition": {
              "line": 141,
              "column": 29
            },
            "endPosition": {
              "line": 141,
              "column": 31
            }
          },
          "source": "ts",
          "severity": "DIAGNOSTIC_SEVERITY_ERROR"
        }
      ]
    },
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "topologicalOrder|topologicalSort",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "topologicalOrder|topologicalSort",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "./src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 62,
                  "content": "function topologicalOrderToTarget("
                },
                {
                  "lineNumber": 78,
                  "content": "\treturn topologicalSort(data, execEdges, nodeIds, settings);"
                },
                {
                  "lineNumber": 82,
                  "content": "function topologicalOrderFull(data: CanvasData, settings: ZettelPluginSettings): string[] {"
                },
                {
                  "lineNumber": 97,
                  "content": "\treturn topologicalSort(data, execEdges, nodeIds, settings);"
                },
                {
                  "lineNumber": 100,
                  "content": "function topologicalSort("
                },
                {
                  "lineNumber": 452,
                  "content": "\tconst order = topologicalOrderFull(data, settings);"
                },
                {
                  "lineNumber": 482,
                  "content": "\tconst order = topologicalOrderToTarget(data, nodeId, settings);"
                }
              ]
            }
          ],
          "totalLines": 7,
          "totalMatchedLines": 7
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---


Fixing lint: handling undefined nodes in the sort comparator.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---





---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2**  Run command: cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build 2>&1</summary>

```bash
cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build 2>&1
```

```

&gt; zettel-thinking-board@1.0.0 build
&gt; tsc -noEmit -skipLibCheck &amp;&amp; node esbuild.config.mjs production


```
</details>
</tool-use>

---





---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2**  Run command: cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm test 2>&1</summary>

```bash
cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm test 2>&1
```

```

&gt; zettel-thinking-board@1.0.0 test
&gt; vitest run


 RUN  v1.6.1 /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board

  src/engine/state.test.ts  (7 tests) 2ms
  src/canvas/types.test.ts  (27 tests) 7ms

 Test Files  2 passed (2)
      Tests  34 passed (34)
   Start at  17:15:12
   Duration  303ms (transform 82ms, setup 0ms, collect 122ms, tests 9ms, environment 0ms, prepare 105ms)


```
</details>
</tool-use>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write**  Todo List</summary>

- [x] Prioritize non-AI (Python/yellow) nodes in topological sort
- [x] Fix canvas label flicker (load before clear)

</details>
</tool-use>

---


Summary of changes:

---

### 1. **Run non-AI nodes first (performance)**

Execution order for **Run chain** and **Run entire canvas** now prefers **non-AI** nodes when multiple are ready:

- **`src/engine/runner.ts`**
  - **`isNonAIRole(role)`**  treats `blue` (Python) and `yellow` (pass-through) as non-AI.
  - **`topologicalSort`** now takes `settings` and uses **`sortQueueByNonAIFirst`** so that whenever several nodes have no pending dependencies, the queue is sorted with:
    - non-AI (Python, yellow) first,
    - then by `y` (top to bottom).
  - **`topologicalOrderFull`** and **`topologicalOrderToTarget`** both take `settings` and pass it into `topologicalSort`.

So when the next step could be e.g. two AI nodes and one Python node, the Python node runs first and its output appears earlier.

---

### 2. **Canvas label flicker**

Flicker was likely from **edge mode labels** being cleared before loading canvas data, so the UI could paint a frame with labels removed and nothing new yet.

- **`src/canvas/canvasNodeLabels.ts`**  **`syncCanvasEdgeModeLabels`**:
  - **Before:** `clearCanvasEdgeModeLabels(containerEl)` then `await loadCanvasData(...)`.
  - **After:** `await loadCanvasData(...)` first, then if we have no edges we clear and return; otherwise we clear and then add the new labels in the same sync block.

So we no longer clear edge labels until we have data; we only clear and then immediately repaint, which should remove the visible flash. Role labels already loaded data before clearing, so only a comment was added there for clarity.

---

**Build and tests:** `npm run build` and `npm test` both succeed (34 tests pass).

If flicker persists, the next place to check is the **2s interval** in `main.ts` that re-runs `syncCanvasRoleLabels` and `syncCanvasEdgeModeLabels`: you could reduce how often it runs or only re-sync when canvas data or running state actually changes. Optionally, that interval can be registered with `this.registerInterval(...)` so its cleaned up with the plugin (see AGENTS.md).

---

