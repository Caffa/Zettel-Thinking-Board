<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session d749d937-1e13-41c8-84db-91ec39354d73 (2026-02-03 09:52Z) -->

# Problem-solving approach and algorithms (2026-02-03 09:52Z)

_**User**_

Take the perspective of an intelligent experienced code reviewer and look through the way I problem solve in this code. Are there algorithms that already exist for collision avoidance? Or solving the problem of which nodes to resolve in the graph that I should be implementing?

Check over the robustness of the code and highlight any problems that you spot in the workflow.

When done, update the readme and give me examples I should mock up to take a screenshot of.

---

_**Agent (model default, mode Agent)**_


Reviewing the codebase for collision avoidance, graph-resolution logic, and robustness. Exploring the relevant code.


---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Where is collision avoidance or overlap detection implemented for nodes?",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 281,
            "column": 1
          },
          "endPosition": {
            "line": 304,
            "column": 1
          }
        },
        "contents": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */\nconst OUTPUT_COLLISION_MAX_RADIUS = 500;\n/** Step (px) between candidate x positions when avoiding collisions. */\nconst OUTPUT_COLLISION_STEP = 80;\n/** Max vertical offset (px) below default placement when avoiding collisions. */\nconst OUTPUT_COLLISION_MAX_VERTICAL = 400;\n/** Step (px) between candidate y positions when avoiding vertical collisions. */\nconst OUTPUT_COLLISION_VERTICAL_STEP = 60;\n/** Min gap (px) between output box and other nodes; placement avoids coming within this distance. */\nconst OUTPUT_COLLISION_BUFFER = 24;\n\nfunction rectanglesOverlap(\n\ta: { x: number; y: number; width: number; height: number },\n\tb: { x: number; y: number; width: number; height: number }\n): boolean {\n\treturn !(\n\t\ta.x + a.width &lt;= b.x ||\n\t\tb.x + b.width &lt;= a.x ||\n\t\ta.y + a.height &lt;= b.y ||\n\t\tb.y + b.height &lt;= a.y\n\t);\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
            "lineNumber": 284
          },
          {
            "text": "const OUTPUT_COLLISION_MAX_RADIUS = 500;",
            "lineNumber": 285
          },
          {
            "text": "/** Step (px) between candidate x positions when avoiding collisions. */",
            "lineNumber": 286
          },
          {
            "text": "const OUTPUT_COLLISION_STEP = 80;",
            "lineNumber": 287
          },
          {
            "text": "/** Max vertical offset (px) below default placement when avoiding collisions. */",
            "lineNumber": 288
          },
          {
            "text": "const OUTPUT_COLLISION_MAX_VERTICAL = 400;",
            "lineNumber": 289
          },
          {
            "text": "/** Step (px) between candidate y positions when avoiding vertical collisions. */",
            "lineNumber": 290
          },
          {
            "text": "const OUTPUT_COLLISION_VERTICAL_STEP = 60;",
            "lineNumber": 291
          },
          {
            "text": "/** Min gap (px) between output box and other nodes; placement avoids coming within this distance. */",
            "lineNumber": 292
          },
          {
            "text": "const OUTPUT_COLLISION_BUFFER = 24;",
            "lineNumber": 293
          },
          {
            "lineNumber": 294
          },
          {
            "text": "function rectanglesOverlap(",
            "lineNumber": 295,
            "isSignature": true
          },
          {
            "text": "\ta: { x: number; y: number; width: number; height: number },",
            "lineNumber": 296,
            "isSignature": true
          },
          {
            "text": "\tb: { x: number; y: number; width: number; height: number }",
            "lineNumber": 297,
            "isSignature": true
          },
          {
            "text": "): boolean {",
            "lineNumber": 298,
            "isSignature": true
          },
          {
            "text": "\treturn !(",
            "lineNumber": 299
          },
          {
            "text": "\t\ta.x + a.width &lt;= b.x ||",
            "lineNumber": 300
          },
          {
            "text": "\t\tb.x + b.width &lt;= a.x ||",
            "lineNumber": 301
          },
          {
            "text": "\t\ta.y + a.height &lt;= b.y ||",
            "lineNumber": 302
          },
          {
            "text": "\t\tb.y + b.height &lt;= a.y",
            "lineNumber": 303
          },
          {
            "text": "\t);",
            "lineNumber": 304
          },
          {
            "text": "}",
            "lineNumber": 305,
            "isSignature": true
          }
        ]
      },
      "score": 0.3978734016418457
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 294
          },
          "endPosition": {
            "line": 342,
            "column": 1
          }
        },
        "contents": "function rectanglesOverlap(\n\ta: { x: number; y: number; width: number; height: number },\n\tb: { x: number; y: number; width: number; height: number }\n): boolean {\n\n\t\ta.y + a.height &lt;= b.y ||\n\t\tb.y + b.height &lt;= a.y\n\t);\n}\n\n/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */\nfunction chooseOutputPositionXY(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\toutNodeId: string | null,\n\tdefaultX: number,\n\tdefaultY: number,\n\twidth: number,\n\theight: number\n): { x: number; y: number } {\n\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);\n\tif (outNodeId) excludeIds.add(outNodeId);\n\tconst box = { x: 0, y: 0, width, height };\n\tfunction tryPosition(x: number, y: number): boolean {\n\t\tbox.x = x;\n\t\tbox.y = y;\n\t\tfor (const node of data.nodes) {\n\t\t\tif (excludeIds.has(node.id)) continue;\n\t\t\t// Expand other node by buffer so we keep at least OUTPUT_COLLISION_BUFFER gap\n\t\t\tconst expanded = {\n\t\t\t\tx: node.x - OUTPUT_COLLISION_BUFFER,\n\t\t\t\ty: node.y - OUTPUT_COLLISION_BUFFER,\n\t\t\t\twidth: node.width + 2 * OUTPUT_COLLISION_BUFFER,\n\t\t\t\theight: node.height + 2 * OUTPUT_COLLISION_BUFFER,\n\t\t\t};\n\t\t\tif (rectanglesOverlap(box, expanded)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {\n\t\tconst candidateY = defaultY + dy;\n\t\tfor (const dx of xOffsets())\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function rectanglesOverlap(",
            "lineNumber": 295,
            "isSignature": true
          },
          {
            "text": "\ta: { x: number; y: number; width: number; height: number },",
            "lineNumber": 296,
            "isSignature": true
          },
          {
            "text": "\tb: { x: number; y: number; width: number; height: number }",
            "lineNumber": 297,
            "isSignature": true
          },
          {
            "text": "): boolean {",
            "lineNumber": 298,
            "isSignature": true
          },
          {
            "lineNumber": 301
          },
          {
            "text": "\t\ta.y + a.height &lt;= b.y ||",
            "lineNumber": 302
          },
          {
            "text": "\t\tb.y + b.height &lt;= a.y",
            "lineNumber": 303
          },
          {
            "text": "\t);",
            "lineNumber": 304
          },
          {
            "text": "}",
            "lineNumber": 305,
            "isSignature": true
          },
          {
            "lineNumber": 306
          },
          {
            "text": "/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */",
            "lineNumber": 307
          },
          {
            "text": "function chooseOutputPositionXY(",
            "lineNumber": 308,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 309,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 310,
            "isSignature": true
          },
          {
            "text": "\toutNodeId: string | null,",
            "lineNumber": 311,
            "isSignature": true
          },
          {
            "text": "\tdefaultX: number,",
            "lineNumber": 312,
            "isSignature": true
          },
          {
            "text": "\tdefaultY: number,",
            "lineNumber": 313,
            "isSignature": true
          },
          {
            "text": "\twidth: number,",
            "lineNumber": 314,
            "isSignature": true
          },
          {
            "text": "\theight: number",
            "lineNumber": 315,
            "isSignature": true
          },
          {
            "text": "): { x: number; y: number } {",
            "lineNumber": 316,
            "isSignature": true
          },
          {
            "text": "\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);",
            "lineNumber": 317
          },
          {
            "text": "\tif (outNodeId) excludeIds.add(outNodeId);",
            "lineNumber": 318
          },
          {
            "text": "\tconst box = { x: 0, y: 0, width, height };",
            "lineNumber": 319
          },
          {
            "text": "\tfunction tryPosition(x: number, y: number): boolean {",
            "lineNumber": 320,
            "isSignature": true
          },
          {
            "text": "\t\tbox.x = x;",
            "lineNumber": 321
          },
          {
            "text": "\t\tbox.y = y;",
            "lineNumber": 322
          },
          {
            "text": "\t\tfor (const node of data.nodes) {",
            "lineNumber": 323
          },
          {
            "text": "\t\t\tif (excludeIds.has(node.id)) continue;",
            "lineNumber": 324
          },
          {
            "text": "\t\t\t// Expand other node by buffer so we keep at least OUTPUT_COLLISION_BUFFER gap",
            "lineNumber": 325
          },
          {
            "text": "\t\t\tconst expanded = {",
            "lineNumber": 326
          },
          {
            "text": "\t\t\t\tx: node.x - OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 327
          },
          {
            "text": "\t\t\t\ty: node.y - OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 328
          },
          {
            "text": "\t\t\t\twidth: node.width + 2 * OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 329
          },
          {
            "text": "\t\t\t\theight: node.height + 2 * OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 330
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 331
          },
          {
            "text": "\t\t\tif (rectanglesOverlap(box, expanded)) return false;",
            "lineNumber": 332
          },
          {
            "text": "\t\t}",
            "lineNumber": 333
          },
          {
            "text": "\t\treturn true;",
            "lineNumber": 334
          },
          {
            "text": "\t}",
            "lineNumber": 335,
            "isSignature": true
          },
          {
            "text": "\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {",
            "lineNumber": 336
          },
          {
            "text": "\t\tconst candidateY = defaultY + dy;",
            "lineNumber": 337
          },
          {
            "text": "\t\tfor (const dx of xOffsets())",
            "lineNumber": 338
          },
          {
            "text": "\t}",
            "lineNumber": 341
          },
          {
            "text": "}",
            "lineNumber": 343,
            "isSignature": true
          }
        ]
      },
      "score": 0.34326326847076416
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 121,
            "column": 50
          },
          "endPosition": {
            "line": 148,
            "column": 1
          }
        },
        "contents": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */\nexport function findOutputNodeForSource(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\tsettings: ZettelPluginSettings\n): string | null {\n\tconst outputEdge = data.edges.find(\n\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t);\n\tif (outputEdge) return outputEdge.toNode;\n\tconst source = getNodeById(data, sourceNodeId);\n\tif (!source) return null;\n\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);\n\tif (!greenColor) return null;\n\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;\n\tconst toleranceAbove = 30; // allow small layout drift above default\n\tfor (const node of data.nodes) {\n\t\tif (node.id === sourceNodeId) continue;\n\t\tif (normalizeColor(node.color) !== greenColor) continue;\n\t\t// Same x (or close), and y at or below expected (collision avoidance may place it lower)\n\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;\n\t\tif (node.y &lt; expectedY - toleranceAbove || node.y &gt; expectedY + OUTPUT_POSITION_FALLBACK_MAX_Y) continue;\n\t\treturn node.id;\n\t}\n\treturn null;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
            "lineNumber": 124
          },
          {
            "text": "export function findOutputNodeForSource(",
            "lineNumber": 125,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 126,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 127,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 128,
            "isSignature": true
          },
          {
            "text": "): string | null {",
            "lineNumber": 129,
            "isSignature": true
          },
          {
            "text": "\tconst outputEdge = data.edges.find(",
            "lineNumber": 130
          },
          {
            "text": "\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 131
          },
          {
            "text": "\t);",
            "lineNumber": 132
          },
          {
            "text": "\tif (outputEdge) return outputEdge.toNode;",
            "lineNumber": 133
          },
          {
            "text": "\tconst source = getNodeById(data, sourceNodeId);",
            "lineNumber": 134
          },
          {
            "text": "\tif (!source) return null;",
            "lineNumber": 135
          },
          {
            "text": "\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);",
            "lineNumber": 136
          },
          {
            "text": "\tif (!greenColor) return null;",
            "lineNumber": 137
          },
          {
            "text": "\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;",
            "lineNumber": 138
          },
          {
            "text": "\tconst toleranceAbove = 30; // allow small layout drift above default",
            "lineNumber": 139
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 140
          },
          {
            "text": "\t\tif (node.id === sourceNodeId) continue;",
            "lineNumber": 141
          },
          {
            "text": "\t\tif (normalizeColor(node.color) !== greenColor) continue;",
            "lineNumber": 142
          },
          {
            "text": "\t\t// Same x (or close), and y at or below expected (collision avoidance may place it lower)",
            "lineNumber": 143
          },
          {
            "text": "\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;",
            "lineNumber": 144
          },
          {
            "text": "\t\tif (node.y &lt; expectedY - toleranceAbove || node.y &gt; expectedY + OUTPUT_POSITION_FALLBACK_MAX_Y) continue;",
            "lineNumber": 145
          },
          {
            "text": "\t\treturn node.id;",
            "lineNumber": 146
          },
          {
            "text": "\t}",
            "lineNumber": 147
          },
          {
            "text": "\treturn null;",
            "lineNumber": 148
          },
          {
            "text": "}",
            "lineNumber": 149,
            "isSignature": true
          }
        ]
      },
      "score": 0.2988874912261963
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 187
          },
          "endPosition": {
            "line": 281,
            "column": 1
          }
        },
        "contents": "async function updateEdgeLabelsAndSave(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tedgeModes: Map&lt;string, EdgeInputMode&gt;,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\n}\n\n/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */\nasync function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return \"\";\n\tconst role = getNodeRole(node, settings);\n\tif (!role || role === \"yellow\" || role === \"green\") {\n\t\t// Yellow: pass-through (use node content as result)\n\t\tif (role === \"yellow\") {\n\t\t\tconst content = await getNodeContent(node, app.vault);\n\t\t\tsetNodeResult(canvasKey, nodeId, content);\n\t\t\treturn content;\n\t\t}\n\t\treturn \"\";\n\t}\n\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\tconst nodeInput = await getNodeContent(node, app.vault);\n\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(\n\t\tcanvasKey,\n\t\tnodeInput,\n\t\tincoming\n\t);\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"purple\") {\n\t\tconst model = settings.ollamaPurpleModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"red\") {\n\t\tconst model = settings.ollamaRedModel || \"llama2\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "async function updateEdgeLabelsAndSave(",
            "lineNumber": 188,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 189,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 190,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 191,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 192,
            "isSignature": true
          },
          {
            "text": "\tedgeModes: Map&lt;string, EdgeInputMode&gt;,",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 195,
            "isSignature": true
          },
          {
            "lineNumber": 214
          },
          {
            "text": "}",
            "lineNumber": 215,
            "isSignature": true
          },
          {
            "lineNumber": 216
          },
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 217
          },
          {
            "text": "async function runSingleNode(",
            "lineNumber": 218,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 219,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 220,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 221,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 222,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 223,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 224,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 225,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 226,
            "isSignature": true
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 227
          },
          {
            "text": "\tif (!node) return \"\";",
            "lineNumber": 228
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 229
          },
          {
            "text": "\tif (!role || role === \"yellow\" || role === \"green\") {",
            "lineNumber": 230
          },
          {
            "text": "\t\t// Yellow: pass-through (use node content as result)",
            "lineNumber": 231
          },
          {
            "text": "\t\tif (role === \"yellow\") {",
            "lineNumber": 232
          },
          {
            "text": "\t\t\tconst content = await getNodeContent(node, app.vault);",
            "lineNumber": 233
          },
          {
            "text": "\t\t\tsetNodeResult(canvasKey, nodeId, content);",
            "lineNumber": 234
          },
          {
            "text": "\t\t\treturn content;",
            "lineNumber": 235
          },
          {
            "text": "\t\t}",
            "lineNumber": 236
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 237
          },
          {
            "text": "\t}",
            "lineNumber": 238
          },
          {
            "text": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 239
          },
          {
            "text": "\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 240
          },
          {
            "text": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(",
            "lineNumber": 241
          },
          {
            "text": "\t\tcanvasKey,",
            "lineNumber": 242
          },
          {
            "text": "\t\tnodeInput,",
            "lineNumber": 243
          },
          {
            "text": "\t\tincoming",
            "lineNumber": 244
          },
          {
            "text": "\t);",
            "lineNumber": 245
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 246
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 247
          },
          {
            "lineNumber": 248
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 249
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 250
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 251
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 252
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 253
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 254
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 255
          },
          {
            "text": "\t}",
            "lineNumber": 256
          },
          {
            "text": "\tif (role === \"purple\") {",
            "lineNumber": 257
          },
          {
            "text": "\t\tconst model = settings.ollamaPurpleModel || \"llama2\";",
            "lineNumber": 258
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 259
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 260
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 261
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 262
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 263
          },
          {
            "text": "\t}",
            "lineNumber": 264
          },
          {
            "text": "\tif (role === \"red\") {",
            "lineNumber": 265
          },
          {
            "text": "\t\tconst model = settings.ollamaRedModel || \"llama2\";",
            "lineNumber": 266
          },
          {
            "text": "}",
            "lineNumber": 282,
            "isSignature": true
          }
        ]
      },
      "score": 0.23961275815963745
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 361
          },
          "endPosition": {
            "line": 465,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings\n): void {\n\n\tdata.edges.push({\n\t\tid: randomId(),\n\t\tfromNode: sourceNode.id,\n\t\ttoNode: newNodeId,\n\t\tlabel: EDGE_LABEL_OUTPUT,\n\t});\n}\n\n/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */\nexport async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return { ok: false, message: \"Node not found.\" };\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };\n\tconst parentIds = getParentIdsSortedByY(nodeId, data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tfor (const pid of parentIds) {\n\t\tif (getNodeResult(canvasKey, pid) == null) {\n\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);\n\t\t}\n\t}\n\ttry {\n\t\tsetRunningNodeId(canvasKey, nodeId);\n\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);\n\t\treturn { ok: true };\n\t} catch (e)\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 362,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 363,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 364,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 365,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 366,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 367,
            "isSignature": true
          },
          {
            "lineNumber": 426
          },
          {
            "text": "\tdata.edges.push({",
            "lineNumber": 427
          },
          {
            "text": "\t\tid: randomId(),",
            "lineNumber": 428
          },
          {
            "text": "\t\tfromNode: sourceNode.id,",
            "lineNumber": 429
          },
          {
            "text": "\t\ttoNode: newNodeId,",
            "lineNumber": 430
          },
          {
            "text": "\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 431
          },
          {
            "text": "\t});",
            "lineNumber": 432
          },
          {
            "text": "}",
            "lineNumber": 433,
            "isSignature": true
          },
          {
            "lineNumber": 434
          },
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 435
          },
          {
            "text": "export async function runNode(",
            "lineNumber": 436,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 437,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 438,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 439,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 440,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 441,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 442,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 443
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 444
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 445
          },
          {
            "text": "\tif (!node) return { ok: false, message: \"Node not found.\" };",
            "lineNumber": 446
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 447
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 448
          },
          {
            "text": "\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };",
            "lineNumber": 449
          },
          {
            "text": "\tconst parentIds = getParentIdsSortedByY(nodeId, data);",
            "lineNumber": 450
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 451
          },
          {
            "text": "\tfor (const pid of parentIds) {",
            "lineNumber": 452
          },
          {
            "text": "\t\tif (getNodeResult(canvasKey, pid) == null) {",
            "lineNumber": 453
          },
          {
            "text": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);",
            "lineNumber": 454
          },
          {
            "text": "\t\t}",
            "lineNumber": 455
          },
          {
            "text": "\t}",
            "lineNumber": 456
          },
          {
            "text": "\ttry {",
            "lineNumber": 457
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, nodeId);",
            "lineNumber": 458
          },
          {
            "text": "\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);",
            "lineNumber": 459
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 460
          },
          {
            "text": "\t} catch (e)",
            "lineNumber": 461
          },
          {
            "text": "}",
            "lineNumber": 466,
            "isSignature": true
          }
        ]
      },
      "score": 0.21887710690498352
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 75,
            "column": 1
          },
          "endPosition": {
            "line": 95,
            "column": 1
          }
        },
        "contents": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */\nexport function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));\n\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withY = fromIds\n\t\t.map((id) =&gt; {\n\t\t\tconst node = nodeMap.get(id);\n\t\t\treturn node ? { id, y: node.y } : null;\n\t\t})\n\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);\n\twithY.sort((a, b) =&gt; a.y - b.y);\n\treturn withY.map((x) =&gt; x.id);\n}\n\n/** Get node by id from canvas data. */\nexport function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */",
            "lineNumber": 78
          },
          {
            "text": "export function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {",
            "lineNumber": 79,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));",
            "lineNumber": 80
          },
          {
            "text": "\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];",
            "lineNumber": 81
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 82
          },
          {
            "text": "\tconst withY = fromIds",
            "lineNumber": 83
          },
          {
            "text": "\t\t.map((id) =&gt; {",
            "lineNumber": 84
          },
          {
            "text": "\t\t\tconst node = nodeMap.get(id);",
            "lineNumber": 85
          },
          {
            "text": "\t\t\treturn node ? { id, y: node.y } : null;",
            "lineNumber": 86
          },
          {
            "text": "\t\t})",
            "lineNumber": 87
          },
          {
            "text": "\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);",
            "lineNumber": 88
          },
          {
            "text": "\twithY.sort((a, b) =&gt; a.y - b.y);",
            "lineNumber": 89
          },
          {
            "text": "\treturn withY.map((x) =&gt; x.id);",
            "lineNumber": 90
          },
          {
            "text": "}",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "lineNumber": 92
          },
          {
            "text": "/** Get node by id from canvas data. */",
            "lineNumber": 93
          },
          {
            "text": "export function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {",
            "lineNumber": 94,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 95
          },
          {
            "text": "}",
            "lineNumber": 96,
            "isSignature": true
          }
        ]
      },
      "score": 0.20615769922733307
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 350,
            "column": 1
          },
          "endPosition": {
            "line": 432,
            "column": 1
          }
        },
        "contents": "/** Generate a unique id for new canvas nodes/edges. */\nfunction randomId(): string {\n\tif (typeof crypto !== \"undefined\" &amp;&amp; crypto.randomUUID) {\n\t\treturn crypto.randomUUID();\n\t}\n\treturn \"output-\" + Date.now() + \"-\" + Math.random().toString(36).slice(2, 11);\n}\n\n/** Create or replace the Green output node and ensure an edge labeled \"output\" from source. Mutates data only. */\nfunction ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings\n): void {\n\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);\n\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;\n\tconst width = Math.max(320, sourceNode.width);\n\tconst height = 180;\n\tconst defaultX = sourceNode.x;\n\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(\n\t\tdata,\n\t\tsourceNode.id,\n\t\toutId,\n\t\tdefaultX,\n\t\tdefaultY,\n\t\twidth,\n\t\theight\n\t);\n\tconst greenColor = settings.colorGreen;\n\n\tif (outId) {\n\t\tconst outNode = getNodeById(data, outId);\n\t\tif (outNode &amp;&amp; isTextNode(outNode)) {\n\t\t\tconst updated = {\n\t\t\t\t...(outNode as CanvasTextData),\n\t\t\t\ttext,\n\t\t\t\tx: chosenX,\n\t\t\t\ty: chosenY,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t};\n\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);\n\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t} else if (outNode) {\n\t\t\t(outNode as { x: number; y: number }).x = chosenX;\n\t\t\t(outNode as { x: number; y: number }).y = chosenY;\n\t\t}\n\t\tconst hasOutputEdge = data.edges.some(\n\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t\t);\n\t\tif (!hasOutputEdge) {\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: outId,\n\t\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tconst newNodeId = randomId();\n\tconst newTextNode: CanvasTextData = {\n\t\tid: newNodeId,\n\t\ttype: \"text\",\n\t\ttext,\n\t\tx: chosenX,\n\t\ty: chosenY,\n\t\twidth,\n\t\theight,\n\t\tcolor: greenColor,\n\t};\n\tdata.nodes.push(newTextNode);\n\tdata.edges.push({\n\t\tid: randomId(),\n\t\tfromNode: sourceNode.id,\n\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Generate a unique id for new canvas nodes/edges. */",
            "lineNumber": 353
          },
          {
            "text": "function randomId(): string {",
            "lineNumber": 354,
            "isSignature": true
          },
          {
            "text": "\tif (typeof crypto !== \"undefined\" &amp;&amp; crypto.randomUUID) {",
            "lineNumber": 355
          },
          {
            "text": "\t\treturn crypto.randomUUID();",
            "lineNumber": 356
          },
          {
            "text": "\t}",
            "lineNumber": 357
          },
          {
            "text": "\treturn \"output-\" + Date.now() + \"-\" + Math.random().toString(36).slice(2, 11);",
            "lineNumber": 358
          },
          {
            "text": "}",
            "lineNumber": 359,
            "isSignature": true
          },
          {
            "lineNumber": 360
          },
          {
            "text": "/** Create or replace the Green output node and ensure an edge labeled \"output\" from source. Mutates data only. */",
            "lineNumber": 361
          },
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 362,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 363,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 364,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 365,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 366,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 367,
            "isSignature": true
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);",
            "lineNumber": 368
          },
          {
            "text": "\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;",
            "lineNumber": 369
          },
          {
            "text": "\tconst width = Math.max(320, sourceNode.width);",
            "lineNumber": 370
          },
          {
            "text": "\tconst height = 180;",
            "lineNumber": 371
          },
          {
            "text": "\tconst defaultX = sourceNode.x;",
            "lineNumber": 372
          },
          {
            "text": "\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(",
            "lineNumber": 373
          },
          {
            "text": "\t\tdata,",
            "lineNumber": 374
          },
          {
            "text": "\t\tsourceNode.id,",
            "lineNumber": 375
          },
          {
            "text": "\t\toutId,",
            "lineNumber": 376
          },
          {
            "text": "\t\tdefaultX,",
            "lineNumber": 377
          },
          {
            "text": "\t\tdefaultY,",
            "lineNumber": 378
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 379
          },
          {
            "text": "\t\theight",
            "lineNumber": 380
          },
          {
            "text": "\t);",
            "lineNumber": 381
          },
          {
            "text": "\tconst greenColor = settings.colorGreen;",
            "lineNumber": 382
          },
          {
            "lineNumber": 383
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 384
          },
          {
            "text": "\t\tconst outNode = getNodeById(data, outId);",
            "lineNumber": 385
          },
          {
            "text": "\t\tif (outNode &amp;&amp; isTextNode(outNode)) {",
            "lineNumber": 386
          },
          {
            "text": "\t\t\tconst updated = {",
            "lineNumber": 387
          },
          {
            "text": "\t\t\t\t...(outNode as CanvasTextData),",
            "lineNumber": 388
          },
          {
            "text": "\t\t\t\ttext,",
            "lineNumber": 389
          },
          {
            "text": "\t\t\t\tx: chosenX,",
            "lineNumber": 390
          },
          {
            "text": "\t\t\t\ty: chosenY,",
            "lineNumber": 391
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 392
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 393
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 394
          },
          {
            "text": "\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);",
            "lineNumber": 395
          },
          {
            "text": "\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 396
          },
          {
            "text": "\t\t} else if (outNode) {",
            "lineNumber": 397
          },
          {
            "text": "\t\t\t(outNode as { x: number; y: number }).x = chosenX;",
            "lineNumber": 398
          },
          {
            "text": "\t\t\t(outNode as { x: number; y: number }).y = chosenY;",
            "lineNumber": 399
          },
          {
            "text": "\t\t}",
            "lineNumber": 400
          },
          {
            "text": "\t\tconst hasOutputEdge = data.edges.some(",
            "lineNumber": 401
          },
          {
            "text": "\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 402
          },
          {
            "text": "\t\t);",
            "lineNumber": 403
          },
          {
            "text": "\t\tif (!hasOutputEdge) {",
            "lineNumber": 404
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 405
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 406
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 407
          },
          {
            "text": "\t\t\t\ttoNode: outId,",
            "lineNumber": 408
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 409
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 410
          },
          {
            "text": "\t\t}",
            "lineNumber": 411
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 412
          },
          {
            "text": "\t}",
            "lineNumber": 413
          },
          {
            "lineNumber": 414
          },
          {
            "text": "\tconst newNodeId = randomId();",
            "lineNumber": 415
          },
          {
            "text": "\tconst newTextNode: CanvasTextData = {",
            "lineNumber": 416
          },
          {
            "text": "\t\tid: newNodeId,",
            "lineNumber": 417
          },
          {
            "text": "\t\ttype: \"text\",",
            "lineNumber": 418
          },
          {
            "text": "\t\ttext,",
            "lineNumber": 419
          },
          {
            "text": "\t\tx: chosenX,",
            "lineNumber": 420
          },
          {
            "text": "\t\ty: chosenY,",
            "lineNumber": 421
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 422
          },
          {
            "text": "\t\theight,",
            "lineNumber": 423
          },
          {
            "text": "\t\tcolor: greenColor,",
            "lineNumber": 424
          },
          {
            "text": "\t};",
            "lineNumber": 425
          },
          {
            "text": "\tdata.nodes.push(newTextNode);",
            "lineNumber": 426
          },
          {
            "text": "\tdata.edges.push({",
            "lineNumber": 427
          },
          {
            "text": "\t\tid: randomId(),",
            "lineNumber": 428
          },
          {
            "text": "\t\tfromNode: sourceNode.id,",
            "lineNumber": 429
          },
          {
            "lineNumber": 432
          },
          {
            "text": "}",
            "lineNumber": 433,
            "isSignature": true
          }
        ]
      },
      "score": 0.19360744953155518
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 42,
            "column": 1
          },
          "endPosition": {
            "line": 60,
            "column": 101
          }
        },
        "contents": "/** Check if there is a path from fromId to toId (ignoring output edges). */\nfunction canReach(data: CanvasData, fromId: string, toId: string): boolean {\n\tconst visited = new Set&lt;string&gt;();\n\tconst stack = [fromId];\n\twhile (stack.length &gt; 0) {\n\t\tconst id = stack.pop()!;\n\t\tif (id === toId) return true;\n\t\tif (visited.has(id)) continue;\n\t\tvisited.add(id);\n\t\tfor (const e of data.edges) {\n\t\t\tif (!isOutputEdge(e) &amp;&amp; e.fromNode === id) stack.push(e.toNode);\n\t\t}\n\t}\n\treturn false;\n}\n\n/** Topological order of node ids (only nodes that are ancestors of target; ignores output edges). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Check if there is a path from fromId to toId (ignoring output edges). */",
            "lineNumber": 45
          },
          {
            "text": "function canReach(data: CanvasData, fromId: string, toId: string): boolean {",
            "lineNumber": 46,
            "isSignature": true
          },
          {
            "text": "\tconst visited = new Set&lt;string&gt;();",
            "lineNumber": 47
          },
          {
            "text": "\tconst stack = [fromId];",
            "lineNumber": 48
          },
          {
            "text": "\twhile (stack.length &gt; 0) {",
            "lineNumber": 49
          },
          {
            "text": "\t\tconst id = stack.pop()!;",
            "lineNumber": 50
          },
          {
            "text": "\t\tif (id === toId) return true;",
            "lineNumber": 51
          },
          {
            "text": "\t\tif (visited.has(id)) continue;",
            "lineNumber": 52
          },
          {
            "text": "\t\tvisited.add(id);",
            "lineNumber": 53
          },
          {
            "text": "\t\tfor (const e of data.edges) {",
            "lineNumber": 54
          },
          {
            "text": "\t\t\tif (!isOutputEdge(e) &amp;&amp; e.fromNode === id) stack.push(e.toNode);",
            "lineNumber": 55
          },
          {
            "text": "\t\t}",
            "lineNumber": 56
          },
          {
            "text": "\t}",
            "lineNumber": 57
          },
          {
            "text": "\treturn false;",
            "lineNumber": 58
          },
          {
            "text": "}",
            "lineNumber": 59,
            "isSignature": true
          },
          {
            "lineNumber": 60
          },
          {
            "text": "/** Topological order of node ids (only nodes that are ancestors of target; ignores output edges). */",
            "lineNumber": 61
          }
        ]
      },
      "score": 0.18383604288101196
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 128,
            "column": 1
          },
          "endPosition": {
            "line": 148,
            "column": 93
          }
        },
        "contents": "/** Sort ready queue: non-AI (Python, yellow) first for early output, then by y. */\nfunction sortQueueByNonAIFirst(\n\tqueue: string[],\n\tdata: CanvasData,\n\tsettings: ZettelPluginSettings\n): void {\n\tqueue.sort((a, b) =&gt; {\n\t\tconst na = getNodeById(data, a);\n\t\tconst nb = getNodeById(data, b);\n\t\tconst roleA = getNodeRole(na ?? { color: undefined }, settings);\n\t\tconst roleB = getNodeRole(nb ?? { color: undefined }, settings);\n\t\tconst nonA = isNonAIRole(roleA) ? 0 : 1;\n\t\tconst nonB = isNonAIRole(roleB) ? 0 : 1;\n\t\tif (nonA !== nonB) return nonA - nonB;\n\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);\n\t});\n}\n\n/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Sort ready queue: non-AI (Python, yellow) first for early output, then by y. */",
            "lineNumber": 131
          },
          {
            "text": "function sortQueueByNonAIFirst(",
            "lineNumber": 132,
            "isSignature": true
          },
          {
            "text": "\tqueue: string[],",
            "lineNumber": 133,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 134,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 135,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 136,
            "isSignature": true
          },
          {
            "text": "\tqueue.sort((a, b) =&gt; {",
            "lineNumber": 137
          },
          {
            "text": "\t\tconst na = getNodeById(data, a);",
            "lineNumber": 138
          },
          {
            "text": "\t\tconst nb = getNodeById(data, b);",
            "lineNumber": 139
          },
          {
            "text": "\t\tconst roleA = getNodeRole(na ?? { color: undefined }, settings);",
            "lineNumber": 140
          },
          {
            "text": "\t\tconst roleB = getNodeRole(nb ?? { color: undefined }, settings);",
            "lineNumber": 141
          },
          {
            "text": "\t\tconst nonA = isNonAIRole(roleA) ? 0 : 1;",
            "lineNumber": 142
          },
          {
            "text": "\t\tconst nonB = isNonAIRole(roleB) ? 0 : 1;",
            "lineNumber": 143
          },
          {
            "text": "\t\tif (nonA !== nonB) return nonA - nonB;",
            "lineNumber": 144
          },
          {
            "text": "\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);",
            "lineNumber": 145
          },
          {
            "text": "\t});",
            "lineNumber": 146
          },
          {
            "text": "}",
            "lineNumber": 147,
            "isSignature": true
          },
          {
            "lineNumber": 148
          },
          {
            "text": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
            "lineNumber": 149
          }
        ]
      },
      "score": 0.18004566431045532
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\n\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js).\n\t\t\tconst addNodeMenuItems = (menu: Menu, node: unknown): void =&gt; {\n\t\t\t\tdebugNodeMenuFired = true;\n\t\t\t\tconst nodeId = resolveCanvasNodeId(node);\n\t\t\t\tif (!nodeId) return;\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Dismiss output\").setIcon(\"trash\").onClick(() =&gt; this.dismissOutput(nodeId))\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst registerCanvasNodeMenu = () =&gt; {\n\t\t\t\ttry {\n\t\t\t\t\tconst on = this.app.workspace.on.bind(this.app.workspace) as (\n\t\t\t\t\t\tname: string,\n\t\t\t\t\t\tcallback: (menu: Menu, node: unknown) =&gt; void\n\t\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;\n\t\t\t\t\t// Try documented-style event name first; some Obsidian builds use \"canvas:node-menu\".\n\t\t\t\t\tthis.registerEvent(on(\"canvas:node-menu\", addNodeMenuItems));\n\t\t\t\t\t// Fallback: try hyphenated name in case the app triggers a different event.\n\t\t\t\t\tthis.registerEvent(on(\"canvas-node-menu\", addNodeMenuItems));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas node menu.\", e);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst timeoutId = window.setTimeout(registerCanvasNodeMenu, 0);\n\t\t\tthis.register(() =&gt; window.clearTimeout(timeoutId));\n\n\t\t\t// Canvas background context menu: use undocumented \"canvas:edge-menu\" (Obsidian broadcasts it;\n\t\t\t// when right-click is on empty area, edge is null). Same pattern as canvas:node-menu: addItem with setTitle, setIcon, onClick.\n\t\t\tconst addCanvasMenuItems = (menu: Menu): void =&gt; {\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Dismiss all output\").setIcon(\"trash\").onClick(() =&gt; this.dismissAllOutput())\n\t\t\t\t);\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace)\n;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 37,
                "column": 2
              },
              "endPosition": {
                "line": 38,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 37
          },
          {
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 90
          },
          {
            "text": "\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js).",
            "lineNumber": 91
          },
          {
            "text": "\t\t\tconst addNodeMenuItems = (menu: Menu, node: unknown): void =&gt; {",
            "lineNumber": 92
          },
          {
            "text": "\t\t\t\tdebugNodeMenuFired = true;",
            "lineNumber": 93
          },
          {
            "text": "\t\t\t\tconst nodeId = resolveCanvasNodeId(node);",
            "lineNumber": 94
          },
          {
            "text": "\t\t\t\tif (!nodeId) return;",
            "lineNumber": 95
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 96
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))",
            "lineNumber": 97
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 98
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 99
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))",
            "lineNumber": 100
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 101
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 102
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Dismiss output\").setIcon(\"trash\").onClick(() =&gt; this.dismissOutput(nodeId))",
            "lineNumber": 103
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 104
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 105
          },
          {
            "text": "\t\t\tconst registerCanvasNodeMenu = () =&gt; {",
            "lineNumber": 106
          },
          {
            "text": "\t\t\t\ttry {",
            "lineNumber": 107
          },
          {
            "text": "\t\t\t\t\tconst on = this.app.workspace.on.bind(this.app.workspace) as (",
            "lineNumber": 108
          },
          {
            "text": "\t\t\t\t\t\tname: string,",
            "lineNumber": 109
          },
          {
            "text": "\t\t\t\t\t\tcallback: (menu: Menu, node: unknown) =&gt; void",
            "lineNumber": 110
          },
          {
            "text": "\t\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;",
            "lineNumber": 111
          },
          {
            "text": "\t\t\t\t\t// Try documented-style event name first; some Obsidian builds use \"canvas:node-menu\".",
            "lineNumber": 112
          },
          {
            "text": "\t\t\t\t\tthis.registerEvent(on(\"canvas:node-menu\", addNodeMenuItems));",
            "lineNumber": 113
          },
          {
            "text": "\t\t\t\t\t// Fallback: try hyphenated name in case the app triggers a different event.",
            "lineNumber": 114
          },
          {
            "text": "\t\t\t\t\tthis.registerEvent(on(\"canvas-node-menu\", addNodeMenuItems));",
            "lineNumber": 115
          },
          {
            "text": "\t\t\t\t} catch (e) {",
            "lineNumber": 116
          },
          {
            "text": "\t\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas node menu.\", e);",
            "lineNumber": 117
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 118
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 119
          },
          {
            "text": "\t\t\tconst timeoutId = window.setTimeout(registerCanvasNodeMenu, 0);",
            "lineNumber": 120
          },
          {
            "text": "\t\t\tthis.register(() =&gt; window.clearTimeout(timeoutId));",
            "lineNumber": 121
          },
          {
            "lineNumber": 122
          },
          {
            "text": "\t\t\t// Canvas background context menu: use undocumented \"canvas:edge-menu\" (Obsidian broadcasts it;",
            "lineNumber": 123
          },
          {
            "text": "\t\t\t// when right-click is on empty area, edge is null). Same pattern as canvas:node-menu: addItem with setTitle, setIcon, onClick.",
            "lineNumber": 124
          },
          {
            "text": "\t\t\tconst addCanvasMenuItems = (menu: Menu): void =&gt; {",
            "lineNumber": 125
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 126
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())",
            "lineNumber": 127
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 128
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 129
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Dismiss all output\").setIcon(\"trash\").onClick(() =&gt; this.dismissAllOutput())",
            "lineNumber": 130
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 131
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 132
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 133
          },
          {
            "text": "\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace)",
            "lineNumber": 134
          },
          {
            "text": ";",
            "lineNumber": 137
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.17623670399188995
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 97,
            "column": 1
          },
          "endPosition": {
            "line": 130,
            "column": 83
          }
        },
        "contents": "function topologicalSort(\n\tdata: CanvasData,\n\texecEdges: CanvasEdgeData[],\n\tnodeIds: Set&lt;string&gt;,\n\tsettings: ZettelPluginSettings\n): string[] {\n\tconst inDegree = new Map&lt;string, number&gt;();\n\tfor (const id of nodeIds) inDegree.set(id, 0);\n\tfor (const e of execEdges) {\n\t\tif (nodeIds.has(e.fromNode) &amp;&amp; nodeIds.has(e.toNode)) {\n\t\t\tinDegree.set(e.toNode, (inDegree.get(e.toNode) ?? 0) + 1);\n\t\t}\n\t}\n\tconst order: string[] = [];\n\tconst queue = [...nodeIds].filter((id) =&gt; inDegree.get(id) === 0);\n\tsortQueueByNonAIFirst(queue, data, settings);\n\twhile (queue.length &gt; 0) {\n\t\tconst id = queue.shift()!;\n\t\torder.push(id);\n\t\tfor (const e of execEdges) {\n\t\t\tif (e.fromNode === id &amp;&amp; nodeIds.has(e.toNode)) {\n\t\t\t\tconst d = (inDegree.get(e.toNode) ?? 0) - 1;\n\t\t\t\tinDegree.set(e.toNode, d);\n\t\t\t\tif (d === 0) queue.push(e.toNode);\n\t\t\t}\n\t\t}\n\t\tsortQueueByNonAIFirst(queue, data, settings);\n\t}\n\treturn order;\n}\n\n/** Sort ready queue: non-AI (Python, yellow) first for early output, then by y. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function topologicalSort(",
            "lineNumber": 100,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 101,
            "isSignature": true
          },
          {
            "text": "\texecEdges: CanvasEdgeData[],",
            "lineNumber": 102,
            "isSignature": true
          },
          {
            "text": "\tnodeIds: Set&lt;string&gt;,",
            "lineNumber": 103,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 104,
            "isSignature": true
          },
          {
            "text": "): string[] {",
            "lineNumber": 105,
            "isSignature": true
          },
          {
            "text": "\tconst inDegree = new Map&lt;string, number&gt;();",
            "lineNumber": 106
          },
          {
            "text": "\tfor (const id of nodeIds) inDegree.set(id, 0);",
            "lineNumber": 107
          },
          {
            "text": "\tfor (const e of execEdges) {",
            "lineNumber": 108
          },
          {
            "text": "\t\tif (nodeIds.has(e.fromNode) &amp;&amp; nodeIds.has(e.toNode)) {",
            "lineNumber": 109
          },
          {
            "text": "\t\t\tinDegree.set(e.toNode, (inDegree.get(e.toNode) ?? 0) + 1);",
            "lineNumber": 110
          },
          {
            "text": "\t\t}",
            "lineNumber": 111
          },
          {
            "text": "\t}",
            "lineNumber": 112
          },
          {
            "text": "\tconst order: string[] = [];",
            "lineNumber": 113
          },
          {
            "text": "\tconst queue = [...nodeIds].filter((id) =&gt; inDegree.get(id) === 0);",
            "lineNumber": 114
          },
          {
            "text": "\tsortQueueByNonAIFirst(queue, data, settings);",
            "lineNumber": 115
          },
          {
            "text": "\twhile (queue.length &gt; 0) {",
            "lineNumber": 116
          },
          {
            "text": "\t\tconst id = queue.shift()!;",
            "lineNumber": 117
          },
          {
            "text": "\t\torder.push(id);",
            "lineNumber": 118
          },
          {
            "text": "\t\tfor (const e of execEdges) {",
            "lineNumber": 119
          },
          {
            "text": "\t\t\tif (e.fromNode === id &amp;&amp; nodeIds.has(e.toNode)) {",
            "lineNumber": 120
          },
          {
            "text": "\t\t\t\tconst d = (inDegree.get(e.toNode) ?? 0) - 1;",
            "lineNumber": 121
          },
          {
            "text": "\t\t\t\tinDegree.set(e.toNode, d);",
            "lineNumber": 122
          },
          {
            "text": "\t\t\t\tif (d === 0) queue.push(e.toNode);",
            "lineNumber": 123
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 124
          },
          {
            "text": "\t\t}",
            "lineNumber": 125
          },
          {
            "text": "\t\tsortQueueByNonAIFirst(queue, data, settings);",
            "lineNumber": 126
          },
          {
            "text": "\t}",
            "lineNumber": 127
          },
          {
            "text": "\treturn order;",
            "lineNumber": 128
          },
          {
            "text": "}",
            "lineNumber": 129,
            "isSignature": true
          },
          {
            "lineNumber": 130
          },
          {
            "text": "/** Sort ready queue: non-AI (Python, yellow) first for early output, then by y. */",
            "lineNumber": 131
          }
        ]
      },
      "score": 0.16941459476947784
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 468
          },
          "endPosition": {
            "line": 521,
            "column": 1
          }
        },
        "contents": "export async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n;\n\t\t\t} finally {\n\t\t\t\tsetRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t}\n}\n\n/** Run chain from roots to the given node. */\nexport async function runChain(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst roots = getRootIds(data);\n\tconst rootsReachingCurrent = roots.filter((r) =&gt; canReach(data, r, nodeId));\n\tif (rootsReachingCurrent.length === 0) return { ok: false, message: \"No root reaches this node.\" };\n\tconst order = topologicalOrderToTarget(data, nodeId, settings);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\ttry {\n\t\tfor (const nid of order) {\n\t\t\ttry {\n\t\t\t\tsetRunningNodeId(canvasKey, nid);\n\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);\n\t\t\t} finally {\n\t\t\t\tsetRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 469,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 470,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 471,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 472,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 473,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 474,
            "isSignature": true
          },
          {
            "text": ";",
            "lineNumber": 483
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 484
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 485
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 486
          },
          {
            "text": "\t\t}",
            "lineNumber": 487
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 488
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 489
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 490
          },
          {
            "text": "\t}",
            "lineNumber": 491
          },
          {
            "text": "}",
            "lineNumber": 492,
            "isSignature": true
          },
          {
            "lineNumber": 493
          },
          {
            "text": "/** Run chain from roots to the given node. */",
            "lineNumber": 494
          },
          {
            "text": "export async function runChain(",
            "lineNumber": 495,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 496,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 497,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 498,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 499,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 500,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 501,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 502
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 503
          },
          {
            "text": "\tconst roots = getRootIds(data);",
            "lineNumber": 504
          },
          {
            "text": "\tconst rootsReachingCurrent = roots.filter((r) =&gt; canReach(data, r, nodeId));",
            "lineNumber": 505
          },
          {
            "text": "\tif (rootsReachingCurrent.length === 0) return { ok: false, message: \"No root reaches this node.\" };",
            "lineNumber": 506
          },
          {
            "text": "\tconst order = topologicalOrderToTarget(data, nodeId, settings);",
            "lineNumber": 507
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 508
          },
          {
            "text": "\ttry {",
            "lineNumber": 509
          },
          {
            "text": "\t\tfor (const nid of order) {",
            "lineNumber": 510
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 511
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, nid);",
            "lineNumber": 512
          },
          {
            "text": "\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);",
            "lineNumber": 513
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 514
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 515
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 516
          },
          {
            "text": "\t\t}",
            "lineNumber": 517
          },
          {
            "text": "}",
            "lineNumber": 522,
            "isSignature": true
          }
        ]
      },
      "score": 0.16850480437278748
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/canvasApi.ts",
        "range": {
          "startPosition": {
            "column": 86
          },
          "endPosition": {
            "line": 15,
            "column": 1
          }
        },
        "contents": "export interface LiveCanvas {\n\tcreateTextNode(options: {\n\t\ttext: string;\n\t\tpos: { x: number; y: number };\n\t\tsize: { width: number; height: number };\n\t\tsave?: boolean;\n\t\tfocus?: boolean;\n\t}): { id: string; x: number; y: number; width: number; height: number; moveTo: (pos: { x: number; y: number }) =&gt; void; resize: (size: { width: number; height: number }) =&gt; void };\n\taddNode(node: unknown): void;\n\trequestSave?: () =&gt; void;\n\tremoveNode?(node: unknown): void;\n\tnodes?: Map&lt;string, unknown&gt; | Iterable&lt;unknown&gt;;\n\t/** If present, used to refresh canvas after edge label updates (Obsidian canvas view). */\n\tsetData?(data: unknown): void;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export interface LiveCanvas {",
            "lineNumber": 2,
            "isSignature": true
          },
          {
            "text": "\tcreateTextNode(options: {",
            "lineNumber": 3
          },
          {
            "text": "\t\ttext: string;",
            "lineNumber": 4
          },
          {
            "text": "\t\tpos: { x: number; y: number };",
            "lineNumber": 5
          },
          {
            "text": "\t\tsize: { width: number; height: number };",
            "lineNumber": 6
          },
          {
            "text": "\t\tsave?: boolean;",
            "lineNumber": 7
          },
          {
            "text": "\t\tfocus?: boolean;",
            "lineNumber": 8
          },
          {
            "text": "\t}): { id: string; x: number; y: number; width: number; height: number; moveTo: (pos: { x: number; y: number }) =&gt; void; resize: (size: { width: number; height: number }) =&gt; void };",
            "lineNumber": 9
          },
          {
            "text": "\taddNode(node: unknown): void;",
            "lineNumber": 10
          },
          {
            "text": "\trequestSave?: () =&gt; void;",
            "lineNumber": 11
          },
          {
            "text": "\tremoveNode?(node: unknown): void;",
            "lineNumber": 12
          },
          {
            "text": "\tnodes?: Map&lt;string, unknown&gt; | Iterable&lt;unknown&gt;;",
            "lineNumber": 13
          },
          {
            "text": "\t/** If present, used to refresh canvas after edge label updates (Obsidian canvas view). */",
            "lineNumber": 14
          },
          {
            "text": "\tsetData?(data: unknown): void;",
            "lineNumber": 15,
            "isSignature": true
          },
          {
            "text": "}",
            "lineNumber": 16,
            "isSignature": true
          }
        ]
      },
      "score": 0.16658973693847656
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 131,
            "column": 1
          },
          "endPosition": {
            "line": 180,
            "column": 1
          }
        },
        "contents": "/**\n * Sync floating role labels for the active canvas: for each node whose color maps to a role,\n * add a small label above the node (e.g. \"Comment\", \"Python\"). Removes existing labels first.\n * Uses the live canvas node map to find each node's DOM element (.canvas-node).\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasRoleLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tsettings: ZettelPluginSettings,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tif (!settings.showNodeRoleLabels) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.nodes) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).\n\tclearCanvasRoleLabels(containerEl);\n\tsyncCanvasLegend(containerEl, settings);\n\tfor (const node of data.nodes) {\n\t\tconst role = getNodeRole(node, settings);\n\t\tif (!role) continue;\n\t\tconst labelText = getRoleLabel(role, settings);\n\t\tconst nodeEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||\n\t\t\tfindNodeElementByDataId(containerEl, node.id);\n\t\tif (!nodeEl) continue;\n\t\tconst label = createLabelEl(labelText);\n\t\t// Append after .canvas-node-container so it matches Obsidian file node label position\n\t\tnodeEl.append(label);\n\t}\n}\n\n/** Get center of an element in viewport coordinates. */\nfunction getElCenter(el: HTMLElement): { x: number; y: number } {\n\tconst r = el.getBoundingClientRect();\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/**",
            "lineNumber": 134
          },
          {
            "text": " * Sync floating role labels for the active canvas: for each node whose color maps to a role,",
            "lineNumber": 135
          },
          {
            "text": " * add a small label above the node (e.g. \"Comment\", \"Python\"). Removes existing labels first.",
            "lineNumber": 136
          },
          {
            "text": " * Uses the live canvas node map to find each node's DOM element (.canvas-node).",
            "lineNumber": 137
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 138
          },
          {
            "text": " */",
            "lineNumber": 139
          },
          {
            "text": "export async function syncCanvasRoleLabels(",
            "lineNumber": 140,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 141,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 142,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 143,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 144,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 145,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 146,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 147,
            "isSignature": true
          },
          {
            "text": "\tif (!settings.showNodeRoleLabels) {",
            "lineNumber": 148
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 149
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 150
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 151
          },
          {
            "text": "\t}",
            "lineNumber": 152
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 153
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 154
          },
          {
            "text": "\tif (!data?.nodes) {",
            "lineNumber": 155
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 156
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 157
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 158
          },
          {
            "text": "\t}",
            "lineNumber": 159
          },
          {
            "text": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).",
            "lineNumber": 160
          },
          {
            "text": "\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 161
          },
          {
            "text": "\tsyncCanvasLegend(containerEl, settings);",
            "lineNumber": 162
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 163
          },
          {
            "text": "\t\tconst role = getNodeRole(node, settings);",
            "lineNumber": 164
          },
          {
            "text": "\t\tif (!role) continue;",
            "lineNumber": 165
          },
          {
            "text": "\t\tconst labelText = getRoleLabel(role, settings);",
            "lineNumber": 166
          },
          {
            "text": "\t\tconst nodeEl =",
            "lineNumber": 167
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||",
            "lineNumber": 168
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, node.id);",
            "lineNumber": 169
          },
          {
            "text": "\t\tif (!nodeEl) continue;",
            "lineNumber": 170
          },
          {
            "text": "\t\tconst label = createLabelEl(labelText);",
            "lineNumber": 171
          },
          {
            "text": "\t\t// Append after .canvas-node-container so it matches Obsidian file node label position",
            "lineNumber": 172
          },
          {
            "text": "\t\tnodeEl.append(label);",
            "lineNumber": 173
          },
          {
            "text": "\t}",
            "lineNumber": 174
          },
          {
            "text": "}",
            "lineNumber": 175,
            "isSignature": true
          },
          {
            "lineNumber": 176
          },
          {
            "text": "/** Get center of an element in viewport coordinates. */",
            "lineNumber": 177
          },
          {
            "text": "function getElCenter(el: HTMLElement): { x: number; y: number } {",
            "lineNumber": 178,
            "isSignature": true
          },
          {
            "text": "\tconst r = el.getBoundingClientRect();",
            "lineNumber": 179
          },
          {
            "text": "}",
            "lineNumber": 181,
            "isSignature": true
          }
        ]
      },
      "score": 0.164328932762146
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "column": 71
          },
          "endPosition": {
            "line": 30,
            "column": 108
          }
        },
        "contents": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";\nimport {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";\nimport {\n\tdismissAllOutput as runnerDismissAllOutput,\n\tdismissOutput as runnerDismissOutput,\n\trunChain as runnerRunChain,\n\trunEntireCanvas as runnerRunEntireCanvas,\n\trunNode as runnerRunNode,\n} from \"./engine/runner\";\nimport {\n\tclearCanvasEdgeModeLabels,\n\tclearCanvasLegend,\n\tclearCanvasRoleLabels,\n\tsyncCanvasEdgeModeLabels,\n\tsyncCanvasRoleLabels,\n} from \"./canvas/canvasNodeLabels\";\nimport {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";\n\n/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */\nfunction resolveCanvasNodeId(node: unknown): string | undefined {\n\tif (!node || typeof node !== \"object\") return undefined;\n\tconst n = node as Record&lt;string, unknown&gt;;\n\tif (typeof n.id === \"string\") return n.id;\n\tconst inner = n.node as Record&lt;string, unknown&gt; | undefined;\n\tif (inner &amp;&amp; typeof inner.id === \"string\") return inner.id;\n\tconst data = typeof n.getData === \"function\" ? (n.getData as () =&gt; { id?: string })() : undefined;\n\treturn data?.id;\n}\n\n/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";",
            "lineNumber": 2
          },
          {
            "text": "import {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";",
            "lineNumber": 3
          },
          {
            "text": "import {",
            "lineNumber": 4
          },
          {
            "text": "\tdismissAllOutput as runnerDismissAllOutput,",
            "lineNumber": 5
          },
          {
            "text": "\tdismissOutput as runnerDismissOutput,",
            "lineNumber": 6
          },
          {
            "text": "\trunChain as runnerRunChain,",
            "lineNumber": 7
          },
          {
            "text": "\trunEntireCanvas as runnerRunEntireCanvas,",
            "lineNumber": 8
          },
          {
            "text": "\trunNode as runnerRunNode,",
            "lineNumber": 9
          },
          {
            "text": "} from \"./engine/runner\";",
            "lineNumber": 10
          },
          {
            "text": "import {",
            "lineNumber": 11
          },
          {
            "text": "\tclearCanvasEdgeModeLabels,",
            "lineNumber": 12
          },
          {
            "text": "\tclearCanvasLegend,",
            "lineNumber": 13
          },
          {
            "text": "\tclearCanvasRoleLabels,",
            "lineNumber": 14
          },
          {
            "text": "\tsyncCanvasEdgeModeLabels,",
            "lineNumber": 15
          },
          {
            "text": "\tsyncCanvasRoleLabels,",
            "lineNumber": 16
          },
          {
            "text": "} from \"./canvas/canvasNodeLabels\";",
            "lineNumber": 17
          },
          {
            "text": "import {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";",
            "lineNumber": 18
          },
          {
            "lineNumber": 19
          },
          {
            "text": "/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */",
            "lineNumber": 20
          },
          {
            "text": "function resolveCanvasNodeId(node: unknown): string | undefined {",
            "lineNumber": 21,
            "isSignature": true
          },
          {
            "text": "\tif (!node || typeof node !== \"object\") return undefined;",
            "lineNumber": 22
          },
          {
            "text": "\tconst n = node as Record&lt;string, unknown&gt;;",
            "lineNumber": 23
          },
          {
            "text": "\tif (typeof n.id === \"string\") return n.id;",
            "lineNumber": 24
          },
          {
            "text": "\tconst inner = n.node as Record&lt;string, unknown&gt; | undefined;",
            "lineNumber": 25
          },
          {
            "text": "\tif (inner &amp;&amp; typeof inner.id === \"string\") return inner.id;",
            "lineNumber": 26
          },
          {
            "text": "\tconst data = typeof n.getData === \"function\" ? (n.getData as () =&gt; { id?: string })() : undefined;",
            "lineNumber": 27
          },
          {
            "text": "\treturn data?.id;",
            "lineNumber": 28
          },
          {
            "text": "}",
            "lineNumber": 29,
            "isSignature": true
          },
          {
            "lineNumber": 30
          },
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 31
          }
        ]
      },
      "score": 0.16163510084152222
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 31,
            "column": 104
          }
        },
        "contents": "import type {App} from \"obsidian\";\nimport {\n\tEDGE_LABEL_OUTPUT,\n\tfindOutputNodeForSource,\n\tgetNodeById,\n\tgetNodeContent,\n\tgetNodeRole,\n\tgetIncomingEdgesWithLabels,\n\tgetParentIdsSortedByY,\n\tGREEN_NODE_PADDING,\n\tisOutputEdge,\n\tloadCanvasData,\n\tsaveCanvasData,\n} from \"../canvas/nodes\";\nimport type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";\nimport { parseEdgeVariableName } from \"../canvas/types\";\nimport {isTextNode} from \"../canvas/types\";\nimport type {LiveCanvas} from \"./canvasApi\";\nimport {getKernelForCanvas} from \"./kernelManager\";\nimport {ollamaGenerate} from \"./ollama\";\nimport {\n\tgetCanvasKey,\n\tgetNodeResult,\n\tsetNodeResult,\n\tsetEdgeModes,\n\tsetRunningNodeId,\n} from \"./state\";\nimport type {NodeRole, ZettelPluginSettings} from \"../settings\";\n\ntype EdgeInputMode = \"inject\" | \"concatenate\";\n\n/** True if the role is non-AI (Python or pass-through); prefer running these first for early output. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {App} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {",
            "lineNumber": 2
          },
          {
            "text": "\tEDGE_LABEL_OUTPUT,",
            "lineNumber": 3
          },
          {
            "text": "\tfindOutputNodeForSource,",
            "lineNumber": 4
          },
          {
            "text": "\tgetNodeById,",
            "lineNumber": 5
          },
          {
            "text": "\tgetNodeContent,",
            "lineNumber": 6
          },
          {
            "text": "\tgetNodeRole,",
            "lineNumber": 7
          },
          {
            "text": "\tgetIncomingEdgesWithLabels,",
            "lineNumber": 8
          },
          {
            "text": "\tgetParentIdsSortedByY,",
            "lineNumber": 9
          },
          {
            "text": "\tGREEN_NODE_PADDING,",
            "lineNumber": 10
          },
          {
            "text": "\tisOutputEdge,",
            "lineNumber": 11
          },
          {
            "text": "\tloadCanvasData,",
            "lineNumber": 12
          },
          {
            "text": "\tsaveCanvasData,",
            "lineNumber": 13
          },
          {
            "text": "} from \"../canvas/nodes\";",
            "lineNumber": 14
          },
          {
            "text": "import type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";",
            "lineNumber": 15
          },
          {
            "text": "import { parseEdgeVariableName } from \"../canvas/types\";",
            "lineNumber": 16
          },
          {
            "text": "import {isTextNode} from \"../canvas/types\";",
            "lineNumber": 17
          },
          {
            "text": "import type {LiveCanvas} from \"./canvasApi\";",
            "lineNumber": 18
          },
          {
            "text": "import {getKernelForCanvas} from \"./kernelManager\";",
            "lineNumber": 19
          },
          {
            "text": "import {ollamaGenerate} from \"./ollama\";",
            "lineNumber": 20
          },
          {
            "text": "import {",
            "lineNumber": 21
          },
          {
            "text": "\tgetCanvasKey,",
            "lineNumber": 22
          },
          {
            "text": "\tgetNodeResult,",
            "lineNumber": 23
          },
          {
            "text": "\tsetNodeResult,",
            "lineNumber": 24
          },
          {
            "text": "\tsetEdgeModes,",
            "lineNumber": 25
          },
          {
            "text": "\tsetRunningNodeId,",
            "lineNumber": 26
          },
          {
            "text": "} from \"./state\";",
            "lineNumber": 27
          },
          {
            "text": "import type {NodeRole, ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "type EdgeInputMode = \"inject\" | \"concatenate\";",
            "lineNumber": 30,
            "isSignature": true
          },
          {
            "lineNumber": 31
          },
          {
            "text": "/** True if the role is non-AI (Python or pass-through); prefer running these first for early output. */",
            "lineNumber": 32
          }
        ]
      },
      "score": 0.15943044424057007
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 217
          },
          "endPosition": {
            "line": 283,
            "column": 99
          }
        },
        "contents": "async function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\n\tif (role === \"red\") {\n\t\tconst model = settings.ollamaRedModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"blue\") {\n\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);\n\t\tconst result = await kernel.run(template, concatenatedPart);\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\treturn \"\";\n}\n\n/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 218,
                "column": 1
              },
              "endPosition": {
                "line": 227,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "async function runSingleNode(",
            "lineNumber": 218,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 219,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 220,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 221,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 222,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 223,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 224,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 225,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 226,
            "isSignature": true
          },
          {
            "lineNumber": 264
          },
          {
            "text": "\tif (role === \"red\") {",
            "lineNumber": 265
          },
          {
            "text": "\t\tconst model = settings.ollamaRedModel || \"llama2\";",
            "lineNumber": 266
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 267
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 268
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 269
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 270
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 271
          },
          {
            "text": "\t}",
            "lineNumber": 272
          },
          {
            "text": "\tif (role === \"blue\") {",
            "lineNumber": 273
          },
          {
            "text": "\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);",
            "lineNumber": 274
          },
          {
            "text": "\t\tconst result = await kernel.run(template, concatenatedPart);",
            "lineNumber": 275
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 276
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 277
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 278
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 279
          },
          {
            "text": "\t}",
            "lineNumber": 280
          },
          {
            "text": "\treturn \"\";",
            "lineNumber": 281
          },
          {
            "text": "}",
            "lineNumber": 282,
            "isSignature": true
          },
          {
            "lineNumber": 283
          },
          {
            "text": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
            "lineNumber": 284
          }
        ]
      },
      "score": 0.15867559611797333
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 57,
            "column": 1
          },
          "endPosition": {
            "line": 77,
            "column": 90
          }
        },
        "contents": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y. Excludes output edges. */\nexport function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withY = edges.map((e) =&gt; {\n\t\tconst parent = nodeMap.get(e.fromNode);\n\t\tconst y = parent?.y ?? 0;\n\t\treturn {\n\t\t\tparentId: e.fromNode,\n\t\t\tedge: e,\n\t\t\tvariableName: parseEdgeVariableName(e.label),\n\t\t\ty,\n\t\t};\n\t});\n\twithY.sort((a, b) =&gt; a.y - b.y);\n\treturn withY.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));\n}\n\n/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y. Excludes output edges. */",
            "lineNumber": 60
          },
          {
            "text": "export function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {",
            "lineNumber": 61,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));",
            "lineNumber": 62
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 63
          },
          {
            "text": "\tconst withY = edges.map((e) =&gt; {",
            "lineNumber": 64
          },
          {
            "text": "\t\tconst parent = nodeMap.get(e.fromNode);",
            "lineNumber": 65
          },
          {
            "text": "\t\tconst y = parent?.y ?? 0;",
            "lineNumber": 66
          },
          {
            "text": "\t\treturn {",
            "lineNumber": 67
          },
          {
            "text": "\t\t\tparentId: e.fromNode,",
            "lineNumber": 68
          },
          {
            "text": "\t\t\tedge: e,",
            "lineNumber": 69
          },
          {
            "text": "\t\t\tvariableName: parseEdgeVariableName(e.label),",
            "lineNumber": 70
          },
          {
            "text": "\t\t\ty,",
            "lineNumber": 71
          },
          {
            "text": "\t\t};",
            "lineNumber": 72
          },
          {
            "text": "\t});",
            "lineNumber": 73
          },
          {
            "text": "\twithY.sort((a, b) =&gt; a.y - b.y);",
            "lineNumber": 74
          },
          {
            "text": "\treturn withY.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));",
            "lineNumber": 75
          },
          {
            "text": "}",
            "lineNumber": 76,
            "isSignature": true
          },
          {
            "lineNumber": 77
          },
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */",
            "lineNumber": 78
          }
        ]
      },
      "score": 0.15755939483642578
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/nodes.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 34,
            "column": 1
          }
        },
        "contents": "import type {Vault} from \"obsidian\";\nimport type {AllCanvasNodeData, CanvasData, CanvasFileData, CanvasTextData} from \"obsidian/canvas\";\nimport {\n\tgetFileNodePath,\n\tgetNodeById,\n\tgetNodeRole,\n\tgetParentIdsSortedByY,\n\tgetTextNodeContent,\n\tisFileNode,\n\tisTextNode,\n} from \"./types\";\nimport type {ZettelPluginSettings} from \"../settings\";\n\n/** Load canvas data from vault by reading the canvas file (JSON). */\nexport async function loadCanvasData(vault: Vault, filePath: string): Promise&lt;CanvasData | null&gt; {\n\ttry {\n\t\tconst raw = await vault.adapter.read(filePath);\n\t\tconst data = JSON.parse(raw) as CanvasData;\n\t\tif (data &amp;&amp; Array.isArray(data.nodes) &amp;&amp; Array.isArray(data.edges)) return data;\n\t} catch {\n\t\t// ignore\n\t}\n\treturn null;\n}\n\n/** Save canvas data to vault (writes the canvas file). */\nexport async function saveCanvasData(vault: Vault, filePath: string, data: CanvasData): Promise&lt;boolean&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {Vault} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import type {AllCanvasNodeData, CanvasData, CanvasFileData, CanvasTextData} from \"obsidian/canvas\";",
            "lineNumber": 2
          },
          {
            "text": "import {",
            "lineNumber": 3
          },
          {
            "text": "\tgetFileNodePath,",
            "lineNumber": 4
          },
          {
            "text": "\tgetNodeById,",
            "lineNumber": 5
          },
          {
            "text": "\tgetNodeRole,",
            "lineNumber": 6
          },
          {
            "text": "\tgetParentIdsSortedByY,",
            "lineNumber": 7
          },
          {
            "text": "\tgetTextNodeContent,",
            "lineNumber": 8
          },
          {
            "text": "\tisFileNode,",
            "lineNumber": 9
          },
          {
            "text": "\tisTextNode,",
            "lineNumber": 10
          },
          {
            "text": "} from \"./types\";",
            "lineNumber": 11
          },
          {
            "text": "import type {ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 12
          },
          {
            "lineNumber": 13
          },
          {
            "text": "/** Load canvas data from vault by reading the canvas file (JSON). */",
            "lineNumber": 14
          },
          {
            "text": "export async function loadCanvasData(vault: Vault, filePath: string): Promise&lt;CanvasData | null&gt; {",
            "lineNumber": 15,
            "isSignature": true
          },
          {
            "text": "\ttry {",
            "lineNumber": 16
          },
          {
            "text": "\t\tconst raw = await vault.adapter.read(filePath);",
            "lineNumber": 17
          },
          {
            "text": "\t\tconst data = JSON.parse(raw) as CanvasData;",
            "lineNumber": 18
          },
          {
            "text": "\t\tif (data &amp;&amp; Array.isArray(data.nodes) &amp;&amp; Array.isArray(data.edges)) return data;",
            "lineNumber": 19
          },
          {
            "text": "\t} catch {",
            "lineNumber": 20
          },
          {
            "text": "\t\t// ignore",
            "lineNumber": 21
          },
          {
            "text": "\t}",
            "lineNumber": 22
          },
          {
            "text": "\treturn null;",
            "lineNumber": 23
          },
          {
            "text": "}",
            "lineNumber": 24,
            "isSignature": true
          },
          {
            "lineNumber": 25
          },
          {
            "text": "/** Save canvas data to vault (writes the canvas file). */",
            "lineNumber": 26
          },
          {
            "text": "export async function saveCanvasData(vault: Vault, filePath: string, data: CanvasData): Promise&lt;boolean&gt; {",
            "lineNumber": 27,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 28
          },
          {
            "text": "}",
            "lineNumber": 35,
            "isSignature": true
          }
        ]
      },
      "score": 0.15584740042686462
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/settings.ts",
        "range": {
          "startPosition": {
            "line": 23,
            "column": 94
          },
          "endPosition": {
            "line": 55,
            "column": 1
          }
        },
        "contents": "/** Human-readable names for conflict alerts (one-to-one color mapping). */\nconst ROLE_DISPLAY_NAMES: Record&lt;NodeRole, string&gt; = {\n\torange: \"Primary model\",\n\tpurple: \"Secondary model\",\n\tred: \"Tertiary model\",\n\tblue: \"Python node\",\n\tyellow: \"Comment node\",\n\tgreen: \"Output node\",\n};\n\n/** Returns another role that already uses this color value, or null if unique. */\nfunction getOtherRoleWithColor(\n\tsettings: ZettelPluginSettings,\n\tcolorValue: string,\n\texcludeRole: NodeRole\n): NodeRole | null {\n\tif (!colorValue) return null;\n\tfor (const r of COLOR_ROLES) {\n\t\tif (r === excludeRole) continue;\n\t\tconst key = &#96;color${r.charAt(0).toUpperCase() + r.slice(1)}&#96; as keyof ZettelPluginSettings;\n\t\tif ((settings[key] as string) === colorValue) return r;\n\t}\n\treturn null;\n}\n\nfunction getModelName(role: NodeRole, settings: ZettelPluginSettings): string {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Human-readable names for conflict alerts (one-to-one color mapping). */",
            "lineNumber": 26
          },
          {
            "text": "const ROLE_DISPLAY_NAMES: Record&lt;NodeRole, string&gt; = {",
            "lineNumber": 27
          },
          {
            "text": "\torange: \"Primary model\",",
            "lineNumber": 28
          },
          {
            "text": "\tpurple: \"Secondary model\",",
            "lineNumber": 29
          },
          {
            "text": "\tred: \"Tertiary model\",",
            "lineNumber": 30
          },
          {
            "text": "\tblue: \"Python node\",",
            "lineNumber": 31
          },
          {
            "text": "\tyellow: \"Comment node\",",
            "lineNumber": 32
          },
          {
            "text": "\tgreen: \"Output node\",",
            "lineNumber": 33
          },
          {
            "text": "};",
            "lineNumber": 34
          },
          {
            "lineNumber": 35
          },
          {
            "text": "/** Returns another role that already uses this color value, or null if unique. */",
            "lineNumber": 36
          },
          {
            "text": "function getOtherRoleWithColor(",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 38,
            "isSignature": true
          },
          {
            "text": "\tcolorValue: string,",
            "lineNumber": 39,
            "isSignature": true
          },
          {
            "text": "\texcludeRole: NodeRole",
            "lineNumber": 40,
            "isSignature": true
          },
          {
            "text": "): NodeRole | null {",
            "lineNumber": 41,
            "isSignature": true
          },
          {
            "text": "\tif (!colorValue) return null;",
            "lineNumber": 42
          },
          {
            "text": "\tfor (const r of COLOR_ROLES) {",
            "lineNumber": 43
          },
          {
            "text": "\t\tif (r === excludeRole) continue;",
            "lineNumber": 44
          },
          {
            "text": "\t\tconst key = &#96;color${r.charAt(0).toUpperCase() + r.slice(1)}&#96; as keyof ZettelPluginSettings;",
            "lineNumber": 45
          },
          {
            "text": "\t\tif ((settings[key] as string) === colorValue) return r;",
            "lineNumber": 46
          },
          {
            "text": "\t}",
            "lineNumber": 47
          },
          {
            "text": "\treturn null;",
            "lineNumber": 48
          },
          {
            "text": "}",
            "lineNumber": 49,
            "isSignature": true
          },
          {
            "lineNumber": 50
          },
          {
            "text": "function getModelName(role: NodeRole, settings: ZettelPluginSettings): string {",
            "lineNumber": 51,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 52
          },
          {
            "text": "}",
            "lineNumber": 56,
            "isSignature": true
          }
        ]
      },
      "score": 0.15088309347629547
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 228
          },
          "endPosition": {
            "line": 329,
            "column": 1
          }
        },
        "contents": "export async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\n\tfor (const edge of data.edges) {\n\t\tif (isOutputEdge(edge)) continue;\n\t\tconst isRunning = runningNodeId != null &amp;&amp; edge.toNode === runningNodeId;\n\t\tconst mode = getEdgeMode(canvasKey, edge.id);\n\t\tconst state: EdgeDisplayState | null = isRunning\n\t\t\t? \"running\"\n\t\t\t: mode === \"inject\"\n\t\t\t\t? \"inject\"\n\t\t\t\t: mode === \"concatenate\"\n\t\t\t\t\t? \"concatenate\"\n\t\t\t\t\t: null;\n\t\tif (!state) continue;\n\t\tconst fromEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);\n\t\tconst toEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);\n\t\tif (!fromEl || !toEl) continue;\n\t\tconst fromCenter = getElCenter(fromEl);\n\t\tconst toCenter = getElCenter(toEl);\n\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;\n\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;\n\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);\n\t\tif (!pathEl) continue;\n\t\tconst group = pathEl.closest(\"g\");\n\t\tif (!group) continue;\n\t\tconst mid = getPathMidpointSvg(pathEl);\n\t\tconst labelGroup = document.createElementNS(SVG_NS, \"g\");\n\t\tlabelGroup.setAttribute(\"class\", EDGE_MODE_SVG_LABEL_CLASS);\n\t\tlabelGroup.setAttribute(EDGE_MODE_DATA_ATTR, edge.id);\n\t\tlabelGroup.setAttribute(EDGE_MODE_STATE_ATTR, state);\n\t\tlabelGroup.setAttribute(\"transform\", &#96;translate(${mid.x}, ${mid.y + Y_OFFSET_BELOW_PATH})&#96;);\n\t\tlabelGroup.setAttribute(\"style\", \"z-index: 100; isolation: isolate;\");\n\t\tconst textContent =\n\t\t\tstate === \"running\" ? \"\" : state === \"inject\" ? \"(injected)\" : \"(concatenated)\";\n\t\tlet textX = 0;\n\t\tconst fontSize = state === \"running\" ? FONT_SIZE_RUNNING : FONT_SIZE;\n\t\tif (state === \"running\") {\n\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 229,
                "column": 1
              },
              "endPosition": {
                "line": 229,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 229,
                "column": 8
              },
              "endPosition": {
                "line": 236,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 235,
            "isSignature": true
          },
          {
            "lineNumber": 252
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 253
          },
          {
            "text": "\t\tif (isOutputEdge(edge)) continue;",
            "lineNumber": 254
          },
          {
            "text": "\t\tconst isRunning = runningNodeId != null &amp;&amp; edge.toNode === runningNodeId;",
            "lineNumber": 255
          },
          {
            "text": "\t\tconst mode = getEdgeMode(canvasKey, edge.id);",
            "lineNumber": 256
          },
          {
            "text": "\t\tconst state: EdgeDisplayState | null = isRunning",
            "lineNumber": 257
          },
          {
            "text": "\t\t\t? \"running\"",
            "lineNumber": 258
          },
          {
            "text": "\t\t\t: mode === \"inject\"",
            "lineNumber": 259
          },
          {
            "text": "\t\t\t\t? \"inject\"",
            "lineNumber": 260
          },
          {
            "text": "\t\t\t\t: mode === \"concatenate\"",
            "lineNumber": 261
          },
          {
            "text": "\t\t\t\t\t? \"concatenate\"",
            "lineNumber": 262
          },
          {
            "text": "\t\t\t\t\t: null;",
            "lineNumber": 263
          },
          {
            "text": "\t\tif (!state) continue;",
            "lineNumber": 264
          },
          {
            "text": "\t\tconst fromEl =",
            "lineNumber": 265
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||",
            "lineNumber": 266
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);",
            "lineNumber": 267
          },
          {
            "text": "\t\tconst toEl =",
            "lineNumber": 268
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||",
            "lineNumber": 269
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);",
            "lineNumber": 270
          },
          {
            "text": "\t\tif (!fromEl || !toEl) continue;",
            "lineNumber": 271
          },
          {
            "text": "\t\tconst fromCenter = getElCenter(fromEl);",
            "lineNumber": 272
          },
          {
            "text": "\t\tconst toCenter = getElCenter(toEl);",
            "lineNumber": 273
          },
          {
            "text": "\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;",
            "lineNumber": 274
          },
          {
            "text": "\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;",
            "lineNumber": 275
          },
          {
            "text": "\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);",
            "lineNumber": 276
          },
          {
            "text": "\t\tif (!pathEl) continue;",
            "lineNumber": 277
          },
          {
            "text": "\t\tconst group = pathEl.closest(\"g\");",
            "lineNumber": 278
          },
          {
            "text": "\t\tif (!group) continue;",
            "lineNumber": 279
          },
          {
            "text": "\t\tconst mid = getPathMidpointSvg(pathEl);",
            "lineNumber": 280
          },
          {
            "text": "\t\tconst labelGroup = document.createElementNS(SVG_NS, \"g\");",
            "lineNumber": 281
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"class\", EDGE_MODE_SVG_LABEL_CLASS);",
            "lineNumber": 282
          },
          {
            "text": "\t\tlabelGroup.setAttribute(EDGE_MODE_DATA_ATTR, edge.id);",
            "lineNumber": 283
          },
          {
            "text": "\t\tlabelGroup.setAttribute(EDGE_MODE_STATE_ATTR, state);",
            "lineNumber": 284
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"transform\", &#96;translate(${mid.x}, ${mid.y + Y_OFFSET_BELOW_PATH})&#96;);",
            "lineNumber": 285
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"style\", \"z-index: 100; isolation: isolate;\");",
            "lineNumber": 286
          },
          {
            "text": "\t\tconst textContent =",
            "lineNumber": 287
          },
          {
            "text": "\t\t\tstate === \"running\" ? \"\" : state === \"inject\" ? \"(injected)\" : \"(concatenated)\";",
            "lineNumber": 288
          },
          {
            "text": "\t\tlet textX = 0;",
            "lineNumber": 289
          },
          {
            "text": "\t\tconst fontSize = state === \"running\" ? FONT_SIZE_RUNNING : FONT_SIZE;",
            "lineNumber": 290
          },
          {
            "text": "\t\tif (state === \"running\") {",
            "lineNumber": 291
          },
          {
            "text": "\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");",
            "lineNumber": 292
          },
          {
            "text": "}",
            "lineNumber": 330,
            "isSignature": true
          }
        ]
      },
      "score": 0.15001875162124634
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 307
          },
          "endPosition": {
            "line": 350,
            "column": 1
          }
        },
        "contents": "function chooseOutputPositionXY(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\toutNodeId: string | null,\n\tdefaultX: number,\n\tdefaultY: number,\n\twidth: number,\n\theight: number\n): { x: number; y: number } {\n\n\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {\n\t\tconst candidateY = defaultY + dy;\n\t\tfor (const dx of xOffsets()) {\n\t\t\tif (tryPosition(defaultX + dx, candidateY)) return { x: defaultX + dx, y: candidateY };\n\t\t}\n\t}\n\treturn { x: defaultX, y: defaultY };\n}\n\nfunction* xOffsets(): Generator&lt;number&gt; {\n\tyield 0;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function chooseOutputPositionXY(",
            "lineNumber": 308,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 309,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 310,
            "isSignature": true
          },
          {
            "text": "\toutNodeId: string | null,",
            "lineNumber": 311,
            "isSignature": true
          },
          {
            "text": "\tdefaultX: number,",
            "lineNumber": 312,
            "isSignature": true
          },
          {
            "text": "\tdefaultY: number,",
            "lineNumber": 313,
            "isSignature": true
          },
          {
            "text": "\twidth: number,",
            "lineNumber": 314,
            "isSignature": true
          },
          {
            "text": "\theight: number",
            "lineNumber": 315,
            "isSignature": true
          },
          {
            "text": "): { x: number; y: number } {",
            "lineNumber": 316,
            "isSignature": true
          },
          {
            "lineNumber": 335
          },
          {
            "text": "\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {",
            "lineNumber": 336
          },
          {
            "text": "\t\tconst candidateY = defaultY + dy;",
            "lineNumber": 337
          },
          {
            "text": "\t\tfor (const dx of xOffsets()) {",
            "lineNumber": 338
          },
          {
            "text": "\t\t\tif (tryPosition(defaultX + dx, candidateY)) return { x: defaultX + dx, y: candidateY };",
            "lineNumber": 339
          },
          {
            "text": "\t\t}",
            "lineNumber": 340
          },
          {
            "text": "\t}",
            "lineNumber": 341
          },
          {
            "text": "\treturn { x: defaultX, y: defaultY };",
            "lineNumber": 342
          },
          {
            "text": "}",
            "lineNumber": 343,
            "isSignature": true
          },
          {
            "lineNumber": 344
          },
          {
            "text": "function* xOffsets(): Generator&lt;number&gt; {",
            "lineNumber": 345,
            "isSignature": true
          },
          {
            "text": "\tyield 0;",
            "lineNumber": 346
          },
          {
            "text": "}",
            "lineNumber": 351,
            "isSignature": true
          }
        ]
      },
      "score": 0.14539456367492676
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 146,
            "column": 1
          },
          "endPosition": {
            "line": 186,
            "column": 107
          }
        },
        "contents": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */\nfunction buildInputWithVariables(\n\tcanvasKey: string,\n\tnodeInput: string,\n\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[]\n): { concatenatedPart: string; template: string; edgeModes: Map&lt;string, EdgeInputMode&gt; } {\n\tconst edgeModes = new Map&lt;string, EdgeInputMode&gt;();\n\tconst parentResults = new Map&lt;string, string&gt;();\n\tfor (const { parentId } of incoming) {\n\t\tconst r = getNodeResult(canvasKey, parentId);\n\t\tif (r != null) parentResults.set(parentId, r);\n\t}\n\tlet concatenatedPart = \"\";\n\tconst varValues: Record&lt;string, string&gt; = {};\n\tfor (const { parentId, edge, variableName } of incoming) {\n\t\tconst result = parentResults.get(parentId);\n\t\tif (result == null) continue;\n\t\tconst usedAsVar =\n\t\t\tvariableName.length &gt; 0 &amp;&amp; nodeInput.includes(&#96;{{var:${variableName}}}&#96;);\n\t\tif (usedAsVar) {\n\t\t\tedgeModes.set(edge.id, \"inject\");\n\t\t\tvarValues[variableName] = result;\n\t\t} else {\n\t\t\tedgeModes.set(edge.id, \"concatenate\");\n\t\t\tconcatenatedPart += result + \"\\n\\n\";\n\t\t}\n\t}\n\tlet template = nodeInput;\n\tfor (const [name, value] of Object.entries(varValues)) {\n\t\ttemplate = template.split(&#96;{{var:${name}}}&#96;).join(value);\n\t}\n\treturn {\n\t\tconcatenatedPart: concatenatedPart.trim(),\n\t\ttemplate,\n\t\tedgeModes,\n\t};\n}\n\n/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
            "lineNumber": 149
          },
          {
            "text": "function buildInputWithVariables(",
            "lineNumber": 150,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 151,
            "isSignature": true
          },
          {
            "text": "\tnodeInput: string,",
            "lineNumber": 152,
            "isSignature": true
          },
          {
            "text": "\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[]",
            "lineNumber": 153,
            "isSignature": true
          },
          {
            "text": "): { concatenatedPart: string; template: string; edgeModes: Map&lt;string, EdgeInputMode&gt; } {",
            "lineNumber": 154,
            "isSignature": true
          },
          {
            "text": "\tconst edgeModes = new Map&lt;string, EdgeInputMode&gt;();",
            "lineNumber": 155
          },
          {
            "text": "\tconst parentResults = new Map&lt;string, string&gt;();",
            "lineNumber": 156
          },
          {
            "text": "\tfor (const { parentId } of incoming) {",
            "lineNumber": 157
          },
          {
            "text": "\t\tconst r = getNodeResult(canvasKey, parentId);",
            "lineNumber": 158
          },
          {
            "text": "\t\tif (r != null) parentResults.set(parentId, r);",
            "lineNumber": 159
          },
          {
            "text": "\t}",
            "lineNumber": 160
          },
          {
            "text": "\tlet concatenatedPart = \"\";",
            "lineNumber": 161
          },
          {
            "text": "\tconst varValues: Record&lt;string, string&gt; = {};",
            "lineNumber": 162
          },
          {
            "text": "\tfor (const { parentId, edge, variableName } of incoming) {",
            "lineNumber": 163
          },
          {
            "text": "\t\tconst result = parentResults.get(parentId);",
            "lineNumber": 164
          },
          {
            "text": "\t\tif (result == null) continue;",
            "lineNumber": 165
          },
          {
            "text": "\t\tconst usedAsVar =",
            "lineNumber": 166
          },
          {
            "text": "\t\t\tvariableName.length &gt; 0 &amp;&amp; nodeInput.includes(&#96;{{var:${variableName}}}&#96;);",
            "lineNumber": 167
          },
          {
            "text": "\t\tif (usedAsVar) {",
            "lineNumber": 168
          },
          {
            "text": "\t\t\tedgeModes.set(edge.id, \"inject\");",
            "lineNumber": 169
          },
          {
            "text": "\t\t\tvarValues[variableName] = result;",
            "lineNumber": 170
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 171
          },
          {
            "text": "\t\t\tedgeModes.set(edge.id, \"concatenate\");",
            "lineNumber": 172
          },
          {
            "text": "\t\t\tconcatenatedPart += result + \"\\n\\n\";",
            "lineNumber": 173
          },
          {
            "text": "\t\t}",
            "lineNumber": 174
          },
          {
            "text": "\t}",
            "lineNumber": 175
          },
          {
            "text": "\tlet template = nodeInput;",
            "lineNumber": 176
          },
          {
            "text": "\tfor (const [name, value] of Object.entries(varValues)) {",
            "lineNumber": 177
          },
          {
            "text": "\t\ttemplate = template.split(&#96;{{var:${name}}}&#96;).join(value);",
            "lineNumber": 178
          },
          {
            "text": "\t}",
            "lineNumber": 179
          },
          {
            "text": "\treturn {",
            "lineNumber": 180
          },
          {
            "text": "\t\tconcatenatedPart: concatenatedPart.trim(),",
            "lineNumber": 181
          },
          {
            "text": "\t\ttemplate,",
            "lineNumber": 182
          },
          {
            "text": "\t\tedgeModes,",
            "lineNumber": 183
          },
          {
            "text": "\t};",
            "lineNumber": 184
          },
          {
            "text": "}",
            "lineNumber": 185,
            "isSignature": true
          },
          {
            "lineNumber": 186
          },
          {
            "text": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
            "lineNumber": 187
          }
        ]
      },
      "score": 0.14156663417816162
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 201,
            "column": 1
          },
          "endPosition": {
            "line": 227,
            "column": 3
          }
        },
        "contents": "/** Find the path whose midpoint is closest to the given viewport point (identifies the arrow for this edge). */\nfunction findPathForEdge(containerEl: HTMLElement, targetViewportX: number, targetViewportY: number): SVGPathElement | null {\n\tconst pathEls = Array.from(containerEl.querySelectorAll(\"path.canvas-display-path\"));\n\tlet best: SVGPathElement | null = null;\n\tlet bestDist = Infinity;\n\tfor (const p of pathEls) {\n\t\tif (!(p instanceof SVGPathElement)) continue;\n\t\tconst mid = getPathMidpointViewport(p);\n\t\tconst dx = mid.x - targetViewportX;\n\t\tconst dy = mid.y - targetViewportY;\n\t\tconst d = dx * dx + dy * dy;\n\t\tif (d &lt; bestDist) {\n\t\t\tbestDist = d;\n\t\t\tbest = p;\n\t\t}\n\t}\n\treturn best;\n}\n\n/**\n * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,\n * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG\n * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Find the path whose midpoint is closest to the given viewport point (identifies the arrow for this edge). */",
            "lineNumber": 204
          },
          {
            "text": "function findPathForEdge(containerEl: HTMLElement, targetViewportX: number, targetViewportY: number): SVGPathElement | null {",
            "lineNumber": 205,
            "isSignature": true
          },
          {
            "text": "\tconst pathEls = Array.from(containerEl.querySelectorAll(\"path.canvas-display-path\"));",
            "lineNumber": 206
          },
          {
            "text": "\tlet best: SVGPathElement | null = null;",
            "lineNumber": 207
          },
          {
            "text": "\tlet bestDist = Infinity;",
            "lineNumber": 208
          },
          {
            "text": "\tfor (const p of pathEls) {",
            "lineNumber": 209
          },
          {
            "text": "\t\tif (!(p instanceof SVGPathElement)) continue;",
            "lineNumber": 210
          },
          {
            "text": "\t\tconst mid = getPathMidpointViewport(p);",
            "lineNumber": 211
          },
          {
            "text": "\t\tconst dx = mid.x - targetViewportX;",
            "lineNumber": 212
          },
          {
            "text": "\t\tconst dy = mid.y - targetViewportY;",
            "lineNumber": 213
          },
          {
            "text": "\t\tconst d = dx * dx + dy * dy;",
            "lineNumber": 214
          },
          {
            "text": "\t\tif (d &lt; bestDist) {",
            "lineNumber": 215
          },
          {
            "text": "\t\t\tbestDist = d;",
            "lineNumber": 216
          },
          {
            "text": "\t\t\tbest = p;",
            "lineNumber": 217
          },
          {
            "text": "\t\t}",
            "lineNumber": 218
          },
          {
            "text": "\t}",
            "lineNumber": 219
          },
          {
            "text": "\treturn best;",
            "lineNumber": 220
          },
          {
            "text": "}",
            "lineNumber": 221,
            "isSignature": true
          },
          {
            "lineNumber": 222
          },
          {
            "text": "/**",
            "lineNumber": 223
          },
          {
            "text": " * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,",
            "lineNumber": 224
          },
          {
            "text": " * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG",
            "lineNumber": 225
          },
          {
            "text": " * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.",
            "lineNumber": 226
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 227
          },
          {
            "text": " */",
            "lineNumber": 228
          }
        ]
      },
      "score": 0.14109063148498535
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 28,
            "column": 1
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */\nlet debugNodeMenuFired = false;\n\nexport default class ZettelThinkingBoardPlugin extends Plugin {\n\tsettings: ZettelPluginSettings;\n\n\tasync onload() {\n\t\ttry {\n\t\t\tawait this.loadSettings();\n\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));\n\n\t\t\tthis.registerView(\n\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,\n\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)\n\t\t\t);\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"open-zettel-controls\",\n\t\t\t\tname: \"Open Zettel Controls\",\n\t\t\t\tcallback: () =&gt; this.activateZettelControls(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-node\",\n\t\t\t\tname: \"Run node\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-chain\",\n\t\t\t\tname: \"Run chain\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"dismiss-output\",\n\t\t\t\tname: \"Dismiss output\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 31
          },
          {
            "text": "let debugNodeMenuFired = false;",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings;",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "\tasync onload() {",
            "lineNumber": 37
          },
          {
            "text": "\t\ttry {",
            "lineNumber": 38
          },
          {
            "text": "\t\t\tawait this.loadSettings();",
            "lineNumber": 39
          },
          {
            "text": "\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));",
            "lineNumber": 40
          },
          {
            "lineNumber": 41
          },
          {
            "text": "\t\t\tthis.registerView(",
            "lineNumber": 42
          },
          {
            "text": "\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,",
            "lineNumber": 43
          },
          {
            "text": "\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)",
            "lineNumber": 44
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 47
          },
          {
            "text": "\t\t\t\tid: \"open-zettel-controls\",",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\tname: \"Open Zettel Controls\",",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.activateZettelControls(),",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 51
          },
          {
            "lineNumber": 52
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 53
          },
          {
            "text": "\t\t\t\tid: \"run-node\",",
            "lineNumber": 54
          },
          {
            "text": "\t\t\t\tname: \"Run node\",",
            "lineNumber": 55
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 56
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 57
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 58
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 59
          },
          {
            "text": "\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu",
            "lineNumber": 60
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");",
            "lineNumber": 61
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 62
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 63
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 64
          },
          {
            "lineNumber": 65
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 66
          },
          {
            "text": "\t\t\t\tid: \"run-chain\",",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t\tname: \"Run chain\",",
            "lineNumber": 68
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 69
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 70
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 71
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 72
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");",
            "lineNumber": 73
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 74
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 75
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 76
          },
          {
            "lineNumber": 77
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 78
          },
          {
            "text": "\t\t\t\tid: \"dismiss-output\",",
            "lineNumber": 79
          },
          {
            "text": "\t\t\t\tname: \"Dismiss output\",",
            "lineNumber": 80
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 81
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 82
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 83
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 84
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");",
            "lineNumber": 85
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 86
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 87
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 90
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.13964000344276428
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Which nodes to resolve in the graph or execution order?",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 97,
            "column": 1
          },
          "endPosition": {
            "line": 130,
            "column": 83
          }
        },
        "contents": "function topologicalSort(\n\tdata: CanvasData,\n\texecEdges: CanvasEdgeData[],\n\tnodeIds: Set&lt;string&gt;,\n\tsettings: ZettelPluginSettings\n): string[] {\n\tconst inDegree = new Map&lt;string, number&gt;();\n\tfor (const id of nodeIds) inDegree.set(id, 0);\n\tfor (const e of execEdges) {\n\t\tif (nodeIds.has(e.fromNode) &amp;&amp; nodeIds.has(e.toNode)) {\n\t\t\tinDegree.set(e.toNode, (inDegree.get(e.toNode) ?? 0) + 1);\n\t\t}\n\t}\n\tconst order: string[] = [];\n\tconst queue = [...nodeIds].filter((id) =&gt; inDegree.get(id) === 0);\n\tsortQueueByNonAIFirst(queue, data, settings);\n\twhile (queue.length &gt; 0) {\n\t\tconst id = queue.shift()!;\n\t\torder.push(id);\n\t\tfor (const e of execEdges) {\n\t\t\tif (e.fromNode === id &amp;&amp; nodeIds.has(e.toNode)) {\n\t\t\t\tconst d = (inDegree.get(e.toNode) ?? 0) - 1;\n\t\t\t\tinDegree.set(e.toNode, d);\n\t\t\t\tif (d === 0) queue.push(e.toNode);\n\t\t\t}\n\t\t}\n\t\tsortQueueByNonAIFirst(queue, data, settings);\n\t}\n\treturn order;\n}\n\n/** Sort ready queue: non-AI (Python, yellow) first for early output, then by y. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function topologicalSort(",
            "lineNumber": 100,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 101,
            "isSignature": true
          },
          {
            "text": "\texecEdges: CanvasEdgeData[],",
            "lineNumber": 102,
            "isSignature": true
          },
          {
            "text": "\tnodeIds: Set&lt;string&gt;,",
            "lineNumber": 103,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 104,
            "isSignature": true
          },
          {
            "text": "): string[] {",
            "lineNumber": 105,
            "isSignature": true
          },
          {
            "text": "\tconst inDegree = new Map&lt;string, number&gt;();",
            "lineNumber": 106
          },
          {
            "text": "\tfor (const id of nodeIds) inDegree.set(id, 0);",
            "lineNumber": 107
          },
          {
            "text": "\tfor (const e of execEdges) {",
            "lineNumber": 108
          },
          {
            "text": "\t\tif (nodeIds.has(e.fromNode) &amp;&amp; nodeIds.has(e.toNode)) {",
            "lineNumber": 109
          },
          {
            "text": "\t\t\tinDegree.set(e.toNode, (inDegree.get(e.toNode) ?? 0) + 1);",
            "lineNumber": 110
          },
          {
            "text": "\t\t}",
            "lineNumber": 111
          },
          {
            "text": "\t}",
            "lineNumber": 112
          },
          {
            "text": "\tconst order: string[] = [];",
            "lineNumber": 113
          },
          {
            "text": "\tconst queue = [...nodeIds].filter((id) =&gt; inDegree.get(id) === 0);",
            "lineNumber": 114
          },
          {
            "text": "\tsortQueueByNonAIFirst(queue, data, settings);",
            "lineNumber": 115
          },
          {
            "text": "\twhile (queue.length &gt; 0) {",
            "lineNumber": 116
          },
          {
            "text": "\t\tconst id = queue.shift()!;",
            "lineNumber": 117
          },
          {
            "text": "\t\torder.push(id);",
            "lineNumber": 118
          },
          {
            "text": "\t\tfor (const e of execEdges) {",
            "lineNumber": 119
          },
          {
            "text": "\t\t\tif (e.fromNode === id &amp;&amp; nodeIds.has(e.toNode)) {",
            "lineNumber": 120
          },
          {
            "text": "\t\t\t\tconst d = (inDegree.get(e.toNode) ?? 0) - 1;",
            "lineNumber": 121
          },
          {
            "text": "\t\t\t\tinDegree.set(e.toNode, d);",
            "lineNumber": 122
          },
          {
            "text": "\t\t\t\tif (d === 0) queue.push(e.toNode);",
            "lineNumber": 123
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 124
          },
          {
            "text": "\t\t}",
            "lineNumber": 125
          },
          {
            "text": "\t\tsortQueueByNonAIFirst(queue, data, settings);",
            "lineNumber": 126
          },
          {
            "text": "\t}",
            "lineNumber": 127
          },
          {
            "text": "\treturn order;",
            "lineNumber": 128
          },
          {
            "text": "}",
            "lineNumber": 129,
            "isSignature": true
          },
          {
            "lineNumber": 130
          },
          {
            "text": "/** Sort ready queue: non-AI (Python, yellow) first for early output, then by y. */",
            "lineNumber": 131
          }
        ]
      },
      "score": 0.468699187040329
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 78,
            "column": 1
          },
          "endPosition": {
            "line": 128,
            "column": 1
          }
        },
        "contents": "/** Topological order of all nodes reachable from any root (ignores output edges). */\nfunction topologicalOrderFull(data: CanvasData, settings: ZettelPluginSettings): string[] {\n\tconst roots = getRootIds(data);\n\tconst execEdges = data.edges.filter((e) =&gt; !isOutputEdge(e));\n\tconst nodeIds = new Set&lt;string&gt;();\n\tfor (const rootId of roots) {\n\t\tconst stack = [rootId];\n\t\twhile (stack.length &gt; 0) {\n\t\t\tconst id = stack.pop()!;\n\t\t\tif (nodeIds.has(id)) continue;\n\t\t\tnodeIds.add(id);\n\t\t\tfor (const e of execEdges) {\n\t\t\t\tif (e.fromNode === id) stack.push(e.toNode);\n\t\t\t}\n\t\t}\n\t}\n\treturn topologicalSort(data, execEdges, nodeIds, settings);\n}\n\nfunction topologicalSort(\n\tdata: CanvasData,\n\texecEdges: CanvasEdgeData[],\n\tnodeIds: Set&lt;string&gt;,\n\tsettings: ZettelPluginSettings\n): string[] {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Topological order of all nodes reachable from any root (ignores output edges). */",
            "lineNumber": 81
          },
          {
            "text": "function topologicalOrderFull(data: CanvasData, settings: ZettelPluginSettings): string[] {",
            "lineNumber": 82,
            "isSignature": true
          },
          {
            "text": "\tconst roots = getRootIds(data);",
            "lineNumber": 83
          },
          {
            "text": "\tconst execEdges = data.edges.filter((e) =&gt; !isOutputEdge(e));",
            "lineNumber": 84
          },
          {
            "text": "\tconst nodeIds = new Set&lt;string&gt;();",
            "lineNumber": 85
          },
          {
            "text": "\tfor (const rootId of roots) {",
            "lineNumber": 86
          },
          {
            "text": "\t\tconst stack = [rootId];",
            "lineNumber": 87
          },
          {
            "text": "\t\twhile (stack.length &gt; 0) {",
            "lineNumber": 88
          },
          {
            "text": "\t\t\tconst id = stack.pop()!;",
            "lineNumber": 89
          },
          {
            "text": "\t\t\tif (nodeIds.has(id)) continue;",
            "lineNumber": 90
          },
          {
            "text": "\t\t\tnodeIds.add(id);",
            "lineNumber": 91
          },
          {
            "text": "\t\t\tfor (const e of execEdges) {",
            "lineNumber": 92
          },
          {
            "text": "\t\t\t\tif (e.fromNode === id) stack.push(e.toNode);",
            "lineNumber": 93
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 94
          },
          {
            "text": "\t\t}",
            "lineNumber": 95
          },
          {
            "text": "\t}",
            "lineNumber": 96
          },
          {
            "text": "\treturn topologicalSort(data, execEdges, nodeIds, settings);",
            "lineNumber": 97
          },
          {
            "text": "}",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "lineNumber": 99
          },
          {
            "text": "function topologicalSort(",
            "lineNumber": 100,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 101,
            "isSignature": true
          },
          {
            "text": "\texecEdges: CanvasEdgeData[],",
            "lineNumber": 102,
            "isSignature": true
          },
          {
            "text": "\tnodeIds: Set&lt;string&gt;,",
            "lineNumber": 103,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 104,
            "isSignature": true
          },
          {
            "text": "): string[] {",
            "lineNumber": 105,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 106
          },
          {
            "text": "}",
            "lineNumber": 129,
            "isSignature": true
          }
        ]
      },
      "score": 0.45082589983940125
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 468
          },
          "endPosition": {
            "line": 521,
            "column": 1
          }
        },
        "contents": "export async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n;\n\t\t\t} finally {\n\t\t\t\tsetRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t}\n}\n\n/** Run chain from roots to the given node. */\nexport async function runChain(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst roots = getRootIds(data);\n\tconst rootsReachingCurrent = roots.filter((r) =&gt; canReach(data, r, nodeId));\n\tif (rootsReachingCurrent.length === 0) return { ok: false, message: \"No root reaches this node.\" };\n\tconst order = topologicalOrderToTarget(data, nodeId, settings);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\ttry {\n\t\tfor (const nid of order) {\n\t\t\ttry {\n\t\t\t\tsetRunningNodeId(canvasKey, nid);\n\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);\n\t\t\t} finally {\n\t\t\t\tsetRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 469,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 470,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 471,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 472,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 473,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 474,
            "isSignature": true
          },
          {
            "text": ";",
            "lineNumber": 483
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 484
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 485
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 486
          },
          {
            "text": "\t\t}",
            "lineNumber": 487
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 488
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 489
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 490
          },
          {
            "text": "\t}",
            "lineNumber": 491
          },
          {
            "text": "}",
            "lineNumber": 492,
            "isSignature": true
          },
          {
            "lineNumber": 493
          },
          {
            "text": "/** Run chain from roots to the given node. */",
            "lineNumber": 494
          },
          {
            "text": "export async function runChain(",
            "lineNumber": 495,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 496,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 497,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 498,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 499,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 500,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 501,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 502
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 503
          },
          {
            "text": "\tconst roots = getRootIds(data);",
            "lineNumber": 504
          },
          {
            "text": "\tconst rootsReachingCurrent = roots.filter((r) =&gt; canReach(data, r, nodeId));",
            "lineNumber": 505
          },
          {
            "text": "\tif (rootsReachingCurrent.length === 0) return { ok: false, message: \"No root reaches this node.\" };",
            "lineNumber": 506
          },
          {
            "text": "\tconst order = topologicalOrderToTarget(data, nodeId, settings);",
            "lineNumber": 507
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 508
          },
          {
            "text": "\ttry {",
            "lineNumber": 509
          },
          {
            "text": "\t\tfor (const nid of order) {",
            "lineNumber": 510
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 511
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, nid);",
            "lineNumber": 512
          },
          {
            "text": "\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);",
            "lineNumber": 513
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 514
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 515
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 516
          },
          {
            "text": "\t\t}",
            "lineNumber": 517
          },
          {
            "text": "}",
            "lineNumber": 522,
            "isSignature": true
          }
        ]
      },
      "score": 0.4314958453178406
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 58,
            "column": 1
          },
          "endPosition": {
            "line": 80,
            "column": 85
          }
        },
        "contents": "/** Topological order of node ids (only nodes that are ancestors of target; ignores output edges). */\nfunction topologicalOrderToTarget(\n\tdata: CanvasData,\n\ttargetId: string,\n\tsettings: ZettelPluginSettings\n): string[] {\n\tconst execEdges = data.edges.filter((e) =&gt; !isOutputEdge(e));\n\tconst nodeIds = new Set&lt;string&gt;();\n\tconst stack = [targetId];\n\twhile (stack.length &gt; 0) {\n\t\tconst id = stack.pop()!;\n\t\tif (nodeIds.has(id)) continue;\n\t\tnodeIds.add(id);\n\t\tfor (const e of execEdges) {\n\t\t\tif (e.toNode === id) stack.push(e.fromNode);\n\t\t}\n\t}\n\treturn topologicalSort(data, execEdges, nodeIds, settings);\n}\n\n/** Topological order of all nodes reachable from any root (ignores output edges). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Topological order of node ids (only nodes that are ancestors of target; ignores output edges). */",
            "lineNumber": 61
          },
          {
            "text": "function topologicalOrderToTarget(",
            "lineNumber": 62,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 63,
            "isSignature": true
          },
          {
            "text": "\ttargetId: string,",
            "lineNumber": 64,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 65,
            "isSignature": true
          },
          {
            "text": "): string[] {",
            "lineNumber": 66,
            "isSignature": true
          },
          {
            "text": "\tconst execEdges = data.edges.filter((e) =&gt; !isOutputEdge(e));",
            "lineNumber": 67
          },
          {
            "text": "\tconst nodeIds = new Set&lt;string&gt;();",
            "lineNumber": 68
          },
          {
            "text": "\tconst stack = [targetId];",
            "lineNumber": 69
          },
          {
            "text": "\twhile (stack.length &gt; 0) {",
            "lineNumber": 70
          },
          {
            "text": "\t\tconst id = stack.pop()!;",
            "lineNumber": 71
          },
          {
            "text": "\t\tif (nodeIds.has(id)) continue;",
            "lineNumber": 72
          },
          {
            "text": "\t\tnodeIds.add(id);",
            "lineNumber": 73
          },
          {
            "text": "\t\tfor (const e of execEdges) {",
            "lineNumber": 74
          },
          {
            "text": "\t\t\tif (e.toNode === id) stack.push(e.fromNode);",
            "lineNumber": 75
          },
          {
            "text": "\t\t}",
            "lineNumber": 76
          },
          {
            "text": "\t}",
            "lineNumber": 77
          },
          {
            "text": "\treturn topologicalSort(data, execEdges, nodeIds, settings);",
            "lineNumber": 78
          },
          {
            "text": "}",
            "lineNumber": 79,
            "isSignature": true
          },
          {
            "lineNumber": 80
          },
          {
            "text": "/** Topological order of all nodes reachable from any root (ignores output edges). */",
            "lineNumber": 81
          }
        ]
      },
      "score": 0.4233488142490387
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 435
          },
          "endPosition": {
            "line": 491,
            "column": 1
          }
        },
        "contents": "export async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n liveCanvas);\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t} finally {\n\t\tsetRunningNodeId(canvasKey, null);\n\t}\n}\n\n/** Run all nodes reachable from any root, in topological order. */\nexport async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst order = topologicalOrderFull(data, settings);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\ttry {\n\t\tfor (const nid of order) {\n\t\t\ttry {\n\t\t\t\tsetRunningNodeId(canvasKey, nid);\n\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);\n\t\t\t} finally {\n\t\t\t\tsetRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export async function runNode(",
            "lineNumber": 436,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 437,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 438,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 439,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 440,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 441,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 442,
            "isSignature": true
          },
          {
            "text": " liveCanvas);",
            "lineNumber": 459
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 460
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 461
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 462
          },
          {
            "text": "\t} finally {",
            "lineNumber": 463
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 464
          },
          {
            "text": "\t}",
            "lineNumber": 465
          },
          {
            "text": "}",
            "lineNumber": 466,
            "isSignature": true
          },
          {
            "lineNumber": 467
          },
          {
            "text": "/** Run all nodes reachable from any root, in topological order. */",
            "lineNumber": 468
          },
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 469,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 470,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 471,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 472,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 473,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 474,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 475
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 476
          },
          {
            "text": "\tconst order = topologicalOrderFull(data, settings);",
            "lineNumber": 477
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 478
          },
          {
            "text": "\ttry {",
            "lineNumber": 479
          },
          {
            "text": "\t\tfor (const nid of order) {",
            "lineNumber": 480
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 481
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, nid);",
            "lineNumber": 482
          },
          {
            "text": "\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas);",
            "lineNumber": 483
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 484
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 485
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 486
          },
          {
            "text": "\t\t}",
            "lineNumber": 487
          },
          {
            "text": "}",
            "lineNumber": 492,
            "isSignature": true
          }
        ]
      },
      "score": 0.403639554977417
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 361
          },
          "endPosition": {
            "line": 465,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings\n): void {\n\n\tdata.edges.push({\n\t\tid: randomId(),\n\t\tfromNode: sourceNode.id,\n\t\ttoNode: newNodeId,\n\t\tlabel: EDGE_LABEL_OUTPUT,\n\t});\n}\n\n/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */\nexport async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return { ok: false, message: \"Node not found.\" };\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };\n\tconst parentIds = getParentIdsSortedByY(nodeId, data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tfor (const pid of parentIds) {\n\t\tif (getNodeResult(canvasKey, pid) == null) {\n\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);\n\t\t}\n\t}\n\ttry {\n\t\tsetRunningNodeId(canvasKey, nodeId);\n\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);\n\t\treturn { ok: true };\n\t} catch (e)\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 362,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 363,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 364,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 365,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 366,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 367,
            "isSignature": true
          },
          {
            "lineNumber": 426
          },
          {
            "text": "\tdata.edges.push({",
            "lineNumber": 427
          },
          {
            "text": "\t\tid: randomId(),",
            "lineNumber": 428
          },
          {
            "text": "\t\tfromNode: sourceNode.id,",
            "lineNumber": 429
          },
          {
            "text": "\t\ttoNode: newNodeId,",
            "lineNumber": 430
          },
          {
            "text": "\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 431
          },
          {
            "text": "\t});",
            "lineNumber": 432
          },
          {
            "text": "}",
            "lineNumber": 433,
            "isSignature": true
          },
          {
            "lineNumber": 434
          },
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 435
          },
          {
            "text": "export async function runNode(",
            "lineNumber": 436,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 437,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 438,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 439,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 440,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 441,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 442,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 443
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 444
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 445
          },
          {
            "text": "\tif (!node) return { ok: false, message: \"Node not found.\" };",
            "lineNumber": 446
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 447
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 448
          },
          {
            "text": "\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };",
            "lineNumber": 449
          },
          {
            "text": "\tconst parentIds = getParentIdsSortedByY(nodeId, data);",
            "lineNumber": 450
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 451
          },
          {
            "text": "\tfor (const pid of parentIds) {",
            "lineNumber": 452
          },
          {
            "text": "\t\tif (getNodeResult(canvasKey, pid) == null) {",
            "lineNumber": 453
          },
          {
            "text": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);",
            "lineNumber": 454
          },
          {
            "text": "\t\t}",
            "lineNumber": 455
          },
          {
            "text": "\t}",
            "lineNumber": 456
          },
          {
            "text": "\ttry {",
            "lineNumber": 457
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, nodeId);",
            "lineNumber": 458
          },
          {
            "text": "\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);",
            "lineNumber": 459
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 460
          },
          {
            "text": "\t} catch (e)",
            "lineNumber": 461
          },
          {
            "text": "}",
            "lineNumber": 466,
            "isSignature": true
          }
        ]
      },
      "score": 0.35977819561958313
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 187
          },
          "endPosition": {
            "line": 281,
            "column": 1
          }
        },
        "contents": "async function updateEdgeLabelsAndSave(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tedgeModes: Map&lt;string, EdgeInputMode&gt;,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\n}\n\n/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */\nasync function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return \"\";\n\tconst role = getNodeRole(node, settings);\n\tif (!role || role === \"yellow\" || role === \"green\") {\n\t\t// Yellow: pass-through (use node content as result)\n\t\tif (role === \"yellow\") {\n\t\t\tconst content = await getNodeContent(node, app.vault);\n\t\t\tsetNodeResult(canvasKey, nodeId, content);\n\t\t\treturn content;\n\t\t}\n\t\treturn \"\";\n\t}\n\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\tconst nodeInput = await getNodeContent(node, app.vault);\n\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(\n\t\tcanvasKey,\n\t\tnodeInput,\n\t\tincoming\n\t);\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"purple\") {\n\t\tconst model = settings.ollamaPurpleModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"red\") {\n\t\tconst model = settings.ollamaRedModel || \"llama2\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "async function updateEdgeLabelsAndSave(",
            "lineNumber": 188,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 189,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 190,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 191,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 192,
            "isSignature": true
          },
          {
            "text": "\tedgeModes: Map&lt;string, EdgeInputMode&gt;,",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 195,
            "isSignature": true
          },
          {
            "lineNumber": 214
          },
          {
            "text": "}",
            "lineNumber": 215,
            "isSignature": true
          },
          {
            "lineNumber": 216
          },
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 217
          },
          {
            "text": "async function runSingleNode(",
            "lineNumber": 218,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 219,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 220,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 221,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 222,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 223,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 224,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 225,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 226,
            "isSignature": true
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 227
          },
          {
            "text": "\tif (!node) return \"\";",
            "lineNumber": 228
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 229
          },
          {
            "text": "\tif (!role || role === \"yellow\" || role === \"green\") {",
            "lineNumber": 230
          },
          {
            "text": "\t\t// Yellow: pass-through (use node content as result)",
            "lineNumber": 231
          },
          {
            "text": "\t\tif (role === \"yellow\") {",
            "lineNumber": 232
          },
          {
            "text": "\t\t\tconst content = await getNodeContent(node, app.vault);",
            "lineNumber": 233
          },
          {
            "text": "\t\t\tsetNodeResult(canvasKey, nodeId, content);",
            "lineNumber": 234
          },
          {
            "text": "\t\t\treturn content;",
            "lineNumber": 235
          },
          {
            "text": "\t\t}",
            "lineNumber": 236
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 237
          },
          {
            "text": "\t}",
            "lineNumber": 238
          },
          {
            "text": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 239
          },
          {
            "text": "\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 240
          },
          {
            "text": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(",
            "lineNumber": 241
          },
          {
            "text": "\t\tcanvasKey,",
            "lineNumber": 242
          },
          {
            "text": "\t\tnodeInput,",
            "lineNumber": 243
          },
          {
            "text": "\t\tincoming",
            "lineNumber": 244
          },
          {
            "text": "\t);",
            "lineNumber": 245
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 246
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 247
          },
          {
            "lineNumber": 248
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 249
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 250
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 251
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 252
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 253
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 254
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 255
          },
          {
            "text": "\t}",
            "lineNumber": 256
          },
          {
            "text": "\tif (role === \"purple\") {",
            "lineNumber": 257
          },
          {
            "text": "\t\tconst model = settings.ollamaPurpleModel || \"llama2\";",
            "lineNumber": 258
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 259
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 260
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 261
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 262
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 263
          },
          {
            "text": "\t}",
            "lineNumber": 264
          },
          {
            "text": "\tif (role === \"red\") {",
            "lineNumber": 265
          },
          {
            "text": "\t\tconst model = settings.ollamaRedModel || \"llama2\";",
            "lineNumber": 266
          },
          {
            "text": "}",
            "lineNumber": 282,
            "isSignature": true
          }
        ]
      },
      "score": 0.29379820823669434
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 128,
            "column": 1
          },
          "endPosition": {
            "line": 148,
            "column": 93
          }
        },
        "contents": "/** Sort ready queue: non-AI (Python, yellow) first for early output, then by y. */\nfunction sortQueueByNonAIFirst(\n\tqueue: string[],\n\tdata: CanvasData,\n\tsettings: ZettelPluginSettings\n): void {\n\tqueue.sort((a, b) =&gt; {\n\t\tconst na = getNodeById(data, a);\n\t\tconst nb = getNodeById(data, b);\n\t\tconst roleA = getNodeRole(na ?? { color: undefined }, settings);\n\t\tconst roleB = getNodeRole(nb ?? { color: undefined }, settings);\n\t\tconst nonA = isNonAIRole(roleA) ? 0 : 1;\n\t\tconst nonB = isNonAIRole(roleB) ? 0 : 1;\n\t\tif (nonA !== nonB) return nonA - nonB;\n\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);\n\t});\n}\n\n/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Sort ready queue: non-AI (Python, yellow) first for early output, then by y. */",
            "lineNumber": 131
          },
          {
            "text": "function sortQueueByNonAIFirst(",
            "lineNumber": 132,
            "isSignature": true
          },
          {
            "text": "\tqueue: string[],",
            "lineNumber": 133,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 134,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 135,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 136,
            "isSignature": true
          },
          {
            "text": "\tqueue.sort((a, b) =&gt; {",
            "lineNumber": 137
          },
          {
            "text": "\t\tconst na = getNodeById(data, a);",
            "lineNumber": 138
          },
          {
            "text": "\t\tconst nb = getNodeById(data, b);",
            "lineNumber": 139
          },
          {
            "text": "\t\tconst roleA = getNodeRole(na ?? { color: undefined }, settings);",
            "lineNumber": 140
          },
          {
            "text": "\t\tconst roleB = getNodeRole(nb ?? { color: undefined }, settings);",
            "lineNumber": 141
          },
          {
            "text": "\t\tconst nonA = isNonAIRole(roleA) ? 0 : 1;",
            "lineNumber": 142
          },
          {
            "text": "\t\tconst nonB = isNonAIRole(roleB) ? 0 : 1;",
            "lineNumber": 143
          },
          {
            "text": "\t\tif (nonA !== nonB) return nonA - nonB;",
            "lineNumber": 144
          },
          {
            "text": "\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);",
            "lineNumber": 145
          },
          {
            "text": "\t});",
            "lineNumber": 146
          },
          {
            "text": "}",
            "lineNumber": 147,
            "isSignature": true
          },
          {
            "lineNumber": 148
          },
          {
            "text": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
            "lineNumber": 149
          }
        ]
      },
      "score": 0.2917459011077881
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 32
          },
          "endPosition": {
            "line": 58,
            "column": 1
          }
        },
        "contents": "function isNonAIRole(role: NodeRole | null): boolean {\n\n}\n\n/** Get all root node ids (no incoming non-output edges). */\nfunction getRootIds(data: CanvasData): string[] {\n\tconst hasIncoming = new Set(\n\t\tdata.edges.filter((e) =&gt; !isOutputEdge(e)).map((e) =&gt; e.toNode)\n\t);\n\treturn data.nodes.filter((n) =&gt; !hasIncoming.has(n.id)).map((n) =&gt; n.id);\n}\n\n/** Check if there is a path from fromId to toId (ignoring output edges). */\nfunction canReach(data: CanvasData, fromId: string, toId: string): boolean {\n\tconst visited = new Set&lt;string&gt;();\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function isNonAIRole(role: NodeRole | null): boolean {",
            "lineNumber": 33,
            "isSignature": true
          },
          {
            "lineNumber": 34
          },
          {
            "text": "}",
            "lineNumber": 35,
            "isSignature": true
          },
          {
            "lineNumber": 36
          },
          {
            "text": "/** Get all root node ids (no incoming non-output edges). */",
            "lineNumber": 37
          },
          {
            "text": "function getRootIds(data: CanvasData): string[] {",
            "lineNumber": 38,
            "isSignature": true
          },
          {
            "text": "\tconst hasIncoming = new Set(",
            "lineNumber": 39
          },
          {
            "text": "\t\tdata.edges.filter((e) =&gt; !isOutputEdge(e)).map((e) =&gt; e.toNode)",
            "lineNumber": 40
          },
          {
            "text": "\t);",
            "lineNumber": 41
          },
          {
            "text": "\treturn data.nodes.filter((n) =&gt; !hasIncoming.has(n.id)).map((n) =&gt; n.id);",
            "lineNumber": 42
          },
          {
            "text": "}",
            "lineNumber": 43,
            "isSignature": true
          },
          {
            "lineNumber": 44
          },
          {
            "text": "/** Check if there is a path from fromId to toId (ignoring output edges). */",
            "lineNumber": 45
          },
          {
            "text": "function canReach(data: CanvasData, fromId: string, toId: string): boolean {",
            "lineNumber": 46,
            "isSignature": true
          },
          {
            "text": "\tconst visited = new Set&lt;string&gt;();",
            "lineNumber": 47
          },
          {
            "text": "}",
            "lineNumber": 59,
            "isSignature": true
          }
        ]
      },
      "score": 0.2347206026315689
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 42,
            "column": 1
          },
          "endPosition": {
            "line": 60,
            "column": 101
          }
        },
        "contents": "/** Check if there is a path from fromId to toId (ignoring output edges). */\nfunction canReach(data: CanvasData, fromId: string, toId: string): boolean {\n\tconst visited = new Set&lt;string&gt;();\n\tconst stack = [fromId];\n\twhile (stack.length &gt; 0) {\n\t\tconst id = stack.pop()!;\n\t\tif (id === toId) return true;\n\t\tif (visited.has(id)) continue;\n\t\tvisited.add(id);\n\t\tfor (const e of data.edges) {\n\t\t\tif (!isOutputEdge(e) &amp;&amp; e.fromNode === id) stack.push(e.toNode);\n\t\t}\n\t}\n\treturn false;\n}\n\n/** Topological order of node ids (only nodes that are ancestors of target; ignores output edges). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Check if there is a path from fromId to toId (ignoring output edges). */",
            "lineNumber": 45
          },
          {
            "text": "function canReach(data: CanvasData, fromId: string, toId: string): boolean {",
            "lineNumber": 46,
            "isSignature": true
          },
          {
            "text": "\tconst visited = new Set&lt;string&gt;();",
            "lineNumber": 47
          },
          {
            "text": "\tconst stack = [fromId];",
            "lineNumber": 48
          },
          {
            "text": "\twhile (stack.length &gt; 0) {",
            "lineNumber": 49
          },
          {
            "text": "\t\tconst id = stack.pop()!;",
            "lineNumber": 50
          },
          {
            "text": "\t\tif (id === toId) return true;",
            "lineNumber": 51
          },
          {
            "text": "\t\tif (visited.has(id)) continue;",
            "lineNumber": 52
          },
          {
            "text": "\t\tvisited.add(id);",
            "lineNumber": 53
          },
          {
            "text": "\t\tfor (const e of data.edges) {",
            "lineNumber": 54
          },
          {
            "text": "\t\t\tif (!isOutputEdge(e) &amp;&amp; e.fromNode === id) stack.push(e.toNode);",
            "lineNumber": 55
          },
          {
            "text": "\t\t}",
            "lineNumber": 56
          },
          {
            "text": "\t}",
            "lineNumber": 57
          },
          {
            "text": "\treturn false;",
            "lineNumber": 58
          },
          {
            "text": "}",
            "lineNumber": 59,
            "isSignature": true
          },
          {
            "lineNumber": 60
          },
          {
            "text": "/** Topological order of node ids (only nodes that are ancestors of target; ignores output edges). */",
            "lineNumber": 61
          }
        ]
      },
      "score": 0.21947799623012543
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 57,
            "column": 1
          },
          "endPosition": {
            "line": 77,
            "column": 90
          }
        },
        "contents": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y. Excludes output edges. */\nexport function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withY = edges.map((e) =&gt; {\n\t\tconst parent = nodeMap.get(e.fromNode);\n\t\tconst y = parent?.y ?? 0;\n\t\treturn {\n\t\t\tparentId: e.fromNode,\n\t\t\tedge: e,\n\t\t\tvariableName: parseEdgeVariableName(e.label),\n\t\t\ty,\n\t\t};\n\t});\n\twithY.sort((a, b) =&gt; a.y - b.y);\n\treturn withY.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));\n}\n\n/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y. Excludes output edges. */",
            "lineNumber": 60
          },
          {
            "text": "export function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {",
            "lineNumber": 61,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));",
            "lineNumber": 62
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 63
          },
          {
            "text": "\tconst withY = edges.map((e) =&gt; {",
            "lineNumber": 64
          },
          {
            "text": "\t\tconst parent = nodeMap.get(e.fromNode);",
            "lineNumber": 65
          },
          {
            "text": "\t\tconst y = parent?.y ?? 0;",
            "lineNumber": 66
          },
          {
            "text": "\t\treturn {",
            "lineNumber": 67
          },
          {
            "text": "\t\t\tparentId: e.fromNode,",
            "lineNumber": 68
          },
          {
            "text": "\t\t\tedge: e,",
            "lineNumber": 69
          },
          {
            "text": "\t\t\tvariableName: parseEdgeVariableName(e.label),",
            "lineNumber": 70
          },
          {
            "text": "\t\t\ty,",
            "lineNumber": 71
          },
          {
            "text": "\t\t};",
            "lineNumber": 72
          },
          {
            "text": "\t});",
            "lineNumber": 73
          },
          {
            "text": "\twithY.sort((a, b) =&gt; a.y - b.y);",
            "lineNumber": 74
          },
          {
            "text": "\treturn withY.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));",
            "lineNumber": 75
          },
          {
            "text": "}",
            "lineNumber": 76,
            "isSignature": true
          },
          {
            "lineNumber": 77
          },
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */",
            "lineNumber": 78
          }
        ]
      },
      "score": 0.2158164381980896
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 146,
            "column": 1
          },
          "endPosition": {
            "line": 186,
            "column": 107
          }
        },
        "contents": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */\nfunction buildInputWithVariables(\n\tcanvasKey: string,\n\tnodeInput: string,\n\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[]\n): { concatenatedPart: string; template: string; edgeModes: Map&lt;string, EdgeInputMode&gt; } {\n\tconst edgeModes = new Map&lt;string, EdgeInputMode&gt;();\n\tconst parentResults = new Map&lt;string, string&gt;();\n\tfor (const { parentId } of incoming) {\n\t\tconst r = getNodeResult(canvasKey, parentId);\n\t\tif (r != null) parentResults.set(parentId, r);\n\t}\n\tlet concatenatedPart = \"\";\n\tconst varValues: Record&lt;string, string&gt; = {};\n\tfor (const { parentId, edge, variableName } of incoming) {\n\t\tconst result = parentResults.get(parentId);\n\t\tif (result == null) continue;\n\t\tconst usedAsVar =\n\t\t\tvariableName.length &gt; 0 &amp;&amp; nodeInput.includes(&#96;{{var:${variableName}}}&#96;);\n\t\tif (usedAsVar) {\n\t\t\tedgeModes.set(edge.id, \"inject\");\n\t\t\tvarValues[variableName] = result;\n\t\t} else {\n\t\t\tedgeModes.set(edge.id, \"concatenate\");\n\t\t\tconcatenatedPart += result + \"\\n\\n\";\n\t\t}\n\t}\n\tlet template = nodeInput;\n\tfor (const [name, value] of Object.entries(varValues)) {\n\t\ttemplate = template.split(&#96;{{var:${name}}}&#96;).join(value);\n\t}\n\treturn {\n\t\tconcatenatedPart: concatenatedPart.trim(),\n\t\ttemplate,\n\t\tedgeModes,\n\t};\n}\n\n/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
            "lineNumber": 149
          },
          {
            "text": "function buildInputWithVariables(",
            "lineNumber": 150,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 151,
            "isSignature": true
          },
          {
            "text": "\tnodeInput: string,",
            "lineNumber": 152,
            "isSignature": true
          },
          {
            "text": "\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[]",
            "lineNumber": 153,
            "isSignature": true
          },
          {
            "text": "): { concatenatedPart: string; template: string; edgeModes: Map&lt;string, EdgeInputMode&gt; } {",
            "lineNumber": 154,
            "isSignature": true
          },
          {
            "text": "\tconst edgeModes = new Map&lt;string, EdgeInputMode&gt;();",
            "lineNumber": 155
          },
          {
            "text": "\tconst parentResults = new Map&lt;string, string&gt;();",
            "lineNumber": 156
          },
          {
            "text": "\tfor (const { parentId } of incoming) {",
            "lineNumber": 157
          },
          {
            "text": "\t\tconst r = getNodeResult(canvasKey, parentId);",
            "lineNumber": 158
          },
          {
            "text": "\t\tif (r != null) parentResults.set(parentId, r);",
            "lineNumber": 159
          },
          {
            "text": "\t}",
            "lineNumber": 160
          },
          {
            "text": "\tlet concatenatedPart = \"\";",
            "lineNumber": 161
          },
          {
            "text": "\tconst varValues: Record&lt;string, string&gt; = {};",
            "lineNumber": 162
          },
          {
            "text": "\tfor (const { parentId, edge, variableName } of incoming) {",
            "lineNumber": 163
          },
          {
            "text": "\t\tconst result = parentResults.get(parentId);",
            "lineNumber": 164
          },
          {
            "text": "\t\tif (result == null) continue;",
            "lineNumber": 165
          },
          {
            "text": "\t\tconst usedAsVar =",
            "lineNumber": 166
          },
          {
            "text": "\t\t\tvariableName.length &gt; 0 &amp;&amp; nodeInput.includes(&#96;{{var:${variableName}}}&#96;);",
            "lineNumber": 167
          },
          {
            "text": "\t\tif (usedAsVar) {",
            "lineNumber": 168
          },
          {
            "text": "\t\t\tedgeModes.set(edge.id, \"inject\");",
            "lineNumber": 169
          },
          {
            "text": "\t\t\tvarValues[variableName] = result;",
            "lineNumber": 170
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 171
          },
          {
            "text": "\t\t\tedgeModes.set(edge.id, \"concatenate\");",
            "lineNumber": 172
          },
          {
            "text": "\t\t\tconcatenatedPart += result + \"\\n\\n\";",
            "lineNumber": 173
          },
          {
            "text": "\t\t}",
            "lineNumber": 174
          },
          {
            "text": "\t}",
            "lineNumber": 175
          },
          {
            "text": "\tlet template = nodeInput;",
            "lineNumber": 176
          },
          {
            "text": "\tfor (const [name, value] of Object.entries(varValues)) {",
            "lineNumber": 177
          },
          {
            "text": "\t\ttemplate = template.split(&#96;{{var:${name}}}&#96;).join(value);",
            "lineNumber": 178
          },
          {
            "text": "\t}",
            "lineNumber": 179
          },
          {
            "text": "\treturn {",
            "lineNumber": 180
          },
          {
            "text": "\t\tconcatenatedPart: concatenatedPart.trim(),",
            "lineNumber": 181
          },
          {
            "text": "\t\ttemplate,",
            "lineNumber": 182
          },
          {
            "text": "\t\tedgeModes,",
            "lineNumber": 183
          },
          {
            "text": "\t};",
            "lineNumber": 184
          },
          {
            "text": "}",
            "lineNumber": 185,
            "isSignature": true
          },
          {
            "lineNumber": 186
          },
          {
            "text": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
            "lineNumber": 187
          }
        ]
      },
      "score": 0.21556520462036133
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 75,
            "column": 1
          },
          "endPosition": {
            "line": 95,
            "column": 1
          }
        },
        "contents": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */\nexport function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));\n\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withY = fromIds\n\t\t.map((id) =&gt; {\n\t\t\tconst node = nodeMap.get(id);\n\t\t\treturn node ? { id, y: node.y } : null;\n\t\t})\n\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);\n\twithY.sort((a, b) =&gt; a.y - b.y);\n\treturn withY.map((x) =&gt; x.id);\n}\n\n/** Get node by id from canvas data. */\nexport function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */",
            "lineNumber": 78
          },
          {
            "text": "export function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {",
            "lineNumber": 79,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));",
            "lineNumber": 80
          },
          {
            "text": "\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];",
            "lineNumber": 81
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 82
          },
          {
            "text": "\tconst withY = fromIds",
            "lineNumber": 83
          },
          {
            "text": "\t\t.map((id) =&gt; {",
            "lineNumber": 84
          },
          {
            "text": "\t\t\tconst node = nodeMap.get(id);",
            "lineNumber": 85
          },
          {
            "text": "\t\t\treturn node ? { id, y: node.y } : null;",
            "lineNumber": 86
          },
          {
            "text": "\t\t})",
            "lineNumber": 87
          },
          {
            "text": "\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);",
            "lineNumber": 88
          },
          {
            "text": "\twithY.sort((a, b) =&gt; a.y - b.y);",
            "lineNumber": 89
          },
          {
            "text": "\treturn withY.map((x) =&gt; x.id);",
            "lineNumber": 90
          },
          {
            "text": "}",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "lineNumber": 92
          },
          {
            "text": "/** Get node by id from canvas data. */",
            "lineNumber": 93
          },
          {
            "text": "export function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {",
            "lineNumber": 94,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 95
          },
          {
            "text": "}",
            "lineNumber": 96,
            "isSignature": true
          }
        ]
      },
      "score": 0.21519020199775696
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "column": 71
          },
          "endPosition": {
            "line": 30,
            "column": 108
          }
        },
        "contents": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";\nimport {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";\nimport {\n\tdismissAllOutput as runnerDismissAllOutput,\n\tdismissOutput as runnerDismissOutput,\n\trunChain as runnerRunChain,\n\trunEntireCanvas as runnerRunEntireCanvas,\n\trunNode as runnerRunNode,\n} from \"./engine/runner\";\nimport {\n\tclearCanvasEdgeModeLabels,\n\tclearCanvasLegend,\n\tclearCanvasRoleLabels,\n\tsyncCanvasEdgeModeLabels,\n\tsyncCanvasRoleLabels,\n} from \"./canvas/canvasNodeLabels\";\nimport {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";\n\n/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */\nfunction resolveCanvasNodeId(node: unknown): string | undefined {\n\tif (!node || typeof node !== \"object\") return undefined;\n\tconst n = node as Record&lt;string, unknown&gt;;\n\tif (typeof n.id === \"string\") return n.id;\n\tconst inner = n.node as Record&lt;string, unknown&gt; | undefined;\n\tif (inner &amp;&amp; typeof inner.id === \"string\") return inner.id;\n\tconst data = typeof n.getData === \"function\" ? (n.getData as () =&gt; { id?: string })() : undefined;\n\treturn data?.id;\n}\n\n/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";",
            "lineNumber": 2
          },
          {
            "text": "import {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";",
            "lineNumber": 3
          },
          {
            "text": "import {",
            "lineNumber": 4
          },
          {
            "text": "\tdismissAllOutput as runnerDismissAllOutput,",
            "lineNumber": 5
          },
          {
            "text": "\tdismissOutput as runnerDismissOutput,",
            "lineNumber": 6
          },
          {
            "text": "\trunChain as runnerRunChain,",
            "lineNumber": 7
          },
          {
            "text": "\trunEntireCanvas as runnerRunEntireCanvas,",
            "lineNumber": 8
          },
          {
            "text": "\trunNode as runnerRunNode,",
            "lineNumber": 9
          },
          {
            "text": "} from \"./engine/runner\";",
            "lineNumber": 10
          },
          {
            "text": "import {",
            "lineNumber": 11
          },
          {
            "text": "\tclearCanvasEdgeModeLabels,",
            "lineNumber": 12
          },
          {
            "text": "\tclearCanvasLegend,",
            "lineNumber": 13
          },
          {
            "text": "\tclearCanvasRoleLabels,",
            "lineNumber": 14
          },
          {
            "text": "\tsyncCanvasEdgeModeLabels,",
            "lineNumber": 15
          },
          {
            "text": "\tsyncCanvasRoleLabels,",
            "lineNumber": 16
          },
          {
            "text": "} from \"./canvas/canvasNodeLabels\";",
            "lineNumber": 17
          },
          {
            "text": "import {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";",
            "lineNumber": 18
          },
          {
            "lineNumber": 19
          },
          {
            "text": "/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */",
            "lineNumber": 20
          },
          {
            "text": "function resolveCanvasNodeId(node: unknown): string | undefined {",
            "lineNumber": 21,
            "isSignature": true
          },
          {
            "text": "\tif (!node || typeof node !== \"object\") return undefined;",
            "lineNumber": 22
          },
          {
            "text": "\tconst n = node as Record&lt;string, unknown&gt;;",
            "lineNumber": 23
          },
          {
            "text": "\tif (typeof n.id === \"string\") return n.id;",
            "lineNumber": 24
          },
          {
            "text": "\tconst inner = n.node as Record&lt;string, unknown&gt; | undefined;",
            "lineNumber": 25
          },
          {
            "text": "\tif (inner &amp;&amp; typeof inner.id === \"string\") return inner.id;",
            "lineNumber": 26
          },
          {
            "text": "\tconst data = typeof n.getData === \"function\" ? (n.getData as () =&gt; { id?: string })() : undefined;",
            "lineNumber": 27
          },
          {
            "text": "\treturn data?.id;",
            "lineNumber": 28
          },
          {
            "text": "}",
            "lineNumber": 29,
            "isSignature": true
          },
          {
            "lineNumber": 30
          },
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 31
          }
        ]
      },
      "score": 0.2126052975654602
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 29,
            "column": 46
          },
          "endPosition": {
            "line": 42,
            "column": 1
          }
        },
        "contents": "/** True if the role is non-AI (Python or pass-through); prefer running these first for early output. */\nfunction isNonAIRole(role: NodeRole | null): boolean {\n\treturn role === \"blue\" || role === \"yellow\";\n}\n\n/** Get all root node ids (no incoming non-output edges). */\nfunction getRootIds(data: CanvasData): string[] {\n\tconst hasIncoming = new Set\n;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** True if the role is non-AI (Python or pass-through); prefer running these first for early output. */",
            "lineNumber": 32
          },
          {
            "text": "function isNonAIRole(role: NodeRole | null): boolean {",
            "lineNumber": 33,
            "isSignature": true
          },
          {
            "text": "\treturn role === \"blue\" || role === \"yellow\";",
            "lineNumber": 34
          },
          {
            "text": "}",
            "lineNumber": 35,
            "isSignature": true
          },
          {
            "lineNumber": 36
          },
          {
            "text": "/** Get all root node ids (no incoming non-output edges). */",
            "lineNumber": 37
          },
          {
            "text": "function getRootIds(data: CanvasData): string[] {",
            "lineNumber": 38,
            "isSignature": true
          },
          {
            "text": "\tconst hasIncoming = new Set",
            "lineNumber": 39
          },
          {
            "text": ";",
            "lineNumber": 41
          },
          {
            "text": "}",
            "lineNumber": 43,
            "isSignature": true
          }
        ]
      },
      "score": 0.20414620637893677
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 121,
            "column": 50
          },
          "endPosition": {
            "line": 148,
            "column": 1
          }
        },
        "contents": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */\nexport function findOutputNodeForSource(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\tsettings: ZettelPluginSettings\n): string | null {\n\tconst outputEdge = data.edges.find(\n\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t);\n\tif (outputEdge) return outputEdge.toNode;\n\tconst source = getNodeById(data, sourceNodeId);\n\tif (!source) return null;\n\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);\n\tif (!greenColor) return null;\n\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;\n\tconst toleranceAbove = 30; // allow small layout drift above default\n\tfor (const node of data.nodes) {\n\t\tif (node.id === sourceNodeId) continue;\n\t\tif (normalizeColor(node.color) !== greenColor) continue;\n\t\t// Same x (or close), and y at or below expected (collision avoidance may place it lower)\n\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;\n\t\tif (node.y &lt; expectedY - toleranceAbove || node.y &gt; expectedY + OUTPUT_POSITION_FALLBACK_MAX_Y) continue;\n\t\treturn node.id;\n\t}\n\treturn null;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
            "lineNumber": 124
          },
          {
            "text": "export function findOutputNodeForSource(",
            "lineNumber": 125,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 126,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 127,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 128,
            "isSignature": true
          },
          {
            "text": "): string | null {",
            "lineNumber": 129,
            "isSignature": true
          },
          {
            "text": "\tconst outputEdge = data.edges.find(",
            "lineNumber": 130
          },
          {
            "text": "\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 131
          },
          {
            "text": "\t);",
            "lineNumber": 132
          },
          {
            "text": "\tif (outputEdge) return outputEdge.toNode;",
            "lineNumber": 133
          },
          {
            "text": "\tconst source = getNodeById(data, sourceNodeId);",
            "lineNumber": 134
          },
          {
            "text": "\tif (!source) return null;",
            "lineNumber": 135
          },
          {
            "text": "\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);",
            "lineNumber": 136
          },
          {
            "text": "\tif (!greenColor) return null;",
            "lineNumber": 137
          },
          {
            "text": "\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;",
            "lineNumber": 138
          },
          {
            "text": "\tconst toleranceAbove = 30; // allow small layout drift above default",
            "lineNumber": 139
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 140
          },
          {
            "text": "\t\tif (node.id === sourceNodeId) continue;",
            "lineNumber": 141
          },
          {
            "text": "\t\tif (normalizeColor(node.color) !== greenColor) continue;",
            "lineNumber": 142
          },
          {
            "text": "\t\t// Same x (or close), and y at or below expected (collision avoidance may place it lower)",
            "lineNumber": 143
          },
          {
            "text": "\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;",
            "lineNumber": 144
          },
          {
            "text": "\t\tif (node.y &lt; expectedY - toleranceAbove || node.y &gt; expectedY + OUTPUT_POSITION_FALLBACK_MAX_Y) continue;",
            "lineNumber": 145
          },
          {
            "text": "\t\treturn node.id;",
            "lineNumber": 146
          },
          {
            "text": "\t}",
            "lineNumber": 147
          },
          {
            "text": "\treturn null;",
            "lineNumber": 148
          },
          {
            "text": "}",
            "lineNumber": 149,
            "isSignature": true
          }
        ]
      },
      "score": 0.20002159476280212
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 217
          },
          "endPosition": {
            "line": 283,
            "column": 99
          }
        },
        "contents": "async function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\n\tif (role === \"red\") {\n\t\tconst model = settings.ollamaRedModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"blue\") {\n\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);\n\t\tconst result = await kernel.run(template, concatenatedPart);\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\treturn \"\";\n}\n\n/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 218,
                "column": 1
              },
              "endPosition": {
                "line": 227,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "async function runSingleNode(",
            "lineNumber": 218,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 219,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 220,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 221,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 222,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 223,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 224,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 225,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 226,
            "isSignature": true
          },
          {
            "lineNumber": 264
          },
          {
            "text": "\tif (role === \"red\") {",
            "lineNumber": 265
          },
          {
            "text": "\t\tconst model = settings.ollamaRedModel || \"llama2\";",
            "lineNumber": 266
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 267
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 268
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 269
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 270
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 271
          },
          {
            "text": "\t}",
            "lineNumber": 272
          },
          {
            "text": "\tif (role === \"blue\") {",
            "lineNumber": 273
          },
          {
            "text": "\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);",
            "lineNumber": 274
          },
          {
            "text": "\t\tconst result = await kernel.run(template, concatenatedPart);",
            "lineNumber": 275
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 276
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 277
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 278
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 279
          },
          {
            "text": "\t}",
            "lineNumber": 280
          },
          {
            "text": "\treturn \"\";",
            "lineNumber": 281
          },
          {
            "text": "}",
            "lineNumber": 282,
            "isSignature": true
          },
          {
            "lineNumber": 283
          },
          {
            "text": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
            "lineNumber": 284
          }
        ]
      },
      "score": 0.1975993514060974
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\n\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js).\n\t\t\tconst addNodeMenuItems = (menu: Menu, node: unknown): void =&gt; {\n\t\t\t\tdebugNodeMenuFired = true;\n\t\t\t\tconst nodeId = resolveCanvasNodeId(node);\n\t\t\t\tif (!nodeId) return;\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Dismiss output\").setIcon(\"trash\").onClick(() =&gt; this.dismissOutput(nodeId))\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst registerCanvasNodeMenu = () =&gt; {\n\t\t\t\ttry {\n\t\t\t\t\tconst on = this.app.workspace.on.bind(this.app.workspace) as (\n\t\t\t\t\t\tname: string,\n\t\t\t\t\t\tcallback: (menu: Menu, node: unknown) =&gt; void\n\t\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;\n\t\t\t\t\t// Try documented-style event name first; some Obsidian builds use \"canvas:node-menu\".\n\t\t\t\t\tthis.registerEvent(on(\"canvas:node-menu\", addNodeMenuItems));\n\t\t\t\t\t// Fallback: try hyphenated name in case the app triggers a different event.\n\t\t\t\t\tthis.registerEvent(on(\"canvas-node-menu\", addNodeMenuItems));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas node menu.\", e);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst timeoutId = window.setTimeout(registerCanvasNodeMenu, 0);\n\t\t\tthis.register(() =&gt; window.clearTimeout(timeoutId));\n\n\t\t\t// Canvas background context menu: use undocumented \"canvas:edge-menu\" (Obsidian broadcasts it;\n\t\t\t// when right-click is on empty area, edge is null). Same pattern as canvas:node-menu: addItem with setTitle, setIcon, onClick.\n\t\t\tconst addCanvasMenuItems = (menu: Menu): void =&gt; {\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Dismiss all output\").setIcon(\"trash\").onClick(() =&gt; this.dismissAllOutput())\n\t\t\t\t);\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace)\n;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 37,
                "column": 2
              },
              "endPosition": {
                "line": 38,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 37
          },
          {
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 90
          },
          {
            "text": "\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js).",
            "lineNumber": 91
          },
          {
            "text": "\t\t\tconst addNodeMenuItems = (menu: Menu, node: unknown): void =&gt; {",
            "lineNumber": 92
          },
          {
            "text": "\t\t\t\tdebugNodeMenuFired = true;",
            "lineNumber": 93
          },
          {
            "text": "\t\t\t\tconst nodeId = resolveCanvasNodeId(node);",
            "lineNumber": 94
          },
          {
            "text": "\t\t\t\tif (!nodeId) return;",
            "lineNumber": 95
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 96
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))",
            "lineNumber": 97
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 98
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 99
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))",
            "lineNumber": 100
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 101
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 102
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Dismiss output\").setIcon(\"trash\").onClick(() =&gt; this.dismissOutput(nodeId))",
            "lineNumber": 103
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 104
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 105
          },
          {
            "text": "\t\t\tconst registerCanvasNodeMenu = () =&gt; {",
            "lineNumber": 106
          },
          {
            "text": "\t\t\t\ttry {",
            "lineNumber": 107
          },
          {
            "text": "\t\t\t\t\tconst on = this.app.workspace.on.bind(this.app.workspace) as (",
            "lineNumber": 108
          },
          {
            "text": "\t\t\t\t\t\tname: string,",
            "lineNumber": 109
          },
          {
            "text": "\t\t\t\t\t\tcallback: (menu: Menu, node: unknown) =&gt; void",
            "lineNumber": 110
          },
          {
            "text": "\t\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;",
            "lineNumber": 111
          },
          {
            "text": "\t\t\t\t\t// Try documented-style event name first; some Obsidian builds use \"canvas:node-menu\".",
            "lineNumber": 112
          },
          {
            "text": "\t\t\t\t\tthis.registerEvent(on(\"canvas:node-menu\", addNodeMenuItems));",
            "lineNumber": 113
          },
          {
            "text": "\t\t\t\t\t// Fallback: try hyphenated name in case the app triggers a different event.",
            "lineNumber": 114
          },
          {
            "text": "\t\t\t\t\tthis.registerEvent(on(\"canvas-node-menu\", addNodeMenuItems));",
            "lineNumber": 115
          },
          {
            "text": "\t\t\t\t} catch (e) {",
            "lineNumber": 116
          },
          {
            "text": "\t\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas node menu.\", e);",
            "lineNumber": 117
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 118
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 119
          },
          {
            "text": "\t\t\tconst timeoutId = window.setTimeout(registerCanvasNodeMenu, 0);",
            "lineNumber": 120
          },
          {
            "text": "\t\t\tthis.register(() =&gt; window.clearTimeout(timeoutId));",
            "lineNumber": 121
          },
          {
            "lineNumber": 122
          },
          {
            "text": "\t\t\t// Canvas background context menu: use undocumented \"canvas:edge-menu\" (Obsidian broadcasts it;",
            "lineNumber": 123
          },
          {
            "text": "\t\t\t// when right-click is on empty area, edge is null). Same pattern as canvas:node-menu: addItem with setTitle, setIcon, onClick.",
            "lineNumber": 124
          },
          {
            "text": "\t\t\tconst addCanvasMenuItems = (menu: Menu): void =&gt; {",
            "lineNumber": 125
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 126
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())",
            "lineNumber": 127
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 128
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 129
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Dismiss all output\").setIcon(\"trash\").onClick(() =&gt; this.dismissAllOutput())",
            "lineNumber": 130
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 131
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 132
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 133
          },
          {
            "text": "\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace)",
            "lineNumber": 134
          },
          {
            "text": ";",
            "lineNumber": 137
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.18811160326004028
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 350,
            "column": 1
          },
          "endPosition": {
            "line": 432,
            "column": 1
          }
        },
        "contents": "/** Generate a unique id for new canvas nodes/edges. */\nfunction randomId(): string {\n\tif (typeof crypto !== \"undefined\" &amp;&amp; crypto.randomUUID) {\n\t\treturn crypto.randomUUID();\n\t}\n\treturn \"output-\" + Date.now() + \"-\" + Math.random().toString(36).slice(2, 11);\n}\n\n/** Create or replace the Green output node and ensure an edge labeled \"output\" from source. Mutates data only. */\nfunction ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings\n): void {\n\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);\n\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;\n\tconst width = Math.max(320, sourceNode.width);\n\tconst height = 180;\n\tconst defaultX = sourceNode.x;\n\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(\n\t\tdata,\n\t\tsourceNode.id,\n\t\toutId,\n\t\tdefaultX,\n\t\tdefaultY,\n\t\twidth,\n\t\theight\n\t);\n\tconst greenColor = settings.colorGreen;\n\n\tif (outId) {\n\t\tconst outNode = getNodeById(data, outId);\n\t\tif (outNode &amp;&amp; isTextNode(outNode)) {\n\t\t\tconst updated = {\n\t\t\t\t...(outNode as CanvasTextData),\n\t\t\t\ttext,\n\t\t\t\tx: chosenX,\n\t\t\t\ty: chosenY,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t};\n\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);\n\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t} else if (outNode) {\n\t\t\t(outNode as { x: number; y: number }).x = chosenX;\n\t\t\t(outNode as { x: number; y: number }).y = chosenY;\n\t\t}\n\t\tconst hasOutputEdge = data.edges.some(\n\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t\t);\n\t\tif (!hasOutputEdge) {\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: outId,\n\t\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tconst newNodeId = randomId();\n\tconst newTextNode: CanvasTextData = {\n\t\tid: newNodeId,\n\t\ttype: \"text\",\n\t\ttext,\n\t\tx: chosenX,\n\t\ty: chosenY,\n\t\twidth,\n\t\theight,\n\t\tcolor: greenColor,\n\t};\n\tdata.nodes.push(newTextNode);\n\tdata.edges.push({\n\t\tid: randomId(),\n\t\tfromNode: sourceNode.id,\n\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Generate a unique id for new canvas nodes/edges. */",
            "lineNumber": 353
          },
          {
            "text": "function randomId(): string {",
            "lineNumber": 354,
            "isSignature": true
          },
          {
            "text": "\tif (typeof crypto !== \"undefined\" &amp;&amp; crypto.randomUUID) {",
            "lineNumber": 355
          },
          {
            "text": "\t\treturn crypto.randomUUID();",
            "lineNumber": 356
          },
          {
            "text": "\t}",
            "lineNumber": 357
          },
          {
            "text": "\treturn \"output-\" + Date.now() + \"-\" + Math.random().toString(36).slice(2, 11);",
            "lineNumber": 358
          },
          {
            "text": "}",
            "lineNumber": 359,
            "isSignature": true
          },
          {
            "lineNumber": 360
          },
          {
            "text": "/** Create or replace the Green output node and ensure an edge labeled \"output\" from source. Mutates data only. */",
            "lineNumber": 361
          },
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 362,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 363,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 364,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 365,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 366,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 367,
            "isSignature": true
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);",
            "lineNumber": 368
          },
          {
            "text": "\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;",
            "lineNumber": 369
          },
          {
            "text": "\tconst width = Math.max(320, sourceNode.width);",
            "lineNumber": 370
          },
          {
            "text": "\tconst height = 180;",
            "lineNumber": 371
          },
          {
            "text": "\tconst defaultX = sourceNode.x;",
            "lineNumber": 372
          },
          {
            "text": "\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(",
            "lineNumber": 373
          },
          {
            "text": "\t\tdata,",
            "lineNumber": 374
          },
          {
            "text": "\t\tsourceNode.id,",
            "lineNumber": 375
          },
          {
            "text": "\t\toutId,",
            "lineNumber": 376
          },
          {
            "text": "\t\tdefaultX,",
            "lineNumber": 377
          },
          {
            "text": "\t\tdefaultY,",
            "lineNumber": 378
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 379
          },
          {
            "text": "\t\theight",
            "lineNumber": 380
          },
          {
            "text": "\t);",
            "lineNumber": 381
          },
          {
            "text": "\tconst greenColor = settings.colorGreen;",
            "lineNumber": 382
          },
          {
            "lineNumber": 383
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 384
          },
          {
            "text": "\t\tconst outNode = getNodeById(data, outId);",
            "lineNumber": 385
          },
          {
            "text": "\t\tif (outNode &amp;&amp; isTextNode(outNode)) {",
            "lineNumber": 386
          },
          {
            "text": "\t\t\tconst updated = {",
            "lineNumber": 387
          },
          {
            "text": "\t\t\t\t...(outNode as CanvasTextData),",
            "lineNumber": 388
          },
          {
            "text": "\t\t\t\ttext,",
            "lineNumber": 389
          },
          {
            "text": "\t\t\t\tx: chosenX,",
            "lineNumber": 390
          },
          {
            "text": "\t\t\t\ty: chosenY,",
            "lineNumber": 391
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 392
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 393
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 394
          },
          {
            "text": "\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);",
            "lineNumber": 395
          },
          {
            "text": "\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 396
          },
          {
            "text": "\t\t} else if (outNode) {",
            "lineNumber": 397
          },
          {
            "text": "\t\t\t(outNode as { x: number; y: number }).x = chosenX;",
            "lineNumber": 398
          },
          {
            "text": "\t\t\t(outNode as { x: number; y: number }).y = chosenY;",
            "lineNumber": 399
          },
          {
            "text": "\t\t}",
            "lineNumber": 400
          },
          {
            "text": "\t\tconst hasOutputEdge = data.edges.some(",
            "lineNumber": 401
          },
          {
            "text": "\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 402
          },
          {
            "text": "\t\t);",
            "lineNumber": 403
          },
          {
            "text": "\t\tif (!hasOutputEdge) {",
            "lineNumber": 404
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 405
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 406
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 407
          },
          {
            "text": "\t\t\t\ttoNode: outId,",
            "lineNumber": 408
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 409
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 410
          },
          {
            "text": "\t\t}",
            "lineNumber": 411
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 412
          },
          {
            "text": "\t}",
            "lineNumber": 413
          },
          {
            "lineNumber": 414
          },
          {
            "text": "\tconst newNodeId = randomId();",
            "lineNumber": 415
          },
          {
            "text": "\tconst newTextNode: CanvasTextData = {",
            "lineNumber": 416
          },
          {
            "text": "\t\tid: newNodeId,",
            "lineNumber": 417
          },
          {
            "text": "\t\ttype: \"text\",",
            "lineNumber": 418
          },
          {
            "text": "\t\ttext,",
            "lineNumber": 419
          },
          {
            "text": "\t\tx: chosenX,",
            "lineNumber": 420
          },
          {
            "text": "\t\ty: chosenY,",
            "lineNumber": 421
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 422
          },
          {
            "text": "\t\theight,",
            "lineNumber": 423
          },
          {
            "text": "\t\tcolor: greenColor,",
            "lineNumber": 424
          },
          {
            "text": "\t};",
            "lineNumber": 425
          },
          {
            "text": "\tdata.nodes.push(newTextNode);",
            "lineNumber": 426
          },
          {
            "text": "\tdata.edges.push({",
            "lineNumber": 427
          },
          {
            "text": "\t\tid: randomId(),",
            "lineNumber": 428
          },
          {
            "text": "\t\tfromNode: sourceNode.id,",
            "lineNumber": 429
          },
          {
            "lineNumber": 432
          },
          {
            "text": "}",
            "lineNumber": 433,
            "isSignature": true
          }
        ]
      },
      "score": 0.1879052072763443
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/settings.ts",
        "range": {
          "startPosition": {
            "line": 17,
            "column": 2
          },
          "endPosition": {
            "line": 33,
            "column": 1
          }
        },
        "contents": "/** Model roles that use an Ollama model and support an optional custom label. */\nconst MODEL_ROLES: NodeRole[] = [\"orange\", \"purple\", \"red\"];\n\n/** All roles that have a configurable node color. Canonical display order: primary  secondary  tertiary, then Python, Comment, Output. */\nexport const COLOR_ROLES: NodeRole[] = [\"orange\", \"purple\", \"red\", \"blue\", \"yellow\", \"green\"];\n\n/** Human-readable names for conflict alerts (one-to-one color mapping). */\nconst ROLE_DISPLAY_NAMES: Record&lt;NodeRole, string&gt; = {\n\torange: \"Primary model\"\n,\n};",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Model roles that use an Ollama model and support an optional custom label. */",
            "lineNumber": 20
          },
          {
            "text": "const MODEL_ROLES: NodeRole[] = [\"orange\", \"purple\", \"red\"];",
            "lineNumber": 21
          },
          {
            "lineNumber": 22
          },
          {
            "text": "/** All roles that have a configurable node color. Canonical display order: primary  secondary  tertiary, then Python, Comment, Output. */",
            "lineNumber": 23
          },
          {
            "text": "export const COLOR_ROLES: NodeRole[] = [\"orange\", \"purple\", \"red\", \"blue\", \"yellow\", \"green\"];",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "/** Human-readable names for conflict alerts (one-to-one color mapping). */",
            "lineNumber": 26
          },
          {
            "text": "const ROLE_DISPLAY_NAMES: Record&lt;NodeRole, string&gt; = {",
            "lineNumber": 27
          },
          {
            "text": "\torange: \"Primary model\"",
            "lineNumber": 28
          },
          {
            "text": ",",
            "lineNumber": 33
          },
          {
            "text": "};",
            "lineNumber": 34
          }
        ]
      },
      "score": 0.18659520149230957
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/settings.ts",
        "range": {
          "startPosition": {
            "line": 344
          },
          "endPosition": {
            "line": 436,
            "column": 1
          }
        },
        "contents": "export class ZettelSettingTab extends PluginSettingTab {\n\n\n\tdisplay(): void {\n\t\tconst {containerEl} = this;\n\t\tcontainerEl.empty();\n\t\tconst s = this.plugin.settings;\n\n\t\t/*\n\t\t * UX philosophy for this tab:\n\t\t * - Group by concept, not by control type: each \"model\" is one place (model + label + color).\n\t\t * - Progressive disclosure: collapsible blocks so primary is visible by default; secondary/tertiary can stay collapsed.\n\t\t * - Summary shows current choice when collapsed (e.g. \"Primary model  llama2\") so users can scan without expanding.\n\t\t * - Execution first (what runs), then Display (how it looks for non-model nodes and labels).\n\t\t */\n\n\t\t// How to run: one-line hint\n\t\tconst hint = containerEl.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });\n\t\thint.setText(\"Right-click a node on the canvas and choose Run node or Run chain.\");\n\n\t\t// Execution: model blocks (each: model + label + color) then Python\n\t\tconst executionSection = containerEl.createDiv({ cls: \"ztb-settings-section\" });\n\t\texecutionSection.createEl(\"h4\", { text: \"Execution\", cls: \"ztb-section-title\" });\n\t\tconst ollamaContainer = executionSection.createDiv({ cls: \"ztb-ollama-settings\" });\n\t\tconst loadingEl = ollamaContainer.createDiv({ cls: \"ztb-ollama-loading\" });\n\t\tloadingEl.setText(\"Loading Ollama models\");\n\t\t(async () =&gt; {\n\t\t\tconst models = await fetchOllamaModels();\n\t\t\tloadingEl.remove();\n\t\t\tif (models.length === 0) {\n\t\t\t\tconst fallback = ollamaContainer.createDiv({ cls: \"ztb-ollama-fallback\" });\n\t\t\t\tfallback.createEl(\"p\", { text: \"Ollama not reachable or no models. Enter model names manually.\" });\n\t\t\t}\n\t\t\t// One collapsible block per model role: primary (expanded), secondary and tertiary (collapsed)\n\t\t\taddModelBlock(ollamaContainer, \"orange\", models.length === 0 ? null : models, this.plugin);\n\t\t\taddModelBlock(ollamaContainer, \"purple\", models.length === 0 ? null : models, this.plugin);\n\t\t\taddModelBlock(ollamaContainer, \"red\", models.length === 0 ? null : models, this.plugin);\n\t\t})();\n\n\t\tnew Setting(executionSection)\n\t\t\t.setName(\"Python path\")\n\n\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 345,
                "column": 1
              },
              "endPosition": {
                "line": 345,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 345,
                "column": 8
              },
              "endPosition": {
                "line": 346,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export class ZettelSettingTab extends PluginSettingTab {",
            "lineNumber": 345,
            "isSignature": true
          },
          {
            "lineNumber": 351
          },
          {
            "lineNumber": 352
          },
          {
            "text": "\tdisplay(): void {",
            "lineNumber": 353
          },
          {
            "text": "\t\tconst {containerEl} = this;",
            "lineNumber": 354
          },
          {
            "text": "\t\tcontainerEl.empty();",
            "lineNumber": 355
          },
          {
            "text": "\t\tconst s = this.plugin.settings;",
            "lineNumber": 356
          },
          {
            "lineNumber": 357
          },
          {
            "text": "\t\t/*",
            "lineNumber": 358
          },
          {
            "text": "\t\t * UX philosophy for this tab:",
            "lineNumber": 359
          },
          {
            "text": "\t\t * - Group by concept, not by control type: each \"model\" is one place (model + label + color).",
            "lineNumber": 360
          },
          {
            "text": "\t\t * - Progressive disclosure: collapsible blocks so primary is visible by default; secondary/tertiary can stay collapsed.",
            "lineNumber": 361
          },
          {
            "text": "\t\t * - Summary shows current choice when collapsed (e.g. \"Primary model  llama2\") so users can scan without expanding.",
            "lineNumber": 362
          },
          {
            "text": "\t\t * - Execution first (what runs), then Display (how it looks for non-model nodes and labels).",
            "lineNumber": 363
          },
          {
            "text": "\t\t */",
            "lineNumber": 364
          },
          {
            "lineNumber": 365
          },
          {
            "text": "\t\t// How to run: one-line hint",
            "lineNumber": 366
          },
          {
            "text": "\t\tconst hint = containerEl.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });",
            "lineNumber": 367
          },
          {
            "text": "\t\thint.setText(\"Right-click a node on the canvas and choose Run node or Run chain.\");",
            "lineNumber": 368
          },
          {
            "lineNumber": 369
          },
          {
            "text": "\t\t// Execution: model blocks (each: model + label + color) then Python",
            "lineNumber": 370
          },
          {
            "text": "\t\tconst executionSection = containerEl.createDiv({ cls: \"ztb-settings-section\" });",
            "lineNumber": 371
          },
          {
            "text": "\t\texecutionSection.createEl(\"h4\", { text: \"Execution\", cls: \"ztb-section-title\" });",
            "lineNumber": 372
          },
          {
            "text": "\t\tconst ollamaContainer = executionSection.createDiv({ cls: \"ztb-ollama-settings\" });",
            "lineNumber": 373
          },
          {
            "text": "\t\tconst loadingEl = ollamaContainer.createDiv({ cls: \"ztb-ollama-loading\" });",
            "lineNumber": 374
          },
          {
            "text": "\t\tloadingEl.setText(\"Loading Ollama models\");",
            "lineNumber": 375
          },
          {
            "text": "\t\t(async () =&gt; {",
            "lineNumber": 376
          },
          {
            "text": "\t\t\tconst models = await fetchOllamaModels();",
            "lineNumber": 377
          },
          {
            "text": "\t\t\tloadingEl.remove();",
            "lineNumber": 378
          },
          {
            "text": "\t\t\tif (models.length === 0) {",
            "lineNumber": 379
          },
          {
            "text": "\t\t\t\tconst fallback = ollamaContainer.createDiv({ cls: \"ztb-ollama-fallback\" });",
            "lineNumber": 380
          },
          {
            "text": "\t\t\t\tfallback.createEl(\"p\", { text: \"Ollama not reachable or no models. Enter model names manually.\" });",
            "lineNumber": 381
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 382
          },
          {
            "text": "\t\t\t// One collapsible block per model role: primary (expanded), secondary and tertiary (collapsed)",
            "lineNumber": 383
          },
          {
            "text": "\t\t\taddModelBlock(ollamaContainer, \"orange\", models.length === 0 ? null : models, this.plugin);",
            "lineNumber": 384
          },
          {
            "text": "\t\t\taddModelBlock(ollamaContainer, \"purple\", models.length === 0 ? null : models, this.plugin);",
            "lineNumber": 385
          },
          {
            "text": "\t\t\taddModelBlock(ollamaContainer, \"red\", models.length === 0 ? null : models, this.plugin);",
            "lineNumber": 386
          },
          {
            "text": "\t\t})();",
            "lineNumber": 387
          },
          {
            "lineNumber": 388
          },
          {
            "text": "\t\tnew Setting(executionSection)",
            "lineNumber": 389
          },
          {
            "text": "\t\t\t.setName(\"Python path\")",
            "lineNumber": 390
          },
          {
            "lineNumber": 391
          },
          {
            "lineNumber": 398
          },
          {
            "text": "\t}",
            "lineNumber": 436
          },
          {
            "text": "}",
            "lineNumber": 437,
            "isSignature": true
          }
        ]
      },
      "score": 0.18518173694610596
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 31,
            "column": 104
          }
        },
        "contents": "import type {App} from \"obsidian\";\nimport {\n\tEDGE_LABEL_OUTPUT,\n\tfindOutputNodeForSource,\n\tgetNodeById,\n\tgetNodeContent,\n\tgetNodeRole,\n\tgetIncomingEdgesWithLabels,\n\tgetParentIdsSortedByY,\n\tGREEN_NODE_PADDING,\n\tisOutputEdge,\n\tloadCanvasData,\n\tsaveCanvasData,\n} from \"../canvas/nodes\";\nimport type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";\nimport { parseEdgeVariableName } from \"../canvas/types\";\nimport {isTextNode} from \"../canvas/types\";\nimport type {LiveCanvas} from \"./canvasApi\";\nimport {getKernelForCanvas} from \"./kernelManager\";\nimport {ollamaGenerate} from \"./ollama\";\nimport {\n\tgetCanvasKey,\n\tgetNodeResult,\n\tsetNodeResult,\n\tsetEdgeModes,\n\tsetRunningNodeId,\n} from \"./state\";\nimport type {NodeRole, ZettelPluginSettings} from \"../settings\";\n\ntype EdgeInputMode = \"inject\" | \"concatenate\";\n\n/** True if the role is non-AI (Python or pass-through); prefer running these first for early output. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {App} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {",
            "lineNumber": 2
          },
          {
            "text": "\tEDGE_LABEL_OUTPUT,",
            "lineNumber": 3
          },
          {
            "text": "\tfindOutputNodeForSource,",
            "lineNumber": 4
          },
          {
            "text": "\tgetNodeById,",
            "lineNumber": 5
          },
          {
            "text": "\tgetNodeContent,",
            "lineNumber": 6
          },
          {
            "text": "\tgetNodeRole,",
            "lineNumber": 7
          },
          {
            "text": "\tgetIncomingEdgesWithLabels,",
            "lineNumber": 8
          },
          {
            "text": "\tgetParentIdsSortedByY,",
            "lineNumber": 9
          },
          {
            "text": "\tGREEN_NODE_PADDING,",
            "lineNumber": 10
          },
          {
            "text": "\tisOutputEdge,",
            "lineNumber": 11
          },
          {
            "text": "\tloadCanvasData,",
            "lineNumber": 12
          },
          {
            "text": "\tsaveCanvasData,",
            "lineNumber": 13
          },
          {
            "text": "} from \"../canvas/nodes\";",
            "lineNumber": 14
          },
          {
            "text": "import type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";",
            "lineNumber": 15
          },
          {
            "text": "import { parseEdgeVariableName } from \"../canvas/types\";",
            "lineNumber": 16
          },
          {
            "text": "import {isTextNode} from \"../canvas/types\";",
            "lineNumber": 17
          },
          {
            "text": "import type {LiveCanvas} from \"./canvasApi\";",
            "lineNumber": 18
          },
          {
            "text": "import {getKernelForCanvas} from \"./kernelManager\";",
            "lineNumber": 19
          },
          {
            "text": "import {ollamaGenerate} from \"./ollama\";",
            "lineNumber": 20
          },
          {
            "text": "import {",
            "lineNumber": 21
          },
          {
            "text": "\tgetCanvasKey,",
            "lineNumber": 22
          },
          {
            "text": "\tgetNodeResult,",
            "lineNumber": 23
          },
          {
            "text": "\tsetNodeResult,",
            "lineNumber": 24
          },
          {
            "text": "\tsetEdgeModes,",
            "lineNumber": 25
          },
          {
            "text": "\tsetRunningNodeId,",
            "lineNumber": 26
          },
          {
            "text": "} from \"./state\";",
            "lineNumber": 27
          },
          {
            "text": "import type {NodeRole, ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "type EdgeInputMode = \"inject\" | \"concatenate\";",
            "lineNumber": 30,
            "isSignature": true
          },
          {
            "lineNumber": 31
          },
          {
            "text": "/** True if the role is non-AI (Python or pass-through); prefer running these first for early output. */",
            "lineNumber": 32
          }
        ]
      },
      "score": 0.18018989264965057
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/state.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 25,
            "column": 1
          }
        },
        "contents": "/** Per-canvas state: NodeID -&gt; last output result string. */\nconst canvasState = new Map&lt;string, Map&lt;string, string&gt;&gt;();\n\n/** Per-canvas edge mode: EdgeID -&gt; \"inject\" | \"concatenate\" (shown in floating label under edge). */\nconst edgeModeState = new Map&lt;string, Map&lt;string, \"inject\" | \"concatenate\"&gt;&gt;();\n\n/** Node currently running (waiting for AI/kernel) per canvas; used to show \"running\" on incoming edges. */\nconst runningNodeState = new Map&lt;string, string | null&gt;();\n\nfunction getCanvasState(canvasKey: string): Map&lt;string, string&gt; {\n\tlet map = canvasState.get(canvasKey);\n\tif (!map) {\n\t\tmap = new Map();\n\t\tcanvasState.set(canvasKey, map);\n\t}\n\treturn map;\n}\n\nfunction getEdgeModeState(canvasKey: string): Map&lt;string, \"inject\" | \"concatenate\"&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Per-canvas state: NodeID -&gt; last output result string. */",
            "lineNumber": 1
          },
          {
            "text": "const canvasState = new Map&lt;string, Map&lt;string, string&gt;&gt;();",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "/** Per-canvas edge mode: EdgeID -&gt; \"inject\" | \"concatenate\" (shown in floating label under edge). */",
            "lineNumber": 4
          },
          {
            "text": "const edgeModeState = new Map&lt;string, Map&lt;string, \"inject\" | \"concatenate\"&gt;&gt;();",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "/** Node currently running (waiting for AI/kernel) per canvas; used to show \"running\" on incoming edges. */",
            "lineNumber": 7
          },
          {
            "text": "const runningNodeState = new Map&lt;string, string | null&gt;();",
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "function getCanvasState(canvasKey: string): Map&lt;string, string&gt; {",
            "lineNumber": 10,
            "isSignature": true
          },
          {
            "text": "\tlet map = canvasState.get(canvasKey);",
            "lineNumber": 11
          },
          {
            "text": "\tif (!map) {",
            "lineNumber": 12
          },
          {
            "text": "\t\tmap = new Map();",
            "lineNumber": 13
          },
          {
            "text": "\t\tcanvasState.set(canvasKey, map);",
            "lineNumber": 14
          },
          {
            "text": "\t}",
            "lineNumber": 15
          },
          {
            "text": "\treturn map;",
            "lineNumber": 16
          },
          {
            "text": "}",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "lineNumber": 18
          },
          {
            "text": "function getEdgeModeState(canvasKey: string): Map&lt;string, \"inject\" | \"concatenate\"&gt; {",
            "lineNumber": 19,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 20
          },
          {
            "text": "}",
            "lineNumber": 26,
            "isSignature": true
          }
        ]
      },
      "score": 0.16293436288833618
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 294
          },
          "endPosition": {
            "line": 342,
            "column": 1
          }
        },
        "contents": "function rectanglesOverlap(\n\ta: { x: number; y: number; width: number; height: number },\n\tb: { x: number; y: number; width: number; height: number }\n): boolean {\n\n\t\ta.y + a.height &lt;= b.y ||\n\t\tb.y + b.height &lt;= a.y\n\t);\n}\n\n/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */\nfunction chooseOutputPositionXY(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\toutNodeId: string | null,\n\tdefaultX: number,\n\tdefaultY: number,\n\twidth: number,\n\theight: number\n): { x: number; y: number } {\n\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);\n\tif (outNodeId) excludeIds.add(outNodeId);\n\tconst box = { x: 0, y: 0, width, height };\n\tfunction tryPosition(x: number, y: number): boolean {\n\t\tbox.x = x;\n\t\tbox.y = y;\n\t\tfor (const node of data.nodes) {\n\t\t\tif (excludeIds.has(node.id)) continue;\n\t\t\t// Expand other node by buffer so we keep at least OUTPUT_COLLISION_BUFFER gap\n\t\t\tconst expanded = {\n\t\t\t\tx: node.x - OUTPUT_COLLISION_BUFFER,\n\t\t\t\ty: node.y - OUTPUT_COLLISION_BUFFER,\n\t\t\t\twidth: node.width + 2 * OUTPUT_COLLISION_BUFFER,\n\t\t\t\theight: node.height + 2 * OUTPUT_COLLISION_BUFFER,\n\t\t\t};\n\t\t\tif (rectanglesOverlap(box, expanded)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {\n\t\tconst candidateY = defaultY + dy;\n\t\tfor (const dx of xOffsets())\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "function rectanglesOverlap(",
            "lineNumber": 295,
            "isSignature": true
          },
          {
            "text": "\ta: { x: number; y: number; width: number; height: number },",
            "lineNumber": 296,
            "isSignature": true
          },
          {
            "text": "\tb: { x: number; y: number; width: number; height: number }",
            "lineNumber": 297,
            "isSignature": true
          },
          {
            "text": "): boolean {",
            "lineNumber": 298,
            "isSignature": true
          },
          {
            "lineNumber": 301
          },
          {
            "text": "\t\ta.y + a.height &lt;= b.y ||",
            "lineNumber": 302
          },
          {
            "text": "\t\tb.y + b.height &lt;= a.y",
            "lineNumber": 303
          },
          {
            "text": "\t);",
            "lineNumber": 304
          },
          {
            "text": "}",
            "lineNumber": 305,
            "isSignature": true
          },
          {
            "lineNumber": 306
          },
          {
            "text": "/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */",
            "lineNumber": 307
          },
          {
            "text": "function chooseOutputPositionXY(",
            "lineNumber": 308,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 309,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 310,
            "isSignature": true
          },
          {
            "text": "\toutNodeId: string | null,",
            "lineNumber": 311,
            "isSignature": true
          },
          {
            "text": "\tdefaultX: number,",
            "lineNumber": 312,
            "isSignature": true
          },
          {
            "text": "\tdefaultY: number,",
            "lineNumber": 313,
            "isSignature": true
          },
          {
            "text": "\twidth: number,",
            "lineNumber": 314,
            "isSignature": true
          },
          {
            "text": "\theight: number",
            "lineNumber": 315,
            "isSignature": true
          },
          {
            "text": "): { x: number; y: number } {",
            "lineNumber": 316,
            "isSignature": true
          },
          {
            "text": "\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);",
            "lineNumber": 317
          },
          {
            "text": "\tif (outNodeId) excludeIds.add(outNodeId);",
            "lineNumber": 318
          },
          {
            "text": "\tconst box = { x: 0, y: 0, width, height };",
            "lineNumber": 319
          },
          {
            "text": "\tfunction tryPosition(x: number, y: number): boolean {",
            "lineNumber": 320,
            "isSignature": true
          },
          {
            "text": "\t\tbox.x = x;",
            "lineNumber": 321
          },
          {
            "text": "\t\tbox.y = y;",
            "lineNumber": 322
          },
          {
            "text": "\t\tfor (const node of data.nodes) {",
            "lineNumber": 323
          },
          {
            "text": "\t\t\tif (excludeIds.has(node.id)) continue;",
            "lineNumber": 324
          },
          {
            "text": "\t\t\t// Expand other node by buffer so we keep at least OUTPUT_COLLISION_BUFFER gap",
            "lineNumber": 325
          },
          {
            "text": "\t\t\tconst expanded = {",
            "lineNumber": 326
          },
          {
            "text": "\t\t\t\tx: node.x - OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 327
          },
          {
            "text": "\t\t\t\ty: node.y - OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 328
          },
          {
            "text": "\t\t\t\twidth: node.width + 2 * OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 329
          },
          {
            "text": "\t\t\t\theight: node.height + 2 * OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 330
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 331
          },
          {
            "text": "\t\t\tif (rectanglesOverlap(box, expanded)) return false;",
            "lineNumber": 332
          },
          {
            "text": "\t\t}",
            "lineNumber": 333
          },
          {
            "text": "\t\treturn true;",
            "lineNumber": 334
          },
          {
            "text": "\t}",
            "lineNumber": 335,
            "isSignature": true
          },
          {
            "text": "\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {",
            "lineNumber": 336
          },
          {
            "text": "\t\tconst candidateY = defaultY + dy;",
            "lineNumber": 337
          },
          {
            "text": "\t\tfor (const dx of xOffsets())",
            "lineNumber": 338
          },
          {
            "text": "\t}",
            "lineNumber": 341
          },
          {
            "text": "}",
            "lineNumber": 343,
            "isSignature": true
          }
        ]
      },
      "score": 0.16033659875392914
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 28,
            "column": 1
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */\nlet debugNodeMenuFired = false;\n\nexport default class ZettelThinkingBoardPlugin extends Plugin {\n\tsettings: ZettelPluginSettings;\n\n\tasync onload() {\n\t\ttry {\n\t\t\tawait this.loadSettings();\n\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));\n\n\t\t\tthis.registerView(\n\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,\n\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)\n\t\t\t);\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"open-zettel-controls\",\n\t\t\t\tname: \"Open Zettel Controls\",\n\t\t\t\tcallback: () =&gt; this.activateZettelControls(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-node\",\n\t\t\t\tname: \"Run node\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-chain\",\n\t\t\t\tname: \"Run chain\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"dismiss-output\",\n\t\t\t\tname: \"Dismiss output\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 31
          },
          {
            "text": "let debugNodeMenuFired = false;",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings;",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "\tasync onload() {",
            "lineNumber": 37
          },
          {
            "text": "\t\ttry {",
            "lineNumber": 38
          },
          {
            "text": "\t\t\tawait this.loadSettings();",
            "lineNumber": 39
          },
          {
            "text": "\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));",
            "lineNumber": 40
          },
          {
            "lineNumber": 41
          },
          {
            "text": "\t\t\tthis.registerView(",
            "lineNumber": 42
          },
          {
            "text": "\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,",
            "lineNumber": 43
          },
          {
            "text": "\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)",
            "lineNumber": 44
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 47
          },
          {
            "text": "\t\t\t\tid: \"open-zettel-controls\",",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\tname: \"Open Zettel Controls\",",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.activateZettelControls(),",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 51
          },
          {
            "lineNumber": 52
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 53
          },
          {
            "text": "\t\t\t\tid: \"run-node\",",
            "lineNumber": 54
          },
          {
            "text": "\t\t\t\tname: \"Run node\",",
            "lineNumber": 55
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 56
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 57
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 58
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 59
          },
          {
            "text": "\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu",
            "lineNumber": 60
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");",
            "lineNumber": 61
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 62
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 63
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 64
          },
          {
            "lineNumber": 65
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 66
          },
          {
            "text": "\t\t\t\tid: \"run-chain\",",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t\tname: \"Run chain\",",
            "lineNumber": 68
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 69
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 70
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 71
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 72
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");",
            "lineNumber": 73
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 74
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 75
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 76
          },
          {
            "lineNumber": 77
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 78
          },
          {
            "text": "\t\t\t\tid: \"dismiss-output\",",
            "lineNumber": 79
          },
          {
            "text": "\t\t\t\tname: \"Dismiss output\",",
            "lineNumber": 80
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 81
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 82
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 83
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 84
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");",
            "lineNumber": 85
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 86
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 87
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 90
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.1583815962076187
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/PRD.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/README.md</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/state.ts</summary>

</details>
</tool-use>

---


Checking graph helpers, cycle handling, and node-content loading:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/nodes.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "cycle|inDegree|order\\.length",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "cycle|inDegree|order\\.length",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 106,
                  "content": "\tconst inDegree = new Map&lt;string, number&gt;();"
                },
                {
                  "lineNumber": 107,
                  "content": "\tfor (const id of nodeIds) inDegree.set(id, 0);"
                },
                {
                  "lineNumber": 110,
                  "content": "\t\t\tinDegree.set(e.toNode, (inDegree.get(e.toNode) ?? 0) + 1);"
                },
                {
                  "lineNumber": 114,
                  "content": "\tconst queue = [...nodeIds].filter((id) =&gt; inDegree.get(id) === 0);"
                },
                {
                  "lineNumber": 121,
                  "content": "\t\t\t\tconst d = (inDegree.get(e.toNode) ?? 0) - 1;"
                },
                {
                  "lineNumber": 122,
                  "content": "\t\t\t\tinDegree.set(e.toNode, d);"
                }
              ]
            }
          ],
          "totalLines": 6,
          "totalMatchedLines": 6
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search**  Searched web `undefined`  **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web search results for query: topological sort cycle detection DAG graph algorithm |  | Links:<br/>1. [Cycle Detection and Topological Sort Algorithm](https://labuladong.online/en/algo/data-structure/topological-sort/)<br/>2. [Detect cycle in Directed Graph using Topological Sort](https://www.geeksforgeeks.org/dsa/detect-cycle-in-directed-graph-using-topological-sort/)<br/>3. [Topological Sorting ](https://cp-algorithms.com/graph/topological-sort.html)<br/>4. [Detecting cycles in Topological sort using Kahn's algorithm (in degree / out degree)](https://stackoverflow.com/questions/67644378/detecting-cycles-in-topological-sort-using-kahns-algorithm-in-degree-out-deg)<br/>5. [How do I find a cycle in a directed graph using topological sort?](https://stackoverflow.com/questions/26589744/how-do-i-find-a-cycle-in-a-directed-graph-using-topological-sort)<br/><br/># Topological Sort, Cycle Detection, and DAGs<br/><br/>## Key Concepts<br/><br/>A **topological sort** is a linear ordering of a directed graph's vertices where every directed edge U  V has U appearing before V in the ordering.[3] This ordering is only possible for **directed acyclic graphs (DAGs)**graphs with no cycles.[3]<br/><br/>## Cycle Detection Methods<br/><br/>### DFS Approach<br/>Use depth-first search with a coloring system or state tracking:[1]<br/>- Maintain a "visiting" set and a "visited" set<br/>- If you encounter a node currently in the "visiting" set, a cycle exists<br/>- The reverse postorder of DFS traversal produces the topological sort[1]<br/><br/>### Kahn's Algorithm (BFS Approach)<br/>Uses in-degree calculation:[4]<br/>1. Compute in-degrees for all nodes<br/>2. Create a queue of all nodes with in-degree zero (safe starting points)<br/>3. Remove nodes from the queue one at a time, reducing in-degrees of dependent nodes<br/>4. **If edges remain after processing all nodes with in-degree zero, a cycle exists**[4]<br/><br/>## Why Cycles Matter<br/><br/>A topological order cannot exist if the graph contains cycles.[3] If a cycle exists between vertices a and b, then a must come before b (reachable via edges) and b must come before a (creating a contradiction).[3]<br/><br/>## Practical Applications<br/><br/>These algorithms solve real problems like course scheduling, where a cycle indicates impossible prerequisites (e.g., course A requires B, but B requires A).[1]<br/><br/>Both DFS and BFS approaches can detect cycles and produce topological sorts, though BFS (Kahn's algorithm) typically has simpler code implementation.[1] |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search**  Searched web `undefined`  **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web search results for query: rectangle collision avoidance placement algorithm 2D layout |  | Links:<br/>1. [Free Space Modeling for Placing Rectangles without Overlapping](https://www.academia.edu/84574182/Free_Space_Modeling_for_Placing_Rectangles_without_Overlapping)<br/>2. [Optimal Rectangle Packing: An Absolute Placement Approach](https://jair.org/index.php/jair/article/view/10797)<br/>3. [Efficient random rectangle placement with no overlaps](https://stackoverflow.com/questions/70110634/efficient-random-rectangle-placement-with-no-overlaps)<br/>4. [Comparing Algorithms for Dispersing Overlapping Rectangles](https://mikekling.com/comparing-algorithms-for-dispersing-overlapping-rectangles/)<br/>5. [](https://blainebell.org/publications/uist00.pdf)<br/><br/># Rectangle Collision Avoidance and Placement Algorithms<br/><br/>## Core Approaches<br/><br/>**Free Space Modeling**: A fundamental technique models free space iteratively as rectangles are placed.[1] This method computes available space independent of object size or placement method, allowing comparison of different placement strategies and identifying "largest free rectangles" for subsequent placements.[1]<br/><br/>**Absolute Placement Approach**: Advanced algorithms like optimal rectangle packing choose x-coordinates first, then transform the problem into a perfect-packing problem by adding supplementary rectangles, then branch on different y-coordinate placements.[2]<br/><br/>## Practical Algorithms<br/><br/>**Greedy Methods**: <br/>- **TopDown**: Shifts rectangles downward from the top to avoid overlaps, though this can move objects far from original positions.[4]<br/>- **WorstFirst**: Intelligently prioritizes fixing maximum overlaps first, shifting rectangles left, right, or verticallywhichever requires smaller movement.[4]<br/><br/>**Separation Behavior**: Iteratively moves overlapping rectangles apart, offering better results than basic greedy approaches.[4]<br/><br/>**Hierarchical/Spatial Partitioning**: A recursive approach divides the canvas into smaller rectangular regions after each placement, ensuring new candidates only need to fit within available subdivisions rather than checking against all existing rectangles.[3]<br/><br/>## Empty Space Representation<br/><br/>An efficient method represents 2D space by partitioning it into full (occupied) and empty categories, enabling incremental algorithms for adding/deleting rectangles and querying available spaceuseful for window management and UI layout.[5]<br/><br/>## Complexity Note<br/><br/>Finding optimal solutions (minimizing total movement) is an NP-complete problem, making practical algorithms rely on heuristics and greedy approaches.[4] |

</details>
</tool-use>

---


Checking for tests and how `runEntireCanvas` / `runChain` use the order:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "runEntireCanvas|runChain|runNode",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "runEntireCanvas|runChain|runNode",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 436,
                  "content": "export async function runNode("
                },
                {
                  "lineNumber": 454,
                  "content": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);"
                },
                {
                  "lineNumber": 469,
                  "content": "export async function runEntireCanvas("
                },
                {
                  "lineNumber": 495,
                  "content": "export async function runChain("
                }
              ]
            },
            {
              "file": "src/main.ts",
              "matches": [
                {
                  "lineNumber": 7,
                  "content": "\trunChain as runnerRunChain,"
                },
                {
                  "lineNumber": 8,
                  "content": "\trunEntireCanvas as runnerRunEntireCanvas,"
                },
                {
                  "lineNumber": 9,
                  "content": "\trunNode as runnerRunNode,"
                },
                {
                  "lineNumber": 97,
                  "content": "\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))"
                },
                {
                  "lineNumber": 100,
                  "content": "\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))"
                },
                {
                  "lineNumber": 127,
                  "content": "\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())"
                },
                {
                  "lineNumber": 218,
                  "content": "\t\t\t\t\t\titemView.addAction(\"play\", \"Run entire canvas\", () =&gt; this.runEntireCanvas());"
                },
                {
                  "lineNumber": 333,
                  "content": "\t\trunBtn.addEventListener(\"click\", () =&gt; this.runEntireCanvas());"
                },
                {
                  "lineNumber": 342,
                  "content": "\tasync runNode(nodeId: string): Promise&lt;void&gt; {"
                },
                {
                  "lineNumber": 351,
                  "content": "\tasync runChain(nodeId: string): Promise&lt;void&gt; {"
                },
                {
                  "lineNumber": 368,
                  "content": "\tasync runEntireCanvas(): Promise&lt;void&gt; {"
                }
              ]
            }
          ],
          "totalLines": 15,
          "totalMatchedLines": 15
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/state.test.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="list_dir_v2">
<details>
<summary>Tool use: **list_dir_v2**</summary>


Parameters:

```json
{
  "targetDirectory": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src"
}
```
Result:

```json
{
  "directoryTreeRoot": {
    "absPath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "childrenDirs": [
      {
        "absPath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/__mocks__",
        "childrenFiles": [
          {
            "name": "obsidian-canvas.ts"
          },
          {
            "name": "obsidian.ts"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas",
        "childrenFiles": [
          {
            "name": "canvasNodeLabels.ts"
          },
          {
            "name": "nodes.ts"
          },
          {
            "name": "types.test.ts"
          },
          {
            "name": "types.ts"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine",
        "childrenFiles": [
          {
            "name": "canvasApi.ts"
          },
          {
            "name": "kernelManager.ts"
          },
          {
            "name": "ollama.ts"
          },
          {
            "name": "pythonKernel.ts"
          },
          {
            "name": "runner.ts"
          },
          {
            "name": "state.test.ts"
          },
          {
            "name": "state.ts"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/views",
        "childrenFiles": [
          {
            "name": "ZettelControlsView.ts"
          }
        ],
        "childrenWereProcessed": true
      }
    ],
    "childrenFiles": [
      {
        "name": "main.ts"
      },
      {
        "name": "settings.ts"
      },
      {
        "name": "types.ts"
      }
    ],
    "childrenWereProcessed": true
  }
}
```
Status: **completed**


</details>
</tool-use>

---





---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "saveCanvasData|loadCanvasData",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "saveCanvasData|loadCanvasData",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 12,
                  "content": "\tloadCanvasData,"
                },
                {
                  "lineNumber": 13,
                  "content": "\tsaveCanvasData,"
                },
                {
                  "lineNumber": 214,
                  "content": "\tawait saveCanvasData(vault, canvasFilePath, data);"
                },
                {
                  "lineNumber": 443,
                  "content": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);"
                },
                {
                  "lineNumber": 475,
                  "content": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);"
                },
                {
                  "lineNumber": 502,
                  "content": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);"
                },
                {
                  "lineNumber": 532,
                  "content": "\tconst data = await loadCanvasData(vault, canvasFilePath);"
                },
                {
                  "lineNumber": 542,
                  "content": "\tawait saveCanvasData(vault, canvasFilePath, data);"
                },
                {
                  "lineNumber": 551,
                  "content": "\tconst data = await loadCanvasData(vault, canvasFilePath);"
                },
                {
                  "lineNumber": 562,
                  "content": "\tawait saveCanvasData(vault, canvasFilePath, data);"
                }
              ]
            },
            {
              "file": "src/canvas/canvasNodeLabels.ts",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "import {loadCanvasData} from \"./nodes\";"
                },
                {
                  "lineNumber": 153,
                  "content": "\tconst data = await loadCanvasData(vault, canvasFilePath);"
                },
                {
                  "lineNumber": 236,
                  "content": "\tconst data = await loadCanvasData(vault, canvasFilePath);"
                }
              ]
            },
            {
              "file": "src/canvas/nodes.ts",
              "matches": [
                {
                  "lineNumber": 15,
                  "content": "export async function loadCanvasData(vault: Vault, filePath: string): Promise&lt;CanvasData | null&gt; {"
                },
                {
                  "lineNumber": 27,
                  "content": "export async function saveCanvasData(vault: Vault, filePath: string, data: CanvasData): Promise&lt;boolean&gt; {"
                }
              ]
            }
          ],
          "totalLines": 15,
          "totalMatchedLines": 15
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.test.ts</summary>

</details>
</tool-use>

---


Checking how the runner is invoked from main to confirm the workflow:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts</summary>

</details>
</tool-use>

---


Creating the code review plan, README update, and screenshot examples.


---

<tool-use data-tool-type="unknown" data-tool-name="create_plan">
<details>
<summary>Tool use: **create_plan**</summary>


Parameters:

```json
{
  "plan": "# Code review: algorithms, robustness, README and screenshot examples\n\n## 1. Algorithms in use\n\n### Graph execution order (which nodes to resolve)\n\n- **What you have:** [runner.ts](src/engine/runner.ts) uses **Kahn's algorithm** (in-degree BFS) for topological sort:\n  - &#96;getRootIds&#96;  roots (no incoming exec edges)\n  - &#96;topologicalOrderToTarget&#96; / &#96;topologicalOrderFull&#96;  collect node set (BFS from target or from roots), then &#96;topologicalSort&#96; with in-degrees and a queue\n  - Tie-breaking: &#96;sortQueueByNonAIFirst&#96; (Python/yellow before orange/purple/red), then by &#96;y&#96;\n- **Verdict:** This is the standard approach for DAG execution order. No need to replace it with a different algorithm.\n\n- **Gap:** There is **no cycle detection**. In Kahn's algorithm, if the graph has a cycle, nodes in the cycle never reach in-degree 0, so they are never pushed to the queue. Your &#96;order&#96; array can therefore be **shorter** than the collected &#96;nodeIds&#96;, and you still return it and run only that subset. Result: **Run Chain / Run entire canvas can succeed while silently skipping nodes that lie in a cycle**, with no user-visible error.\n- **Standard fix:** After the BFS loop in &#96;topologicalSort&#96;, check &#96;order.length !== nodeIds.size&#96;. If unequal, the subgraph contains a cycle; return an error or a clear sentinel instead of a partial order, and surface a message (e.g. Execution graph contains a cycle; fix connections and try again).\n\n### Collision avoidance (output box placement)\n\n- **What you have:** [runner.ts](src/engine/runner.ts) (lines 284343): **greedy offset grid**:\n  - Default position: below source, same x.\n  - Try positions in order: for each vertical step (0, 60,  up to 400 px), try horizontal offsets (0, 80, 160,  up to 500 px) via &#96;xOffsets()&#96;.\n  - Overlap test: axis-aligned rectangles with an expanded buffer (24 px) via &#96;rectanglesOverlap&#96;.\n  - Fallback: if no candidate is free, you return the default (defaultX, defaultY), which **may still overlap**.\n- **Verdict:** For place one new box avoiding existing nodes, this is a reasonable heuristic (similar to a spiral or grid search). There are more advanced options (e.g. disperse overlapping rectangles, free-space modeling) but they are usually for many boxes or optimal layout; your approach is appropriate for the single output-node use case.\n- **Small robustness issue:** When every candidate in the search radius overlaps, you still return the default position. Consider either extending the search (e.g. increase max vertical/horizontal) or documenting that output may overlap in dense layouts.\n\n---\n\n## 2. Robustness issues in the workflow\n\n| Issue | Location | Severity | Suggestion |\n|-------|----------|----------|------------|\n| **Cycles not detected** | &#96;topologicalSort&#96; in [runner.ts](src/engine/runner.ts) | High | After the BFS loop, if &#96;order.length !== nodeIds.size&#96;, treat as cycle and return error (and surface in Run Chain / Run entire canvas). |\n| **Output node match ambiguity** | &#96;findOutputNodeForSource&#96; in [types.ts](src/canvas/types.ts) | Medium | Position fallback uses first green in y range and same x (50). With two sources stacked vertically, the same green could match the wrong source. Prefer the green whose center is **closest** to &#96;expectedY&#96; for this source (minimize &#96;\\|node.y - expectedY\\|&#96;) among candidates. |\n| **Save failure not surfaced** | &#96;saveCanvasData&#96; in [nodes.ts](src/canvas/nodes.ts) returns &#96;boolean&#96;; callers in [runner.ts](src/engine/runner.ts) (e.g. &#96;updateEdgeLabelsAndSave&#96;, &#96;dismissOutput&#96;, &#96;dismissAllOutput&#96;) dont check it | Low | Either check return and show a Notice on failure, or document that save errors are not user-visible. |\n| **Data reload** | &#96;runChain&#96; / &#96;runEntireCanvas&#96; load canvas once and pass the same &#96;data&#96; reference through the loop; &#96;ensureOutputNodeAndEdge&#96; mutates it | None | Correct: mutations are visible to subsequent nodes; no need to reload. |\n\n---\n\n## 3. README updates to make\n\n- **Add a short Behaviour and limitations (or Notes) subsection** so users and contributors know:\n  - Execution graph must be a **DAG** (no cycles); if a cycle exists, Run Chain / Run entire canvas may complete without running all nodes (and a future version will surface an error).\n  - Output (green) node placement uses collision avoidance below the source; in very dense layouts it may still overlap (optional one-line note).\n- **Add a Screenshot examples (or Example canvases) subsection** that points to the mock-ups below and suggests when to use each for docs or marketing.\n\n---\n\n## 4. Example canvases to mock up for screenshots\n\nUse these as one-page canvas layouts you can build in Obsidian (with the plugin) and screenshot.\n\n1. **Simple chain (quick start)**  \n   - **Layout:** One Orange  one Blue  one Green (auto).  \n   - **Content:** Orange: Write a haiku about rust. Blue: &#96;print(len(input.split()))&#96; (or similar).  \n   - **Use:** README Quick Start and Run chain explanation.\n\n2. **Edge variable injection**  \n   - **Layout:** Orange  (edge label &#96;draft&#96;)  Purple; Purple note: Critique this draft:\\n\\n{{var:draft}}\\n\\nBe concise.  \n   - **Use:** README Edge variable injection section; screenshot showing edge label and Purple output with (injected) on the edge after run.\n\n3. **Collision avoidance**  \n   - **Layout:** Two columns: left column one Orange with a Green below it; right column another Orange, with a Green placed so it would overlap the default position of the right Oranges output. Run the right Orange and show the new Green placed to the side or below without overlapping.  \n   - **Use:** Docs or PRD Auto-layout / collision check behaviour.\n\n4. **Multi-root / branching**  \n   - **Layout:** Two roots (e.g. Orange A and Orange B) each feeding into a single Blue node (or two Blues merging into one). Run entire canvas.  \n   - **Use:** Show that all roots are run and execution order is correct (topological order from all roots).\n\n5. **Python state (persistent kernel)**  \n   - **Layout:** Blue A: &#96;memory = []&#96;  Blue B: &#96;memory.append(input); obsidian_log(str(len(memory)))&#96;.  \n   - **Use:** README Advanced: Python State and side panel console with &#96;obsidian_log&#96; output.\n\n6. **Dismiss output**  \n   - **Layout:** Any canvas with several Green output nodes.  \n   - **Screenshot:** Context menu on a node showing Dismiss output, and/or toolbar Dismiss all output with before/after.  \n   - **Use:** README or settings/UX section.\n\nOptional (for future cycle-detection work):\n\n7. **Cycle (current behaviour)**  \n   - **Layout:** A  B  C  A (execution edges only).  \n   - **Screenshot (current):** After Run entire canvas, only a subset of nodes run (or none), with no error.  \n   - **Use:** Before/after for cycle detection improvement in release notes or PRD.\n\n---\n\n## 5. Summary\n\n- **Algorithms:** Keep Kahns topological sort; add cycle detection by comparing &#96;order.length&#96; to &#96;nodeIds.size&#96; and surface an error. Keep the current collision-avoidance heuristic; optionally extend search or document overlap in dense layouts.\n- **Robustness:** Fix cycle handling (high), tighten output-node matching when multiple greens are in range (medium), optionally surface save failures (low).\n- **README:** Add behaviour/limitations (DAG, optional collision note) and a Screenshot examples subsection referencing the mock-ups above.\n- **Screenshots:** Mock up the six (or seven) example canvases and use them in README and docs as suggested.\n",
  "name": "Code review and README",
  "overview": "Code review of collision avoidance and graph resolution logic, robustness findings, README updates, and concrete screenshot examples for the Zettel Thinking Board plugin."
}
```
Additional data:

```json
{
  "reviewData": {
    "status": "Requested",
    "selectedOption": "none",
    "isShowingInput": false
  },
  "planUri": "file:///Users/caffae/.cursor/plans/code_review_and_readme_fb5308de.plan.md",
  "hasOpenedEditor": true
}
```
Result:

```json
{
  "rejected": {}
}
```
Status: **completed**


</details>
</tool-use>

---

_**User**_

Implement the plan as specified, it is attached for your reference. Do NOT edit the plan file itself.

To-do's from the plan have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the to-dos.

---

_**Agent (model default, mode Agent)**_

Implementing the plan: locating existing todos and starting with the first task.


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "todo|Todo|TODO",
  "path": "/Users/caffae/.cursor/plans",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "todo|Todo|TODO",
  "path": "/Users/caffae/.cursor/plans",
  "outputMode": "content",
  "totalFiles": 15,
  "totalMatches": 15,
  "topFiles": [
    {
      "uri": "../../../../../.cursor/plans/code_review_and_readme_fb5308de.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/canvas_run_and_collision_avoidance_6b16b8c7.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/edge_label_lower_smaller_and_state_colors_6fd00df9.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/fix_preset_color_mappings_d96125c4.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/fix_empty_color_swatches_adf69498.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/output_edge_and_replace_green_node_6ae55a7d.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/edge_label_parse_for_rerun_c44caa36.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/settings_labels_and_node_context_menu_41f843c9.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/plugin_load_fix_and_test_automation_bd429fb3.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/prd_analysis_and_doubts_64d99f16.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/apple-notes-memory-auto-sorting_dce7a88a.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/sentence_case_ui_text_0d330476.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/add_adjustable_color_range_settings_97741b57.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/dark_mode_color_palette_optimization_b8ef91a3.plan.md",
      "matchCount": 1
    },
    {
      "uri": "../../../../../.cursor/plans/fix_linting_and_style_issues_2882bf7d.plan.md",
      "matchCount": 1
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/.cursor/plans/code_review_and_readme_fb5308de.plan.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

Implementing the plan: adding todos and starting with cycle detection.


---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write**  Todo List</summary>

- [-] Add cycle detection in topologicalSort and surface in runChain/runEntireCanvas
- [ ] Fix findOutputNodeForSource to prefer green closest to expectedY
- [ ] Check saveCanvasData return and show Notice on failure
- [ ] README: add Behaviour and limitations + Screenshot examples

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

Implementing cycle detection: making `topologicalSort` return a result type and updating callers.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---



---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---



---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write**  Todo List</summary>

- [x] Add cycle detection in topologicalSort and surface in runChain/runEntireCanvas
- [-] Fix findOutputNodeForSource to prefer green closest to expectedY
- [ ] Check saveCanvasData return and show Notice on failure
- [ ] README: add Behaviour and limitations + Screenshot examples

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts</summary>

</details>

</tool-use>

---

Implementing save-failure handling: checking where `updateEdgeLabelsAndSave` is called and adding an `app` parameter so we can show a Notice.


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "updateEdgeLabelsAndSave|dismissOutput|dismissAllOutput",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "updateEdgeLabelsAndSave|dismissOutput|dismissAllOutput",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "outputMode": "content",
  "totalFiles": 2,
  "totalMatches": 15,
  "topFiles": [
    {
      "uri": "src/engine/runner.ts",
      "matchCount": 7
    },
    {
      "uri": "src/main.ts",
      "matchCount": 8
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write**  Todo List</summary>

- [x] Add cycle detection in topologicalSort and surface in runChain/runEntireCanvas
- [x] Fix findOutputNodeForSource to prefer green closest to expectedY
- [-] Check saveCanvasData return and show Notice on failure
- [ ] README: add Behaviour and limitations + Screenshot examples

</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

The string to replace was not found in the file.

---



---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "updateEdgeLabelsAndSave",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "updateEdgeLabelsAndSave",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts",
  "outputMode": "content",
  "totalFiles": 1,
  "totalMatches": 5,
  "topFiles": [
    {
      "uri": "src/engine/runner.ts",
      "matchCount": 5
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

Updating `dismissOutput` and `dismissAllOutput` to accept `app` and show a Notice on save failure:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---



---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts</summary>

</details>

</tool-use>

---

Removing the unused `app` parameter from `dismissOutput` and `dismissAllOutput`; we only need the Notice.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts</summary>

</details>

</tool-use>

---

Removing the unused `app` parameter from `updateEdgeLabelsAndSave`.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---



---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write**  Todo List</summary>

- [x] Add cycle detection in topologicalSort and surface in runChain/runEntireCanvas
- [x] Fix findOutputNodeForSource to prefer green closest to expectedY
- [x] Check saveCanvasData return and show Notice on failure
- [-] README: add Behaviour and limitations + Screenshot examples

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2**  Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/README.md</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2**  Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/README.md</summary>

</details>

</tool-use>

---

Running tests and lint to verify everything works:


---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2**  Run command: cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run test 2>&1</summary>

```bash
cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run test 2>&1
```

```

&gt; zettel-thinking-board@1.0.0 test
&gt; vitest run


 RUN  v1.6.1 /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board

  src/engine/state.test.ts  (7 tests) 2ms
  src/canvas/types.test.ts  (27 tests) 5ms

 Test Files  2 passed (2)
      Tests  34 passed (34)
   Start at  18:00:44
   Duration  272ms (transform 70ms, setup 0ms, collect 91ms, tests 7ms, environment 0ms, prepare 105ms)


```
</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts",
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts",
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
    },
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts"
    },
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---



---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write**  Todo List</summary>

- [x] Add cycle detection in topologicalSort and surface in runChain/runEntireCanvas
- [x] Fix findOutputNodeForSource to prefer green closest to expectedY
- [x] Check saveCanvasData return and show Notice on failure
- [x] README: add Behaviour and limitations + Screenshot examples

</details>
</tool-use>

---

Summary of what was implemented:

**1. Cycle detection (runner.ts)**  
- Introduced `TopoResult = { order: string[] } | { cycle: true }`.  
- `topologicalSort` now returns `{ cycle: true }` when `order.length !== nodeIds.size` after Kahns algorithm.  
- `topologicalOrderToTarget` and `topologicalOrderFull` return `TopoResult`.  
- `runChain` and `runEntireCanvas` check for cycle and return `{ ok: false, message: "Execution graph contains a cycle; fix connections and try again." }` so the UI can show a Notice.

**2. Output node match (types.ts)**  
- `findOutputNodeForSource` position fallback no longer returns the first green in y-range.  
- It collects all candidate green nodes (same x 50, y in range) and returns the one whose center Y is closest to `expectedY` for the source, avoiding wrong matches when sources are stacked.

**3. Save failure feedback (runner.ts + Notice)**  
- `updateEdgeLabelsAndSave`: checks `saveCanvasData` return value and shows `new Notice("Failed to save canvas.")` on failure.  
- `dismissOutput` and `dismissAllOutput`: same check and Notice.  
- `Notice` is imported from `obsidian` in `runner.ts`. No API changes for callers.

**4. README**  
- **Behaviour and limitations:** Execution graph must be a DAG (cycles produce the new error message); green nodes use collision avoidance and may still overlap in very dense layouts.  
- **Screenshot examples:** Six example canvases with layout/content and suggested use (Quick Start, edge variables, collision, multi-root, Python state, dismiss output).

Tests: 34 passing. Lint: clean. The plan file was not modified.

---

