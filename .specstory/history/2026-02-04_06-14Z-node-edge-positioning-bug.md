<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 31a3e407-8c90-414e-9289-004a5de2ff4f (2026-02-04 06:14Z) -->

# Node edge positioning bug (2026-02-04 06:14Z)

_**User**_

There is a bug with the edges and the position of the nodes, there is a distance between the end of the arrow and the edge of the note. I believe there is a problem with how we are using the absolute position, instead of the relative position. Please check past conversations because this bug has reappeared. 

---

_**Agent (model default, mode Agent)**_

Searching the codebase for how edges and node positions (absolute vs relative) are computed so we can form hypotheses and add instrumentation.


---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Where are edge positions or arrow endpoints calculated for canvas nodes?",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 133,
            "column": 50
          },
          "endPosition": {
            "line": 168,
            "column": 125
          }
        },
        "contents": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */\nexport function findOutputNodeForSource(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\tsettings: ZettelPluginSettings\n): string | null {\n\tconst outputEdge = data.edges.find(\n\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t);\n\tif (outputEdge) return outputEdge.toNode;\n\tconst source = getNodeById(data, sourceNodeId);\n\tif (!source) return null;\n\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);\n\tif (!greenColor) return null;\n\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;\n\tconst toleranceAbove = 30; // allow small layout drift above default\n\tconst candidates: { id: string; centerY: number }[] = [];\n\tfor (const node of data.nodes) {\n\t\tif (node.id === sourceNodeId) continue;\n\t\tif (normalizeColor(node.color) !== greenColor) continue;\n\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;\n\t\tif (node.y &lt; expectedY - toleranceAbove || node.y &gt; expectedY + OUTPUT_POSITION_FALLBACK_MAX_Y) continue;\n\t\tconst centerY = node.y + (node.height ?? 0) / 2;\n\t\tcandidates.push({ id: node.id, centerY });\n\t}\n\tif (candidates.length === 0) return null;\n\t// Prefer the green whose center is closest to expectedY (avoids wrong match when sources are stacked)\n\tconst best = candidates.reduce((a, b) =&gt;\n\t\tMath.abs(a.centerY - expectedY) &lt;= Math.abs(b.centerY - expectedY) ? a : b\n\t);\n\treturn best.id;\n}\n\n/** Find the node id for an auxiliary edge from source with the given label (e.g. EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
            "lineNumber": 136
          },
          {
            "text": "export function findOutputNodeForSource(",
            "lineNumber": 137,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 138,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 139,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 140,
            "isSignature": true
          },
          {
            "text": "): string | null {",
            "lineNumber": 141,
            "isSignature": true
          },
          {
            "text": "\tconst outputEdge = data.edges.find(",
            "lineNumber": 142
          },
          {
            "text": "\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 143
          },
          {
            "text": "\t);",
            "lineNumber": 144
          },
          {
            "text": "\tif (outputEdge) return outputEdge.toNode;",
            "lineNumber": 145
          },
          {
            "text": "\tconst source = getNodeById(data, sourceNodeId);",
            "lineNumber": 146
          },
          {
            "text": "\tif (!source) return null;",
            "lineNumber": 147
          },
          {
            "text": "\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);",
            "lineNumber": 148
          },
          {
            "text": "\tif (!greenColor) return null;",
            "lineNumber": 149
          },
          {
            "text": "\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;",
            "lineNumber": 150
          },
          {
            "text": "\tconst toleranceAbove = 30; // allow small layout drift above default",
            "lineNumber": 151
          },
          {
            "text": "\tconst candidates: { id: string; centerY: number }[] = [];",
            "lineNumber": 152
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 153
          },
          {
            "text": "\t\tif (node.id === sourceNodeId) continue;",
            "lineNumber": 154
          },
          {
            "text": "\t\tif (normalizeColor(node.color) !== greenColor) continue;",
            "lineNumber": 155
          },
          {
            "text": "\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;",
            "lineNumber": 156
          },
          {
            "text": "\t\tif (node.y &lt; expectedY - toleranceAbove || node.y &gt; expectedY + OUTPUT_POSITION_FALLBACK_MAX_Y) continue;",
            "lineNumber": 157
          },
          {
            "text": "\t\tconst centerY = node.y + (node.height ?? 0) / 2;",
            "lineNumber": 158
          },
          {
            "text": "\t\tcandidates.push({ id: node.id, centerY });",
            "lineNumber": 159
          },
          {
            "text": "\t}",
            "lineNumber": 160
          },
          {
            "text": "\tif (candidates.length === 0) return null;",
            "lineNumber": 161
          },
          {
            "text": "\t// Prefer the green whose center is closest to expectedY (avoids wrong match when sources are stacked)",
            "lineNumber": 162
          },
          {
            "text": "\tconst best = candidates.reduce((a, b) =&gt;",
            "lineNumber": 163
          },
          {
            "text": "\t\tMath.abs(a.centerY - expectedY) &lt;= Math.abs(b.centerY - expectedY) ? a : b",
            "lineNumber": 164
          },
          {
            "text": "\t);",
            "lineNumber": 165
          },
          {
            "text": "\treturn best.id;",
            "lineNumber": 166
          },
          {
            "text": "}",
            "lineNumber": 167,
            "isSignature": true
          },
          {
            "lineNumber": 168
          },
          {
            "text": "/** Find the node id for an auxiliary edge from source with the given label (e.g. EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING). */",
            "lineNumber": 169
          }
        ]
      },
      "score": 0.42956140637397766
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 257,
            "column": 1
          },
          "endPosition": {
            "line": 283,
            "column": 3
          }
        },
        "contents": "/** Find the path whose midpoint is closest to the given viewport point (identifies the arrow for this edge). */\nfunction findPathForEdge(containerEl: HTMLElement, targetViewportX: number, targetViewportY: number): SVGPathElement | null {\n\tconst pathEls = Array.from(containerEl.querySelectorAll(\"path.canvas-display-path\"));\n\tlet best: SVGPathElement | null = null;\n\tlet bestDist = Infinity;\n\tfor (const p of pathEls) {\n\t\tif (!(p instanceof SVGPathElement)) continue;\n\t\tconst mid = getPathMidpointViewport(p);\n\t\tconst dx = mid.x - targetViewportX;\n\t\tconst dy = mid.y - targetViewportY;\n\t\tconst d = dx * dx + dy * dy;\n\t\tif (d &lt; bestDist) {\n\t\t\tbestDist = d;\n\t\t\tbest = p;\n\t\t}\n\t}\n\treturn best;\n}\n\n/**\n * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,\n * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG\n * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Find the path whose midpoint is closest to the given viewport point (identifies the arrow for this edge). */",
            "lineNumber": 260
          },
          {
            "text": "function findPathForEdge(containerEl: HTMLElement, targetViewportX: number, targetViewportY: number): SVGPathElement | null {",
            "lineNumber": 261,
            "isSignature": true
          },
          {
            "text": "\tconst pathEls = Array.from(containerEl.querySelectorAll(\"path.canvas-display-path\"));",
            "lineNumber": 262
          },
          {
            "text": "\tlet best: SVGPathElement | null = null;",
            "lineNumber": 263
          },
          {
            "text": "\tlet bestDist = Infinity;",
            "lineNumber": 264
          },
          {
            "text": "\tfor (const p of pathEls) {",
            "lineNumber": 265
          },
          {
            "text": "\t\tif (!(p instanceof SVGPathElement)) continue;",
            "lineNumber": 266
          },
          {
            "text": "\t\tconst mid = getPathMidpointViewport(p);",
            "lineNumber": 267
          },
          {
            "text": "\t\tconst dx = mid.x - targetViewportX;",
            "lineNumber": 268
          },
          {
            "text": "\t\tconst dy = mid.y - targetViewportY;",
            "lineNumber": 269
          },
          {
            "text": "\t\tconst d = dx * dx + dy * dy;",
            "lineNumber": 270
          },
          {
            "text": "\t\tif (d &lt; bestDist) {",
            "lineNumber": 271
          },
          {
            "text": "\t\t\tbestDist = d;",
            "lineNumber": 272
          },
          {
            "text": "\t\t\tbest = p;",
            "lineNumber": 273
          },
          {
            "text": "\t\t}",
            "lineNumber": 274
          },
          {
            "text": "\t}",
            "lineNumber": 275
          },
          {
            "text": "\treturn best;",
            "lineNumber": 276
          },
          {
            "text": "}",
            "lineNumber": 277,
            "isSignature": true
          },
          {
            "lineNumber": 278
          },
          {
            "text": "/**",
            "lineNumber": 279
          },
          {
            "text": " * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,",
            "lineNumber": 280
          },
          {
            "text": " * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG",
            "lineNumber": 281
          },
          {
            "text": " * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.",
            "lineNumber": 282
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 283
          },
          {
            "text": " */",
            "lineNumber": 284
          }
        ]
      },
      "score": 0.3996666967868805
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 449,
            "column": 1
          },
          "endPosition": {
            "line": 497,
            "column": 1
          }
        },
        "contents": "/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */\nfunction chooseOutputPositionXY(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\toutNodeId: string | null,\n\tdefaultX: number,\n\tdefaultY: number,\n\twidth: number,\n\theight: number,\n\textraExcludeIds: string[] = []\n): { x: number; y: number } {\n\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);\n\tif (outNodeId) excludeIds.add(outNodeId);\n\tfor (const id of extraExcludeIds) excludeIds.add(id);\n\tconst box = { x: 0, y: 0, width, height };\n\tfunction tryPosition(x: number, y: number): boolean {\n\t\tbox.x = x;\n\t\tbox.y = y;\n\t\tfor (const node of data.nodes) {\n\t\t\tif (excludeIds.has(node.id)) continue;\n\t\t\t// Expand other node by buffer so we keep at least OUTPUT_COLLISION_BUFFER gap\n\t\t\tconst expanded = {\n\t\t\t\tx: node.x - OUTPUT_COLLISION_BUFFER,\n\t\t\t\ty: node.y - OUTPUT_COLLISION_BUFFER,\n\t\t\t\twidth: node.width + 2 * OUTPUT_COLLISION_BUFFER,\n\t\t\t\theight: node.height + 2 * OUTPUT_COLLISION_BUFFER,\n\t\t\t};\n\t\t\tif (rectanglesOverlap(box, expanded)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {\n\t\tconst candidateY = defaultY + dy;\n\t\tfor (const dx of xOffsets()) {\n\t\t\tif (tryPosition(defaultX + dx, candidateY)) return { x: defaultX + dx, y: candidateY };\n\t\t}\n\t}\n\treturn { x: defaultX, y: defaultY };\n}\n\nfunction* xOffsets(): Generator&lt;number&gt; {\n\tyield 0;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */",
            "lineNumber": 452
          },
          {
            "text": "function chooseOutputPositionXY(",
            "lineNumber": 453,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 454,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 455,
            "isSignature": true
          },
          {
            "text": "\toutNodeId: string | null,",
            "lineNumber": 456,
            "isSignature": true
          },
          {
            "text": "\tdefaultX: number,",
            "lineNumber": 457,
            "isSignature": true
          },
          {
            "text": "\tdefaultY: number,",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "\twidth: number,",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "\theight: number,",
            "lineNumber": 460,
            "isSignature": true
          },
          {
            "text": "\textraExcludeIds: string[] = []",
            "lineNumber": 461,
            "isSignature": true
          },
          {
            "text": "): { x: number; y: number } {",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);",
            "lineNumber": 463
          },
          {
            "text": "\tif (outNodeId) excludeIds.add(outNodeId);",
            "lineNumber": 464
          },
          {
            "text": "\tfor (const id of extraExcludeIds) excludeIds.add(id);",
            "lineNumber": 465
          },
          {
            "text": "\tconst box = { x: 0, y: 0, width, height };",
            "lineNumber": 466
          },
          {
            "text": "\tfunction tryPosition(x: number, y: number): boolean {",
            "lineNumber": 467,
            "isSignature": true
          },
          {
            "text": "\t\tbox.x = x;",
            "lineNumber": 468
          },
          {
            "text": "\t\tbox.y = y;",
            "lineNumber": 469
          },
          {
            "text": "\t\tfor (const node of data.nodes) {",
            "lineNumber": 470
          },
          {
            "text": "\t\t\tif (excludeIds.has(node.id)) continue;",
            "lineNumber": 471
          },
          {
            "text": "\t\t\t// Expand other node by buffer so we keep at least OUTPUT_COLLISION_BUFFER gap",
            "lineNumber": 472
          },
          {
            "text": "\t\t\tconst expanded = {",
            "lineNumber": 473
          },
          {
            "text": "\t\t\t\tx: node.x - OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 474
          },
          {
            "text": "\t\t\t\ty: node.y - OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 475
          },
          {
            "text": "\t\t\t\twidth: node.width + 2 * OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 476
          },
          {
            "text": "\t\t\t\theight: node.height + 2 * OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 477
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 478
          },
          {
            "text": "\t\t\tif (rectanglesOverlap(box, expanded)) return false;",
            "lineNumber": 479
          },
          {
            "text": "\t\t}",
            "lineNumber": 480
          },
          {
            "text": "\t\treturn true;",
            "lineNumber": 481
          },
          {
            "text": "\t}",
            "lineNumber": 482,
            "isSignature": true
          },
          {
            "text": "\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {",
            "lineNumber": 483
          },
          {
            "text": "\t\tconst candidateY = defaultY + dy;",
            "lineNumber": 484
          },
          {
            "text": "\t\tfor (const dx of xOffsets()) {",
            "lineNumber": 485
          },
          {
            "text": "\t\t\tif (tryPosition(defaultX + dx, candidateY)) return { x: defaultX + dx, y: candidateY };",
            "lineNumber": 486
          },
          {
            "text": "\t\t}",
            "lineNumber": 487
          },
          {
            "text": "\t}",
            "lineNumber": 488
          },
          {
            "text": "\treturn { x: defaultX, y: defaultY };",
            "lineNumber": 489
          },
          {
            "text": "}",
            "lineNumber": 490,
            "isSignature": true
          },
          {
            "lineNumber": 491
          },
          {
            "text": "function* xOffsets(): Generator&lt;number&gt; {",
            "lineNumber": 492,
            "isSignature": true
          },
          {
            "text": "\tyield 0;",
            "lineNumber": 493
          },
          {
            "text": "}",
            "lineNumber": 498,
            "isSignature": true
          }
        ]
      },
      "score": 0.39832574129104614
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 284
          },
          "endPosition": {
            "line": 385,
            "column": 1
          }
        },
        "contents": "export async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\n\tfor (const edge of data.edges) {\n\t\tif (isOutputEdge(edge)) continue;\n\t\tconst isRunning = runningNodeId != null &amp;&amp; edge.toNode === runningNodeId;\n\t\tconst mode = getEdgeMode(canvasKey, edge.id);\n\t\tconst state: EdgeDisplayState | null = isRunning\n\t\t\t? \"running\"\n\t\t\t: mode === \"inject\"\n\t\t\t\t? \"inject\"\n\t\t\t\t: mode === \"concatenate\"\n\t\t\t\t\t? \"concatenate\"\n\t\t\t\t\t: null;\n\t\tif (!state) continue;\n\t\tconst fromEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);\n\t\tconst toEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);\n\t\tif (!fromEl || !toEl) continue;\n\t\tconst fromCenter = getElCenter(fromEl);\n\t\tconst toCenter = getElCenter(toEl);\n\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;\n\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;\n\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);\n\t\tif (!pathEl) continue;\n\t\tconst group = pathEl.closest(\"g\");\n\t\tif (!group) continue;\n\t\tconst mid = getPathMidpointSvg(pathEl);\n\t\tconst labelGroup = document.createElementNS(SVG_NS, \"g\");\n\t\tlabelGroup.setAttribute(\"class\", EDGE_MODE_SVG_LABEL_CLASS);\n\t\tlabelGroup.setAttribute(EDGE_MODE_DATA_ATTR, edge.id);\n\t\tlabelGroup.setAttribute(EDGE_MODE_STATE_ATTR, state);\n\t\tlabelGroup.setAttribute(\"transform\", &#96;translate(${mid.x}, ${mid.y + Y_OFFSET_BELOW_PATH})&#96;);\n\t\tlabelGroup.setAttribute(\"style\", \"z-index: 100; isolation: isolate;\");\n\t\tconst textContent =\n\t\t\tstate === \"running\" ? \"…\" : state === \"inject\" ? \"(injected)\" : \"(concatenated)\";\n\t\tlet textX = 0;\n\t\tconst fontSize = state === \"running\" ? FONT_SIZE_RUNNING : FONT_SIZE;\n\t\tif (state === \"running\") {\n\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 285,
                "column": 1
              },
              "endPosition": {
                "line": 285,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 285,
                "column": 8
              },
              "endPosition": {
                "line": 292,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 285,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 286,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 287,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 288,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 289,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 290,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 291,
            "isSignature": true
          },
          {
            "lineNumber": 308
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 309
          },
          {
            "text": "\t\tif (isOutputEdge(edge)) continue;",
            "lineNumber": 310
          },
          {
            "text": "\t\tconst isRunning = runningNodeId != null &amp;&amp; edge.toNode === runningNodeId;",
            "lineNumber": 311
          },
          {
            "text": "\t\tconst mode = getEdgeMode(canvasKey, edge.id);",
            "lineNumber": 312
          },
          {
            "text": "\t\tconst state: EdgeDisplayState | null = isRunning",
            "lineNumber": 313
          },
          {
            "text": "\t\t\t? \"running\"",
            "lineNumber": 314
          },
          {
            "text": "\t\t\t: mode === \"inject\"",
            "lineNumber": 315
          },
          {
            "text": "\t\t\t\t? \"inject\"",
            "lineNumber": 316
          },
          {
            "text": "\t\t\t\t: mode === \"concatenate\"",
            "lineNumber": 317
          },
          {
            "text": "\t\t\t\t\t? \"concatenate\"",
            "lineNumber": 318
          },
          {
            "text": "\t\t\t\t\t: null;",
            "lineNumber": 319
          },
          {
            "text": "\t\tif (!state) continue;",
            "lineNumber": 320
          },
          {
            "text": "\t\tconst fromEl =",
            "lineNumber": 321
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||",
            "lineNumber": 322
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);",
            "lineNumber": 323
          },
          {
            "text": "\t\tconst toEl =",
            "lineNumber": 324
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||",
            "lineNumber": 325
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);",
            "lineNumber": 326
          },
          {
            "text": "\t\tif (!fromEl || !toEl) continue;",
            "lineNumber": 327
          },
          {
            "text": "\t\tconst fromCenter = getElCenter(fromEl);",
            "lineNumber": 328
          },
          {
            "text": "\t\tconst toCenter = getElCenter(toEl);",
            "lineNumber": 329
          },
          {
            "text": "\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;",
            "lineNumber": 330
          },
          {
            "text": "\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;",
            "lineNumber": 331
          },
          {
            "text": "\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);",
            "lineNumber": 332
          },
          {
            "text": "\t\tif (!pathEl) continue;",
            "lineNumber": 333
          },
          {
            "text": "\t\tconst group = pathEl.closest(\"g\");",
            "lineNumber": 334
          },
          {
            "text": "\t\tif (!group) continue;",
            "lineNumber": 335
          },
          {
            "text": "\t\tconst mid = getPathMidpointSvg(pathEl);",
            "lineNumber": 336
          },
          {
            "text": "\t\tconst labelGroup = document.createElementNS(SVG_NS, \"g\");",
            "lineNumber": 337
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"class\", EDGE_MODE_SVG_LABEL_CLASS);",
            "lineNumber": 338
          },
          {
            "text": "\t\tlabelGroup.setAttribute(EDGE_MODE_DATA_ATTR, edge.id);",
            "lineNumber": 339
          },
          {
            "text": "\t\tlabelGroup.setAttribute(EDGE_MODE_STATE_ATTR, state);",
            "lineNumber": 340
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"transform\", &#96;translate(${mid.x}, ${mid.y + Y_OFFSET_BELOW_PATH})&#96;);",
            "lineNumber": 341
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"style\", \"z-index: 100; isolation: isolate;\");",
            "lineNumber": 342
          },
          {
            "text": "\t\tconst textContent =",
            "lineNumber": 343
          },
          {
            "text": "\t\t\tstate === \"running\" ? \"…\" : state === \"inject\" ? \"(injected)\" : \"(concatenated)\";",
            "lineNumber": 344
          },
          {
            "text": "\t\tlet textX = 0;",
            "lineNumber": 345
          },
          {
            "text": "\t\tconst fontSize = state === \"running\" ? FONT_SIZE_RUNNING : FONT_SIZE;",
            "lineNumber": 346
          },
          {
            "text": "\t\tif (state === \"running\") {",
            "lineNumber": 347
          },
          {
            "text": "\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");",
            "lineNumber": 348
          },
          {
            "text": "}",
            "lineNumber": 386,
            "isSignature": true
          }
        ]
      },
      "score": 0.3921796977519989
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 530,
            "column": 1
          },
          "endPosition": {
            "line": 753,
            "column": 1
          }
        },
        "contents": "/** Create or replace the Green output node (and optional prompt/thinking nodes) and ensure edges from source. Mutates data only. */\nfunction ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\tconst { fullPrompt, thinking } = options;\n\tconst promptId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_PROMPT);\n\tconst thinkingId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING);\n\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);\n\n\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;\n\tconst width = Math.max(320, sourceNode.width);\n\tconst height = 180;\n\tconst defaultX = sourceNode.x;\n\tconst extraExclude = [promptId, thinkingId].filter((id): id is string =&gt; id != null);\n\n\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(\n\t\tdata,\n\t\tsourceNode.id,\n\t\toutId,\n\t\tdefaultX,\n\t\tdefaultY,\n\t\twidth,\n\t\theight,\n\t\textraExclude\n\t);\n\tconst greenColor = settings.colorGreen;\n\n\t// 1. Ensure output node\n\tlet resolvedOutputId: string;\n\tif (outId) {\n\t\tresolvedOutputId = outId;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Create or replace the Green output node (and optional prompt/thinking nodes) and ensure edges from source. Mutates data only. */",
            "lineNumber": 533
          },
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 536,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 538,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 539,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 540,
            "isSignature": true
          },
          {
            "text": "\tconst { fullPrompt, thinking } = options;",
            "lineNumber": 541
          },
          {
            "text": "\tconst promptId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_PROMPT);",
            "lineNumber": 542
          },
          {
            "text": "\tconst thinkingId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING);",
            "lineNumber": 543
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);",
            "lineNumber": 544
          },
          {
            "lineNumber": 545
          },
          {
            "text": "\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;",
            "lineNumber": 546
          },
          {
            "text": "\tconst width = Math.max(320, sourceNode.width);",
            "lineNumber": 547
          },
          {
            "text": "\tconst height = 180;",
            "lineNumber": 548
          },
          {
            "text": "\tconst defaultX = sourceNode.x;",
            "lineNumber": 549
          },
          {
            "text": "\tconst extraExclude = [promptId, thinkingId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 550
          },
          {
            "lineNumber": 551
          },
          {
            "text": "\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(",
            "lineNumber": 552
          },
          {
            "text": "\t\tdata,",
            "lineNumber": 553
          },
          {
            "text": "\t\tsourceNode.id,",
            "lineNumber": 554
          },
          {
            "text": "\t\toutId,",
            "lineNumber": 555
          },
          {
            "text": "\t\tdefaultX,",
            "lineNumber": 556
          },
          {
            "text": "\t\tdefaultY,",
            "lineNumber": 557
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 558
          },
          {
            "text": "\t\theight,",
            "lineNumber": 559
          },
          {
            "text": "\t\textraExclude",
            "lineNumber": 560
          },
          {
            "text": "\t);",
            "lineNumber": 561
          },
          {
            "text": "\tconst greenColor = settings.colorGreen;",
            "lineNumber": 562
          },
          {
            "lineNumber": 563
          },
          {
            "text": "\t// 1. Ensure output node",
            "lineNumber": 564
          },
          {
            "text": "\tlet resolvedOutputId: string;",
            "lineNumber": 565
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 566
          },
          {
            "text": "\t\tresolvedOutputId = outId;",
            "lineNumber": 567
          },
          {
            "text": "}",
            "lineNumber": 754,
            "isSignature": true
          }
        ]
      },
      "score": 0.3917430639266968
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 87,
            "column": 1
          },
          "endPosition": {
            "line": 107,
            "column": 1
          }
        },
        "contents": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */\nexport function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));\n\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withY = fromIds\n\t\t.map((id) =&gt; {\n\t\t\tconst node = nodeMap.get(id);\n\t\t\treturn node ? { id, y: node.y } : null;\n\t\t})\n\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);\n\twithY.sort((a, b) =&gt; a.y - b.y);\n\treturn withY.map((x) =&gt; x.id);\n}\n\n/** Get node by id from canvas data. */\nexport function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */",
            "lineNumber": 90
          },
          {
            "text": "export function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));",
            "lineNumber": 92
          },
          {
            "text": "\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];",
            "lineNumber": 93
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 94
          },
          {
            "text": "\tconst withY = fromIds",
            "lineNumber": 95
          },
          {
            "text": "\t\t.map((id) =&gt; {",
            "lineNumber": 96
          },
          {
            "text": "\t\t\tconst node = nodeMap.get(id);",
            "lineNumber": 97
          },
          {
            "text": "\t\t\treturn node ? { id, y: node.y } : null;",
            "lineNumber": 98
          },
          {
            "text": "\t\t})",
            "lineNumber": 99
          },
          {
            "text": "\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);",
            "lineNumber": 100
          },
          {
            "text": "\twithY.sort((a, b) =&gt; a.y - b.y);",
            "lineNumber": 101
          },
          {
            "text": "\treturn withY.map((x) =&gt; x.id);",
            "lineNumber": 102
          },
          {
            "text": "}",
            "lineNumber": 103,
            "isSignature": true
          },
          {
            "lineNumber": 104
          },
          {
            "text": "/** Get node by id from canvas data. */",
            "lineNumber": 105
          },
          {
            "text": "export function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {",
            "lineNumber": 106,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 107
          },
          {
            "text": "}",
            "lineNumber": 108,
            "isSignature": true
          }
        ]
      },
      "score": 0.38832324743270874
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 276,
            "column": 1
          },
          "endPosition": {
            "line": 385,
            "column": 1
          }
        },
        "contents": "/**\n * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,\n * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG\n * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.edges) {\n\t\tclearCanvasEdgeModeLabels(containerEl);\n\t\treturn;\n\t}\n\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).\n\tclearCanvasEdgeModeLabels(containerEl);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tconst runningNodeId = getRunningNodeId(canvasKey);\n\tconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\tconst Y_OFFSET_BELOW_PATH = 12;\n\tconst FONT_SIZE = 11;\n\tconst FONT_SIZE_RUNNING = 20;\n\tconst DOT_R = 2.5;\n\tconst DOT_R_RUNNING = 5;\n\tconst DOT_TEXT_GAP = 6;\n\tfor (const edge of data.edges) {\n\t\tif (isOutputEdge(edge)) continue;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/**",
            "lineNumber": 279
          },
          {
            "text": " * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,",
            "lineNumber": 280
          },
          {
            "text": " * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG",
            "lineNumber": 281
          },
          {
            "text": " * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.",
            "lineNumber": 282
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 283
          },
          {
            "text": " */",
            "lineNumber": 284
          },
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 285,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 286,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 287,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 288,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 289,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 290,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 291,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 292
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 293
          },
          {
            "text": "\tif (!data?.edges) {",
            "lineNumber": 294
          },
          {
            "text": "\t\tclearCanvasEdgeModeLabels(containerEl);",
            "lineNumber": 295
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 296
          },
          {
            "text": "\t}",
            "lineNumber": 297
          },
          {
            "text": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).",
            "lineNumber": 298
          },
          {
            "text": "\tclearCanvasEdgeModeLabels(containerEl);",
            "lineNumber": 299
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 300
          },
          {
            "text": "\tconst runningNodeId = getRunningNodeId(canvasKey);",
            "lineNumber": 301
          },
          {
            "text": "\tconst SVG_NS = \"http://www.w3.org/2000/svg\";",
            "lineNumber": 302
          },
          {
            "text": "\tconst Y_OFFSET_BELOW_PATH = 12;",
            "lineNumber": 303
          },
          {
            "text": "\tconst FONT_SIZE = 11;",
            "lineNumber": 304
          },
          {
            "text": "\tconst FONT_SIZE_RUNNING = 20;",
            "lineNumber": 305
          },
          {
            "text": "\tconst DOT_R = 2.5;",
            "lineNumber": 306
          },
          {
            "text": "\tconst DOT_R_RUNNING = 5;",
            "lineNumber": 307
          },
          {
            "text": "\tconst DOT_TEXT_GAP = 6;",
            "lineNumber": 308
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 309
          },
          {
            "text": "\t\tif (isOutputEdge(edge)) continue;",
            "lineNumber": 310
          },
          {
            "text": "}",
            "lineNumber": 386,
            "isSignature": true
          }
        ]
      },
      "score": 0.38184139132499695
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 67,
            "column": 1
          },
          "endPosition": {
            "line": 89,
            "column": 106
          }
        },
        "contents": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y then x (higher, then left-most). Excludes output/prompt/thinking edges. */\nexport function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withPos = edges.map((e) =&gt; {\n\t\tconst parent = nodeMap.get(e.fromNode);\n\t\tconst y = parent?.y ?? 0;\n\t\tconst x = parent?.x ?? 0;\n\t\treturn {\n\t\t\tparentId: e.fromNode,\n\t\t\tedge: e,\n\t\t\tvariableName: parseEdgeVariableName(e.label),\n\t\t\ty,\n\t\t\tx,\n\t\t};\n\t});\n\twithPos.sort((a, b) =&gt; (a.y !== b.y ? a.y - b.y : a.x - b.x));\n\treturn withPos.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));\n}\n\n/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y then x (higher, then left-most). Excludes output/prompt/thinking edges. */",
            "lineNumber": 70
          },
          {
            "text": "export function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {",
            "lineNumber": 71,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));",
            "lineNumber": 72
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 73
          },
          {
            "text": "\tconst withPos = edges.map((e) =&gt; {",
            "lineNumber": 74
          },
          {
            "text": "\t\tconst parent = nodeMap.get(e.fromNode);",
            "lineNumber": 75
          },
          {
            "text": "\t\tconst y = parent?.y ?? 0;",
            "lineNumber": 76
          },
          {
            "text": "\t\tconst x = parent?.x ?? 0;",
            "lineNumber": 77
          },
          {
            "text": "\t\treturn {",
            "lineNumber": 78
          },
          {
            "text": "\t\t\tparentId: e.fromNode,",
            "lineNumber": 79
          },
          {
            "text": "\t\t\tedge: e,",
            "lineNumber": 80
          },
          {
            "text": "\t\t\tvariableName: parseEdgeVariableName(e.label),",
            "lineNumber": 81
          },
          {
            "text": "\t\t\ty,",
            "lineNumber": 82
          },
          {
            "text": "\t\t\tx,",
            "lineNumber": 83
          },
          {
            "text": "\t\t};",
            "lineNumber": 84
          },
          {
            "text": "\t});",
            "lineNumber": 85
          },
          {
            "text": "\twithPos.sort((a, b) =&gt; (a.y !== b.y ? a.y - b.y : a.x - b.x));",
            "lineNumber": 86
          },
          {
            "text": "\treturn withPos.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));",
            "lineNumber": 87
          },
          {
            "text": "}",
            "lineNumber": 88,
            "isSignature": true
          },
          {
            "lineNumber": 89
          },
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */",
            "lineNumber": 90
          }
        ]
      },
      "score": 0.37650805711746216
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 508,
            "column": 52
          },
          "endPosition": {
            "line": 526,
            "column": 99
          }
        },
        "contents": "/** Preferred order for auxiliary edges (prompt/thinking): use left/right to avoid input (top) and output (bottom). */\nconst AUXILIARY_EDGE_SIDE_ORDER: NodeSide[] = [\"left\", \"right\", \"top\", \"bottom\"];\n\n/** Pick a side of sourceNode that is not already used by edges from/to that node. Used so prompt/thinking connect on a free side. */\nfunction chooseFreeSideForAuxiliaryEdge(data: CanvasData, sourceNodeId: string): NodeSide {\n\tconst used = new Set&lt;NodeSide&gt;();\n\tfor (const e of data.edges) {\n\t\tif (e.fromNode === sourceNodeId &amp;&amp; e.fromSide) used.add(e.fromSide as NodeSide);\n\t\tif (e.toNode === sourceNodeId &amp;&amp; e.toSide) used.add(e.toSide as NodeSide);\n\t}\n\tfor (const side of AUXILIARY_EDGE_SIDE_ORDER) {\n\t\tif (!used.has(side)) return side;\n\t}\n\treturn \"left\";\n}\n\n/** Options for ensureOutputNodeAndEdge: optional prompt and thinking to show in separate nodes. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Preferred order for auxiliary edges (prompt/thinking): use left/right to avoid input (top) and output (bottom). */",
            "lineNumber": 511
          },
          {
            "text": "const AUXILIARY_EDGE_SIDE_ORDER: NodeSide[] = [\"left\", \"right\", \"top\", \"bottom\"];",
            "lineNumber": 512
          },
          {
            "lineNumber": 513
          },
          {
            "text": "/** Pick a side of sourceNode that is not already used by edges from/to that node. Used so prompt/thinking connect on a free side. */",
            "lineNumber": 514
          },
          {
            "text": "function chooseFreeSideForAuxiliaryEdge(data: CanvasData, sourceNodeId: string): NodeSide {",
            "lineNumber": 515,
            "isSignature": true
          },
          {
            "text": "\tconst used = new Set&lt;NodeSide&gt;();",
            "lineNumber": 516
          },
          {
            "text": "\tfor (const e of data.edges) {",
            "lineNumber": 517
          },
          {
            "text": "\t\tif (e.fromNode === sourceNodeId &amp;&amp; e.fromSide) used.add(e.fromSide as NodeSide);",
            "lineNumber": 518
          },
          {
            "text": "\t\tif (e.toNode === sourceNodeId &amp;&amp; e.toSide) used.add(e.toSide as NodeSide);",
            "lineNumber": 519
          },
          {
            "text": "\t}",
            "lineNumber": 520
          },
          {
            "text": "\tfor (const side of AUXILIARY_EDGE_SIDE_ORDER) {",
            "lineNumber": 521
          },
          {
            "text": "\t\tif (!used.has(side)) return side;",
            "lineNumber": 522
          },
          {
            "text": "\t}",
            "lineNumber": 523
          },
          {
            "text": "\treturn \"left\";",
            "lineNumber": 524
          },
          {
            "text": "}",
            "lineNumber": 525,
            "isSignature": true
          },
          {
            "lineNumber": 526
          },
          {
            "text": "/** Options for ensureOutputNodeAndEdge: optional prompt and thinking to show in separate nodes. */",
            "lineNumber": 527
          }
        ]
      },
      "score": 0.36976325511932373
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 284
          },
          "endPosition": {
            "line": 385,
            "column": 1
          }
        },
        "contents": "export async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\n\t\tif (state === \"running\") {\n\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");\n\t\t\tcircle.setAttribute(\"class\", EDGE_MODE_ICON_CLASS);\n\t\t\tcircle.setAttribute(\"cx\", String(DOT_R_RUNNING + 2));\n\t\t\tcircle.setAttribute(\"cy\", String(fontSize * 0.4));\n\t\t\tcircle.setAttribute(\"r\", String(DOT_R_RUNNING));\n\t\t\tlabelGroup.appendChild(circle);\n\t\t\ttextX = DOT_R_RUNNING * 2 + DOT_TEXT_GAP;\n\t\t}\n\t\tconst textEl = document.createElementNS(SVG_NS, \"text\");\n\t\ttextEl.setAttribute(\"class\", EDGE_MODE_LABEL_CLASS);\n\t\ttextEl.setAttribute(\"x\", String(textX));\n\t\ttextEl.setAttribute(\"y\", String(fontSize * 0.35));\n\t\ttextEl.setAttribute(\"font-size\", String(fontSize));\n\t\ttextEl.setAttribute(\"text-anchor\", \"start\");\n\t\ttextEl.setAttribute(\"dominant-baseline\", \"central\");\n\t\ttextEl.textContent = textContent;\n\t\tlabelGroup.appendChild(textEl);\n\t\tgroup.appendChild(labelGroup);\n\t}\n\t// Mark output edges so their label can be styled smaller/grayed\n\tfor (const edge of data.edges) {\n\t\tif (!isOutputEdge(edge)) continue;\n\t\tconst fromEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);\n\t\tconst toEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);\n\t\tif (!fromEl || !toEl) continue;\n\t\tconst fromCenter = getElCenter(fromEl);\n\t\tconst toCenter = getElCenter(toEl);\n\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;\n\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;\n\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);\n\t\tif (!pathEl) continue;\n\t\tconst group = pathEl.closest(\"g\");\n\t\tif (group) group.classList.add(OUTPUT_EDGE_GROUP_CLASS);\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 285,
                "column": 1
              },
              "endPosition": {
                "line": 285,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 285,
                "column": 8
              },
              "endPosition": {
                "line": 292,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 285,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 286,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 287,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 288,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 289,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 290,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 291,
            "isSignature": true
          },
          {
            "lineNumber": 346
          },
          {
            "text": "\t\tif (state === \"running\") {",
            "lineNumber": 347
          },
          {
            "text": "\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");",
            "lineNumber": 348
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"class\", EDGE_MODE_ICON_CLASS);",
            "lineNumber": 349
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"cx\", String(DOT_R_RUNNING + 2));",
            "lineNumber": 350
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"cy\", String(fontSize * 0.4));",
            "lineNumber": 351
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"r\", String(DOT_R_RUNNING));",
            "lineNumber": 352
          },
          {
            "text": "\t\t\tlabelGroup.appendChild(circle);",
            "lineNumber": 353
          },
          {
            "text": "\t\t\ttextX = DOT_R_RUNNING * 2 + DOT_TEXT_GAP;",
            "lineNumber": 354
          },
          {
            "text": "\t\t}",
            "lineNumber": 355
          },
          {
            "text": "\t\tconst textEl = document.createElementNS(SVG_NS, \"text\");",
            "lineNumber": 356
          },
          {
            "text": "\t\ttextEl.setAttribute(\"class\", EDGE_MODE_LABEL_CLASS);",
            "lineNumber": 357
          },
          {
            "text": "\t\ttextEl.setAttribute(\"x\", String(textX));",
            "lineNumber": 358
          },
          {
            "text": "\t\ttextEl.setAttribute(\"y\", String(fontSize * 0.35));",
            "lineNumber": 359
          },
          {
            "text": "\t\ttextEl.setAttribute(\"font-size\", String(fontSize));",
            "lineNumber": 360
          },
          {
            "text": "\t\ttextEl.setAttribute(\"text-anchor\", \"start\");",
            "lineNumber": 361
          },
          {
            "text": "\t\ttextEl.setAttribute(\"dominant-baseline\", \"central\");",
            "lineNumber": 362
          },
          {
            "text": "\t\ttextEl.textContent = textContent;",
            "lineNumber": 363
          },
          {
            "text": "\t\tlabelGroup.appendChild(textEl);",
            "lineNumber": 364
          },
          {
            "text": "\t\tgroup.appendChild(labelGroup);",
            "lineNumber": 365
          },
          {
            "text": "\t}",
            "lineNumber": 366
          },
          {
            "text": "\t// Mark output edges so their label can be styled smaller/grayed",
            "lineNumber": 367
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 368
          },
          {
            "text": "\t\tif (!isOutputEdge(edge)) continue;",
            "lineNumber": 369
          },
          {
            "text": "\t\tconst fromEl =",
            "lineNumber": 370
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||",
            "lineNumber": 371
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);",
            "lineNumber": 372
          },
          {
            "text": "\t\tconst toEl =",
            "lineNumber": 373
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||",
            "lineNumber": 374
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);",
            "lineNumber": 375
          },
          {
            "text": "\t\tif (!fromEl || !toEl) continue;",
            "lineNumber": 376
          },
          {
            "text": "\t\tconst fromCenter = getElCenter(fromEl);",
            "lineNumber": 377
          },
          {
            "text": "\t\tconst toCenter = getElCenter(toEl);",
            "lineNumber": 378
          },
          {
            "text": "\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;",
            "lineNumber": 379
          },
          {
            "text": "\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;",
            "lineNumber": 380
          },
          {
            "text": "\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);",
            "lineNumber": 381
          },
          {
            "text": "\t\tif (!pathEl) continue;",
            "lineNumber": 382
          },
          {
            "text": "\t\tconst group = pathEl.closest(\"g\");",
            "lineNumber": 383
          },
          {
            "text": "\t\tif (group) group.classList.add(OUTPUT_EDGE_GROUP_CLASS);",
            "lineNumber": 384
          },
          {
            "text": "\t}",
            "lineNumber": 385
          },
          {
            "text": "}",
            "lineNumber": 386,
            "isSignature": true
          }
        ]
      },
      "score": 0.3611496686935425
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 230,
            "column": 1
          },
          "endPosition": {
            "line": 250,
            "column": 1
          }
        },
        "contents": "/** Get center of an element in viewport coordinates. */\nfunction getElCenter(el: HTMLElement): { x: number; y: number } {\n\tconst r = el.getBoundingClientRect();\n\treturn { x: r.left + r.width / 2, y: r.top + r.height / 2 };\n}\n\n/** Path midpoint in viewport (for matching this edge to its path). */\nfunction getPathMidpointViewport(pathEl: SVGPathElement): { x: number; y: number } {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get center of an element in viewport coordinates. */",
            "lineNumber": 233
          },
          {
            "text": "function getElCenter(el: HTMLElement): { x: number; y: number } {",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "\tconst r = el.getBoundingClientRect();",
            "lineNumber": 235
          },
          {
            "text": "\treturn { x: r.left + r.width / 2, y: r.top + r.height / 2 };",
            "lineNumber": 236
          },
          {
            "text": "}",
            "lineNumber": 237,
            "isSignature": true
          },
          {
            "lineNumber": 238
          },
          {
            "text": "/** Path midpoint in viewport (for matching this edge to its path). */",
            "lineNumber": 239
          },
          {
            "text": "function getPathMidpointViewport(pathEl: SVGPathElement): { x: number; y: number } {",
            "lineNumber": 240,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 241
          },
          {
            "text": "}",
            "lineNumber": 251,
            "isSignature": true
          }
        ]
      },
      "score": 0.3557519018650055
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 236,
            "column": 1
          },
          "endPosition": {
            "line": 252,
            "column": 92
          }
        },
        "contents": "/** Path midpoint in viewport (for matching this edge to its path). */\nfunction getPathMidpointViewport(pathEl: SVGPathElement): { x: number; y: number } {\n\tconst len = pathEl.getTotalLength();\n\tconst pt = pathEl.getPointAtLength(len * 0.5);\n\tconst svg = pathEl.ownerSVGElement;\n\tif (!svg) return { x: pt.x, y: pt.y };\n\tconst ctm = svg.getScreenCTM();\n\tif (!ctm) return { x: pt.x, y: pt.y };\n\treturn {\n\t\tx: pt.x * ctm.a + pt.y * ctm.c + ctm.e,\n\t\ty: pt.x * ctm.b + pt.y * ctm.d + ctm.f,\n\t};\n}\n\n/** Path midpoint in SVG coordinates (stable under pan/zoom when used for foreignObject). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Path midpoint in viewport (for matching this edge to its path). */",
            "lineNumber": 239
          },
          {
            "text": "function getPathMidpointViewport(pathEl: SVGPathElement): { x: number; y: number } {",
            "lineNumber": 240,
            "isSignature": true
          },
          {
            "text": "\tconst len = pathEl.getTotalLength();",
            "lineNumber": 241
          },
          {
            "text": "\tconst pt = pathEl.getPointAtLength(len * 0.5);",
            "lineNumber": 242
          },
          {
            "text": "\tconst svg = pathEl.ownerSVGElement;",
            "lineNumber": 243
          },
          {
            "text": "\tif (!svg) return { x: pt.x, y: pt.y };",
            "lineNumber": 244
          },
          {
            "text": "\tconst ctm = svg.getScreenCTM();",
            "lineNumber": 245
          },
          {
            "text": "\tif (!ctm) return { x: pt.x, y: pt.y };",
            "lineNumber": 246
          },
          {
            "text": "\treturn {",
            "lineNumber": 247
          },
          {
            "text": "\t\tx: pt.x * ctm.a + pt.y * ctm.c + ctm.e,",
            "lineNumber": 248
          },
          {
            "text": "\t\ty: pt.x * ctm.b + pt.y * ctm.d + ctm.f,",
            "lineNumber": 249
          },
          {
            "text": "\t};",
            "lineNumber": 250
          },
          {
            "text": "}",
            "lineNumber": 251,
            "isSignature": true
          },
          {
            "lineNumber": 252
          },
          {
            "text": "/** Path midpoint in SVG coordinates (stable under pan/zoom when used for foreignObject). */",
            "lineNumber": 253
          }
        ]
      },
      "score": 0.353959858417511
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 533
          },
          "endPosition": {
            "line": 753,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\n\n\t// 2. Ensure thinking node (above output) when setting on and thinking present\n\tif (settings.showThinkingNode &amp;&amp; thinking != null &amp;&amp; thinking.length &gt; 0) {\n\t\tconst thinkingSide = chooseFreeSideForAuxiliaryEdge(data, sourceNode.id);\n\t\tconst thinkingDefaultY = outputY - height - GREEN_NODE_PADDING;\n\t\tconst thinkingExclude = [sourceNode.id, resolvedOutputId, promptId].filter((id): id is string =&gt; id != null);\n\t\tconst { x: tx, y: ty } = chooseOutputPositionXY(\n\t\t\tdata,\n\t\t\tsourceNode.id,\n\t\t\tthinkingId,\n\t\t\tdefaultX,\n\t\t\tthinkingDefaultY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tthinkingExclude\n\t\t);\n\t\tconst thinkingColor = shadeColor(settings.colorGreen, 0.15);\n\n\t\tif (thinkingId) {\n\t\t\tconst tn = getNodeById(data, thinkingId);\n\t\t\tif (tn &amp;&amp; isTextNode(tn)) {\n\t\t\t\tconst updated = {\n\t\t\t\t\t...(tn as CanvasTextData),\n\t\t\t\t\ttext: thinking,\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\tcolor: thinkingColor,\n\t\t\t\t};\n\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === thinkingId);\n\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t\t}\n\t\t\tconst hasEdge = data.edges.some(\n\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === thinkingId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING\n\t\t\t);\n\t\t\tif (!hasEdge) {\n\t\t\t\tdata.edges.push({\n\t\t\t\t\tid: randomId(),\n\t\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\t\tfromSide: thinkingSide,\n\t\t\t\t\ttoNode: thinkingId,\n\t\t\t\t\ttoSide: thinkingSide === \"left\" ? \"right\" : thinkingSide === \"right\" ? \"left\" : thinkingSide === \"top\" ? \"bottom\" : \"top\",\n\t\t\t\t\tlabel: EDGE_LABEL_THINKING,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst newId = randomId();\n\t\t\tdata.nodes.push({\n\t\t\t\tid: newId,\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: thinking,\n\t\t\t\tx: tx,\n\t\t\t\ty: ty,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tcolor: thinkingColor,\n\t\t\t} as CanvasTextData);\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\tfromSide: thinkingSide,\n\t\t\t\ttoNode: newId,\n\t\t\t\ttoSide: thinkingSide === \"left\" ? \"right\" : thinkingSide === \"right\" ? \"left\" : thinkingSide === \"top\" ? \"bottom\" : \"top\",\n\t\t\t\tlabel: EDGE_LABEL_THINKING,\n\t\t\t});\n\t\t}\n\t}\n\n\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 534,
                "column": 1
              },
              "endPosition": {
                "line": 541,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 536,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 538,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 539,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 540,
            "isSignature": true
          },
          {
            "lineNumber": 617
          },
          {
            "lineNumber": 618
          },
          {
            "text": "\t// 2. Ensure thinking node (above output) when setting on and thinking present",
            "lineNumber": 619
          },
          {
            "text": "\tif (settings.showThinkingNode &amp;&amp; thinking != null &amp;&amp; thinking.length &gt; 0) {",
            "lineNumber": 620
          },
          {
            "text": "\t\tconst thinkingSide = chooseFreeSideForAuxiliaryEdge(data, sourceNode.id);",
            "lineNumber": 621
          },
          {
            "text": "\t\tconst thinkingDefaultY = outputY - height - GREEN_NODE_PADDING;",
            "lineNumber": 622
          },
          {
            "text": "\t\tconst thinkingExclude = [sourceNode.id, resolvedOutputId, promptId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 623
          },
          {
            "text": "\t\tconst { x: tx, y: ty } = chooseOutputPositionXY(",
            "lineNumber": 624
          },
          {
            "text": "\t\t\tdata,",
            "lineNumber": 625
          },
          {
            "text": "\t\t\tsourceNode.id,",
            "lineNumber": 626
          },
          {
            "text": "\t\t\tthinkingId,",
            "lineNumber": 627
          },
          {
            "text": "\t\t\tdefaultX,",
            "lineNumber": 628
          },
          {
            "text": "\t\t\tthinkingDefaultY,",
            "lineNumber": 629
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 630
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 631
          },
          {
            "text": "\t\t\tthinkingExclude",
            "lineNumber": 632
          },
          {
            "text": "\t\t);",
            "lineNumber": 633
          },
          {
            "text": "\t\tconst thinkingColor = shadeColor(settings.colorGreen, 0.15);",
            "lineNumber": 634
          },
          {
            "lineNumber": 635
          },
          {
            "text": "\t\tif (thinkingId) {",
            "lineNumber": 636
          },
          {
            "text": "\t\t\tconst tn = getNodeById(data, thinkingId);",
            "lineNumber": 637
          },
          {
            "text": "\t\t\tif (tn &amp;&amp; isTextNode(tn)) {",
            "lineNumber": 638
          },
          {
            "text": "\t\t\t\tconst updated = {",
            "lineNumber": 639
          },
          {
            "text": "\t\t\t\t\t...(tn as CanvasTextData),",
            "lineNumber": 640
          },
          {
            "text": "\t\t\t\t\ttext: thinking,",
            "lineNumber": 641
          },
          {
            "text": "\t\t\t\t\twidth,",
            "lineNumber": 642
          },
          {
            "text": "\t\t\t\t\theight,",
            "lineNumber": 643
          },
          {
            "text": "\t\t\t\t\tcolor: thinkingColor,",
            "lineNumber": 644
          },
          {
            "text": "\t\t\t\t};",
            "lineNumber": 645
          },
          {
            "text": "\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === thinkingId);",
            "lineNumber": 646
          },
          {
            "text": "\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 647
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 648
          },
          {
            "text": "\t\t\tconst hasEdge = data.edges.some(",
            "lineNumber": 649
          },
          {
            "text": "\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === thinkingId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING",
            "lineNumber": 650
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 651
          },
          {
            "text": "\t\t\tif (!hasEdge) {",
            "lineNumber": 652
          },
          {
            "text": "\t\t\t\tdata.edges.push({",
            "lineNumber": 653
          },
          {
            "text": "\t\t\t\t\tid: randomId(),",
            "lineNumber": 654
          },
          {
            "text": "\t\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 655
          },
          {
            "text": "\t\t\t\t\tfromSide: thinkingSide,",
            "lineNumber": 656
          },
          {
            "text": "\t\t\t\t\ttoNode: thinkingId,",
            "lineNumber": 657
          },
          {
            "text": "\t\t\t\t\ttoSide: thinkingSide === \"left\" ? \"right\" : thinkingSide === \"right\" ? \"left\" : thinkingSide === \"top\" ? \"bottom\" : \"top\",",
            "lineNumber": 658
          },
          {
            "text": "\t\t\t\t\tlabel: EDGE_LABEL_THINKING,",
            "lineNumber": 659
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 660
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 661
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 662
          },
          {
            "text": "\t\t\tconst newId = randomId();",
            "lineNumber": 663
          },
          {
            "text": "\t\t\tdata.nodes.push({",
            "lineNumber": 664
          },
          {
            "text": "\t\t\t\tid: newId,",
            "lineNumber": 665
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 666
          },
          {
            "text": "\t\t\t\ttext: thinking,",
            "lineNumber": 667
          },
          {
            "text": "\t\t\t\tx: tx,",
            "lineNumber": 668
          },
          {
            "text": "\t\t\t\ty: ty,",
            "lineNumber": 669
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 670
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 671
          },
          {
            "text": "\t\t\t\tcolor: thinkingColor,",
            "lineNumber": 672
          },
          {
            "text": "\t\t\t} as CanvasTextData);",
            "lineNumber": 673
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 674
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 675
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 676
          },
          {
            "text": "\t\t\t\tfromSide: thinkingSide,",
            "lineNumber": 677
          },
          {
            "text": "\t\t\t\ttoNode: newId,",
            "lineNumber": 678
          },
          {
            "text": "\t\t\t\ttoSide: thinkingSide === \"left\" ? \"right\" : thinkingSide === \"right\" ? \"left\" : thinkingSide === \"top\" ? \"bottom\" : \"top\",",
            "lineNumber": 679
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_THINKING,",
            "lineNumber": 680
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 681
          },
          {
            "text": "\t\t}",
            "lineNumber": 682
          },
          {
            "text": "\t}",
            "lineNumber": 683
          },
          {
            "lineNumber": 684
          },
          {
            "text": "\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present",
            "lineNumber": 685
          },
          {
            "text": "}",
            "lineNumber": 754,
            "isSignature": true
          }
        ]
      },
      "score": 0.34801506996154785
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 533
          },
          "endPosition": {
            "line": 753,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\n\n\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present\n\tif (settings.showPromptInOutput &amp;&amp; fullPrompt != null &amp;&amp; fullPrompt.length &gt; 0) {\n\t\tconst promptSide = chooseFreeSideForAuxiliaryEdge(data, sourceNode.id);\n\t\tconst thinkingNodeId = settings.showThinkingNode &amp;&amp; thinking ? findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING) : null;\n\t\tconst anchorNode = thinkingNodeId ? getNodeById(data, thinkingNodeId) : outputNode;\n\t\tconst anchorY = anchorNode &amp;&amp; \"y\" in anchorNode ? (anchorNode as { y: number }).y : outputY;\n\t\tconst promptDefaultY = anchorY - height - GREEN_NODE_PADDING;\n\t\tconst promptExclude = [sourceNode.id, resolvedOutputId, thinkingId, promptId].filter((id): id is string =&gt; id != null);\n\t\tconst { x: px, y: py } = chooseOutputPositionXY(\n\t\t\tdata,\n\t\t\tsourceNode.id,\n\t\t\tpromptId,\n\t\t\tdefaultX,\n\t\t\tpromptDefaultY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tpromptExclude\n\t\t);\n\t\tconst promptColor = shadeColor(settings.colorGreen, 0.25);\n\t\tconst promptToSide = promptSide === \"left\" ? \"right\" : promptSide === \"right\" ? \"left\" : promptSide === \"top\" ? \"bottom\" : \"top\";\n\n\t\tif (promptId)\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 534,
                "column": 1
              },
              "endPosition": {
                "line": 541,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 536,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 538,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 539,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 540,
            "isSignature": true
          },
          {
            "lineNumber": 683
          },
          {
            "lineNumber": 684
          },
          {
            "text": "\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present",
            "lineNumber": 685
          },
          {
            "text": "\tif (settings.showPromptInOutput &amp;&amp; fullPrompt != null &amp;&amp; fullPrompt.length &gt; 0) {",
            "lineNumber": 686
          },
          {
            "text": "\t\tconst promptSide = chooseFreeSideForAuxiliaryEdge(data, sourceNode.id);",
            "lineNumber": 687
          },
          {
            "text": "\t\tconst thinkingNodeId = settings.showThinkingNode &amp;&amp; thinking ? findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING) : null;",
            "lineNumber": 688
          },
          {
            "text": "\t\tconst anchorNode = thinkingNodeId ? getNodeById(data, thinkingNodeId) : outputNode;",
            "lineNumber": 689
          },
          {
            "text": "\t\tconst anchorY = anchorNode &amp;&amp; \"y\" in anchorNode ? (anchorNode as { y: number }).y : outputY;",
            "lineNumber": 690
          },
          {
            "text": "\t\tconst promptDefaultY = anchorY - height - GREEN_NODE_PADDING;",
            "lineNumber": 691
          },
          {
            "text": "\t\tconst promptExclude = [sourceNode.id, resolvedOutputId, thinkingId, promptId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 692
          },
          {
            "text": "\t\tconst { x: px, y: py } = chooseOutputPositionXY(",
            "lineNumber": 693
          },
          {
            "text": "\t\t\tdata,",
            "lineNumber": 694
          },
          {
            "text": "\t\t\tsourceNode.id,",
            "lineNumber": 695
          },
          {
            "text": "\t\t\tpromptId,",
            "lineNumber": 696
          },
          {
            "text": "\t\t\tdefaultX,",
            "lineNumber": 697
          },
          {
            "text": "\t\t\tpromptDefaultY,",
            "lineNumber": 698
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 699
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 700
          },
          {
            "text": "\t\t\tpromptExclude",
            "lineNumber": 701
          },
          {
            "text": "\t\t);",
            "lineNumber": 702
          },
          {
            "text": "\t\tconst promptColor = shadeColor(settings.colorGreen, 0.25);",
            "lineNumber": 703
          },
          {
            "text": "\t\tconst promptToSide = promptSide === \"left\" ? \"right\" : promptSide === \"right\" ? \"left\" : promptSide === \"top\" ? \"bottom\" : \"top\";",
            "lineNumber": 704
          },
          {
            "lineNumber": 705
          },
          {
            "text": "\t\tif (promptId)",
            "lineNumber": 706
          },
          {
            "text": "}",
            "lineNumber": 754,
            "isSignature": true
          }
        ]
      },
      "score": 0.3361803889274597
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 533
          },
          "endPosition": {
            "line": 753,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\n\tif (outId) {\n\t\tresolvedOutputId = outId;\n\t\tconst outNode = getNodeById(data, outId);\n\t\tif (outNode &amp;&amp; isTextNode(outNode)) {\n\t\t\tconst existingX = (outNode as CanvasTextData).x;\n\t\t\tconst existingY = (outNode as CanvasTextData).y;\n\t\t\tconst updated = {\n\t\t\t\t...(outNode as CanvasTextData),\n\t\t\t\ttext,\n\t\t\t\tx: existingX,\n\t\t\t\ty: existingY,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t};\n\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);\n\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t}\n\t\tconst hasOutputEdge = data.edges.some(\n\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t\t);\n\t\tif (!hasOutputEdge) {\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: outId,\n\t\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tconst newNodeId = randomId();\n\t\tresolvedOutputId = newNodeId;\n\t\tconst newTextNode: CanvasTextData = {\n\t\t\tid: newNodeId,\n\t\t\ttype: \"text\",\n\t\t\ttext,\n\t\t\tx: chosenX,\n\t\t\ty: chosenY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tcolor: greenColor,\n\t\t};\n\t\tdata.nodes.push(newTextNode);\n\t\tdata.edges.push({\n\t\t\tid: randomId(),\n\t\t\tfromNode: sourceNode.id,\n\t\t\ttoNode: newNodeId,\n\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t});\n\t}\n\n\tconst outputNode = getNodeById(data, resolvedOutputId);\n\tconst outputY = outputNode &amp;&amp; \"y\" in outputNode ? (outputNode as { y: number }).y : chosenY;\n\n\t// 2. Ensure thinking node (above output) when setting on and thinking present\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 534,
                "column": 1
              },
              "endPosition": {
                "line": 541,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 536,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 538,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 539,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 540,
            "isSignature": true
          },
          {
            "lineNumber": 565
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 566
          },
          {
            "text": "\t\tresolvedOutputId = outId;",
            "lineNumber": 567
          },
          {
            "text": "\t\tconst outNode = getNodeById(data, outId);",
            "lineNumber": 568
          },
          {
            "text": "\t\tif (outNode &amp;&amp; isTextNode(outNode)) {",
            "lineNumber": 569
          },
          {
            "text": "\t\t\tconst existingX = (outNode as CanvasTextData).x;",
            "lineNumber": 570
          },
          {
            "text": "\t\t\tconst existingY = (outNode as CanvasTextData).y;",
            "lineNumber": 571
          },
          {
            "text": "\t\t\tconst updated = {",
            "lineNumber": 572
          },
          {
            "text": "\t\t\t\t...(outNode as CanvasTextData),",
            "lineNumber": 573
          },
          {
            "text": "\t\t\t\ttext,",
            "lineNumber": 574
          },
          {
            "text": "\t\t\t\tx: existingX,",
            "lineNumber": 575
          },
          {
            "text": "\t\t\t\ty: existingY,",
            "lineNumber": 576
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 577
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 578
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 579
          },
          {
            "text": "\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);",
            "lineNumber": 580
          },
          {
            "text": "\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 581
          },
          {
            "text": "\t\t}",
            "lineNumber": 582
          },
          {
            "text": "\t\tconst hasOutputEdge = data.edges.some(",
            "lineNumber": 583
          },
          {
            "text": "\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 584
          },
          {
            "text": "\t\t);",
            "lineNumber": 585
          },
          {
            "text": "\t\tif (!hasOutputEdge) {",
            "lineNumber": 586
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 587
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 588
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 589
          },
          {
            "text": "\t\t\t\ttoNode: outId,",
            "lineNumber": 590
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 591
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 592
          },
          {
            "text": "\t\t}",
            "lineNumber": 593
          },
          {
            "text": "\t} else {",
            "lineNumber": 594
          },
          {
            "text": "\t\tconst newNodeId = randomId();",
            "lineNumber": 595
          },
          {
            "text": "\t\tresolvedOutputId = newNodeId;",
            "lineNumber": 596
          },
          {
            "text": "\t\tconst newTextNode: CanvasTextData = {",
            "lineNumber": 597
          },
          {
            "text": "\t\t\tid: newNodeId,",
            "lineNumber": 598
          },
          {
            "text": "\t\t\ttype: \"text\",",
            "lineNumber": 599
          },
          {
            "text": "\t\t\ttext,",
            "lineNumber": 600
          },
          {
            "text": "\t\t\tx: chosenX,",
            "lineNumber": 601
          },
          {
            "text": "\t\t\ty: chosenY,",
            "lineNumber": 602
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 603
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 604
          },
          {
            "text": "\t\t\tcolor: greenColor,",
            "lineNumber": 605
          },
          {
            "text": "\t\t};",
            "lineNumber": 606
          },
          {
            "text": "\t\tdata.nodes.push(newTextNode);",
            "lineNumber": 607
          },
          {
            "text": "\t\tdata.edges.push({",
            "lineNumber": 608
          },
          {
            "text": "\t\t\tid: randomId(),",
            "lineNumber": 609
          },
          {
            "text": "\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 610
          },
          {
            "text": "\t\t\ttoNode: newNodeId,",
            "lineNumber": 611
          },
          {
            "text": "\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 612
          },
          {
            "text": "\t\t});",
            "lineNumber": 613
          },
          {
            "text": "\t}",
            "lineNumber": 614
          },
          {
            "lineNumber": 615
          },
          {
            "text": "\tconst outputNode = getNodeById(data, resolvedOutputId);",
            "lineNumber": 616
          },
          {
            "text": "\tconst outputY = outputNode &amp;&amp; \"y\" in outputNode ? (outputNode as { y: number }).y : chosenY;",
            "lineNumber": 617
          },
          {
            "lineNumber": 618
          },
          {
            "text": "\t// 2. Ensure thinking node (above output) when setting on and thinking present",
            "lineNumber": 619
          },
          {
            "text": "}",
            "lineNumber": 754,
            "isSignature": true
          }
        ]
      },
      "score": 0.3291642963886261
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 250,
            "column": 1
          },
          "endPosition": {
            "line": 259,
            "column": 112
          }
        },
        "contents": "/** Path midpoint in SVG coordinates (stable under pan/zoom when used for foreignObject). */\nfunction getPathMidpointSvg(pathEl: SVGPathElement): { x: number; y: number } {\n\tconst len = pathEl.getTotalLength();\n\tconst pt = pathEl.getPointAtLength(len * 0.5);\n\treturn { x: pt.x, y: pt.y };\n}\n\n/** Find the path whose midpoint is closest to the given viewport point (identifies the arrow for this edge). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Path midpoint in SVG coordinates (stable under pan/zoom when used for foreignObject). */",
            "lineNumber": 253
          },
          {
            "text": "function getPathMidpointSvg(pathEl: SVGPathElement): { x: number; y: number } {",
            "lineNumber": 254,
            "isSignature": true
          },
          {
            "text": "\tconst len = pathEl.getTotalLength();",
            "lineNumber": 255
          },
          {
            "text": "\tconst pt = pathEl.getPointAtLength(len * 0.5);",
            "lineNumber": 256
          },
          {
            "text": "\treturn { x: pt.x, y: pt.y };",
            "lineNumber": 257
          },
          {
            "text": "}",
            "lineNumber": 258,
            "isSignature": true
          },
          {
            "lineNumber": 259
          },
          {
            "text": "/** Find the path whose midpoint is closest to the given viewport point (identifies the arrow for this edge). */",
            "lineNumber": 260
          }
        ]
      },
      "score": 0.32688578963279724
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 150,
            "column": 1
          },
          "endPosition": {
            "line": 230,
            "column": 1
          }
        },
        "contents": "/**\n * Sync floating role labels for the active canvas: for each node whose color maps to a role,\n * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first.\n * Uses the live canvas node map to find each node's DOM element (.canvas-node).\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasRoleLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tsettings: ZettelPluginSettings,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tif (!settings.showNodeRoleLabels) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.nodes) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).\n\tclearCanvasRoleLabels(containerEl);\n\tsyncCanvasLegend(containerEl, settings);\n\n\tconst order = getTopologicalOrder(data, settings);\n\tconst orderByNodeId = new Map&lt;string, number&gt;();\n\tif (order) {\n\t\torder.forEach((nodeId, index) =&gt; orderByNodeId.set(nodeId, index + 1));\n\t}\n\n\tconst promptNodeIds = new Set(\n\t\tdata.edges\n\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT)\n\t\t\t.map((e) =&gt; e.toNode)\n\t);\n\tconst thinkingNodeIds = new Set(\n\t\tdata.edges\n\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING)\n\t\t\t.map((e) =&gt; e.toNode)\n\t);\n\n\tfor (const node of data.nodes)\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/**",
            "lineNumber": 153
          },
          {
            "text": " * Sync floating role labels for the active canvas: for each node whose color maps to a role,",
            "lineNumber": 154
          },
          {
            "text": " * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first.",
            "lineNumber": 155
          },
          {
            "text": " * Uses the live canvas node map to find each node's DOM element (.canvas-node).",
            "lineNumber": 156
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 157
          },
          {
            "text": " */",
            "lineNumber": 158
          },
          {
            "text": "export async function syncCanvasRoleLabels(",
            "lineNumber": 159,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 160,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 161,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 162,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 163,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 164,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 165,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 166,
            "isSignature": true
          },
          {
            "text": "\tif (!settings.showNodeRoleLabels) {",
            "lineNumber": 167
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 168
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 169
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 170
          },
          {
            "text": "\t}",
            "lineNumber": 171
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 172
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 173
          },
          {
            "text": "\tif (!data?.nodes) {",
            "lineNumber": 174
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 175
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 176
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 177
          },
          {
            "text": "\t}",
            "lineNumber": 178
          },
          {
            "text": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).",
            "lineNumber": 179
          },
          {
            "text": "\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 180
          },
          {
            "text": "\tsyncCanvasLegend(containerEl, settings);",
            "lineNumber": 181
          },
          {
            "lineNumber": 182
          },
          {
            "text": "\tconst order = getTopologicalOrder(data, settings);",
            "lineNumber": 183
          },
          {
            "text": "\tconst orderByNodeId = new Map&lt;string, number&gt;();",
            "lineNumber": 184
          },
          {
            "text": "\tif (order) {",
            "lineNumber": 185
          },
          {
            "text": "\t\torder.forEach((nodeId, index) =&gt; orderByNodeId.set(nodeId, index + 1));",
            "lineNumber": 186
          },
          {
            "text": "\t}",
            "lineNumber": 187
          },
          {
            "lineNumber": 188
          },
          {
            "text": "\tconst promptNodeIds = new Set(",
            "lineNumber": 189
          },
          {
            "text": "\t\tdata.edges",
            "lineNumber": 190
          },
          {
            "text": "\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT)",
            "lineNumber": 191
          },
          {
            "text": "\t\t\t.map((e) =&gt; e.toNode)",
            "lineNumber": 192
          },
          {
            "text": "\t);",
            "lineNumber": 193
          },
          {
            "text": "\tconst thinkingNodeIds = new Set(",
            "lineNumber": 194
          },
          {
            "text": "\t\tdata.edges",
            "lineNumber": 195
          },
          {
            "text": "\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING)",
            "lineNumber": 196
          },
          {
            "text": "\t\t\t.map((e) =&gt; e.toNode)",
            "lineNumber": 197
          },
          {
            "text": "\t);",
            "lineNumber": 198
          },
          {
            "lineNumber": 199
          },
          {
            "text": "\tfor (const node of data.nodes)",
            "lineNumber": 200
          },
          {
            "text": "}",
            "lineNumber": 231,
            "isSignature": true
          }
        ]
      },
      "score": 0.32237958908081055
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 505,
            "column": 1
          },
          "endPosition": {
            "line": 510,
            "column": 118
          }
        },
        "contents": "/** Sides of a node for edge connection (Obsidian canvas). */\ntype NodeSide = \"top\" | \"right\" | \"bottom\" | \"left\";\n\n/** Preferred order for auxiliary edges (prompt/thinking): use left/right to avoid input (top) and output (bottom). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Sides of a node for edge connection (Obsidian canvas). */",
            "lineNumber": 508
          },
          {
            "text": "type NodeSide = \"top\" | \"right\" | \"bottom\" | \"left\";",
            "lineNumber": 509,
            "isSignature": true
          },
          {
            "lineNumber": 510
          },
          {
            "text": "/** Preferred order for auxiliary edges (prompt/thinking): use left/right to avoid input (top) and output (bottom). */",
            "lineNumber": 511
          }
        ]
      },
      "score": 0.3153153657913208
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 97
          },
          "endPosition": {
            "line": 315,
            "column": 93
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\nconst nodes: CanvasData[\"nodes\"] = [\n 145),\n\t];\n\n\tconst edges: CanvasData[\"edges\"] = [\n\t\te(\"e-orange-out\", orangeNode, orangeOut, EDGE_LABEL_OUTPUT),\n\t\te(\"e-purple-out\", purpleNode, purpleOut, EDGE_LABEL_OUTPUT),\n\t\te(\"e-blue-out\", blueNode, blueOut, EDGE_LABEL_OUTPUT),\n\t\te(\"e-concat-comment-orange\", concatComment, concatOrange),\n\t\te(\"e-concat-out\", concatOrange, concatOut, EDGE_LABEL_OUTPUT),\n\t\te(\"e-inject-first-second\", injectFirst, injectSecond, \"reply\"),\n\t\te(\"e-inject-out\", injectSecond, injectOut, EDGE_LABEL_OUTPUT),\n\t];\n\n\treturn { nodes, edges };\n}\n\n/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 98,
                "column": 1
              },
              "endPosition": {
                "line": 99,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "text": "const nodes: CanvasData[\"nodes\"] = [",
            "lineNumber": 259
          },
          {
            "text": " 145),",
            "lineNumber": 300
          },
          {
            "text": "\t];",
            "lineNumber": 301
          },
          {
            "lineNumber": 302
          },
          {
            "text": "\tconst edges: CanvasData[\"edges\"] = [",
            "lineNumber": 303
          },
          {
            "text": "\t\te(\"e-orange-out\", orangeNode, orangeOut, EDGE_LABEL_OUTPUT),",
            "lineNumber": 304
          },
          {
            "text": "\t\te(\"e-purple-out\", purpleNode, purpleOut, EDGE_LABEL_OUTPUT),",
            "lineNumber": 305
          },
          {
            "text": "\t\te(\"e-blue-out\", blueNode, blueOut, EDGE_LABEL_OUTPUT),",
            "lineNumber": 306
          },
          {
            "text": "\t\te(\"e-concat-comment-orange\", concatComment, concatOrange),",
            "lineNumber": 307
          },
          {
            "text": "\t\te(\"e-concat-out\", concatOrange, concatOut, EDGE_LABEL_OUTPUT),",
            "lineNumber": 308
          },
          {
            "text": "\t\te(\"e-inject-first-second\", injectFirst, injectSecond, \"reply\"),",
            "lineNumber": 309
          },
          {
            "text": "\t\te(\"e-inject-out\", injectSecond, injectOut, EDGE_LABEL_OUTPUT),",
            "lineNumber": 310
          },
          {
            "text": "\t];",
            "lineNumber": 311
          },
          {
            "lineNumber": 312
          },
          {
            "text": "\treturn { nodes, edges };",
            "lineNumber": 313
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          },
          {
            "lineNumber": 315
          },
          {
            "text": "/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */",
            "lineNumber": 316
          }
        ]
      },
      "score": 0.30852383375167847
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 53,
            "column": 1
          }
        },
        "contents": "import type {Vault} from \"obsidian\";\nimport {loadCanvasData} from \"./nodes\";\nimport {\n\tEDGE_LABEL_PROMPT,\n\tEDGE_LABEL_THINKING,\n\tgetNodeRole,\n\tisOutputEdge,\n\tparseEdgeVariableName,\n} from \"./types\";\nimport type {CanvasColor, NodeRole, ZettelPluginSettings} from \"../settings\";\nimport {COLOR_ROLES, getPresetColor, getRoleLabel} from \"../settings\";\nimport type {LiveCanvas} from \"../engine/canvasApi\";\nimport {getTopologicalOrder} from \"../engine/runner\";\nimport {getCanvasKey, getEdgeMode, getRunningNodeId} from \"../engine/state\";\n\nconst LABEL_CLASS = \"ztb-node-role-label\";\nconst ORDER_BADGE_CLASS = \"ztb-node-order-badge\";\nconst LABEL_DATA_ATTR = \"data-ztb-role-label\";\nconst LEGEND_CLASS = \"ztb-canvas-legend\";\nconst EDGE_MODE_LABEL_CLASS = \"ztb-edge-mode-label\";\nconst EDGE_MODE_DATA_ATTR = \"data-ztb-edge-id\";\nconst EDGE_MODE_STATE_ATTR = \"data-ztb-edge-state\";\nconst EDGE_MODE_ICON_CLASS = \"ztb-edge-mode-icon\";\ntype EdgeDisplayState = \"running\" | \"inject\" | \"concatenate\";\n/** Try to get a canvas node's root DOM element from the live canvas (Obsidian uses .canvas-node, no data-id). */\nfunction getNodeElFromCanvas(canvas: LiveCanvas, nodeId: string): HTMLElement | null {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {Vault} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {loadCanvasData} from \"./nodes\";",
            "lineNumber": 2
          },
          {
            "text": "import {",
            "lineNumber": 3
          },
          {
            "text": "\tEDGE_LABEL_PROMPT,",
            "lineNumber": 4
          },
          {
            "text": "\tEDGE_LABEL_THINKING,",
            "lineNumber": 5
          },
          {
            "text": "\tgetNodeRole,",
            "lineNumber": 6
          },
          {
            "text": "\tisOutputEdge,",
            "lineNumber": 7
          },
          {
            "text": "\tparseEdgeVariableName,",
            "lineNumber": 8
          },
          {
            "text": "} from \"./types\";",
            "lineNumber": 9
          },
          {
            "text": "import type {CanvasColor, NodeRole, ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 10
          },
          {
            "text": "import {COLOR_ROLES, getPresetColor, getRoleLabel} from \"../settings\";",
            "lineNumber": 11
          },
          {
            "text": "import type {LiveCanvas} from \"../engine/canvasApi\";",
            "lineNumber": 12
          },
          {
            "text": "import {getTopologicalOrder} from \"../engine/runner\";",
            "lineNumber": 13
          },
          {
            "text": "import {getCanvasKey, getEdgeMode, getRunningNodeId} from \"../engine/state\";",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "const LABEL_CLASS = \"ztb-node-role-label\";",
            "lineNumber": 16
          },
          {
            "text": "const ORDER_BADGE_CLASS = \"ztb-node-order-badge\";",
            "lineNumber": 17
          },
          {
            "text": "const LABEL_DATA_ATTR = \"data-ztb-role-label\";",
            "lineNumber": 18
          },
          {
            "text": "const LEGEND_CLASS = \"ztb-canvas-legend\";",
            "lineNumber": 19
          },
          {
            "text": "const EDGE_MODE_LABEL_CLASS = \"ztb-edge-mode-label\";",
            "lineNumber": 20
          },
          {
            "text": "const EDGE_MODE_DATA_ATTR = \"data-ztb-edge-id\";",
            "lineNumber": 21
          },
          {
            "text": "const EDGE_MODE_STATE_ATTR = \"data-ztb-edge-state\";",
            "lineNumber": 22
          },
          {
            "text": "const EDGE_MODE_ICON_CLASS = \"ztb-edge-mode-icon\";",
            "lineNumber": 23
          },
          {
            "text": "type EdgeDisplayState = \"running\" | \"inject\" | \"concatenate\";",
            "lineNumber": 24,
            "isSignature": true
          },
          {
            "text": "/** Try to get a canvas node's root DOM element from the live canvas (Obsidian uses .canvas-node, no data-id). */",
            "lineNumber": 25
          },
          {
            "text": "function getNodeElFromCanvas(canvas: LiveCanvas, nodeId: string): HTMLElement | null {",
            "lineNumber": 26,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 27
          },
          {
            "text": "}",
            "lineNumber": 54,
            "isSignature": true
          }
        ]
      },
      "score": 0.3037526607513428
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 533
          },
          "endPosition": {
            "line": 755,
            "column": 107
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\nconst promptToSide =  promptSide === \"top\" ? \"bottom\" : \"top\";\n\n\t\tif (promptId) {\n\t\t\tconst pn = getNodeById(data, promptId);\n\t\t\tif (pn &amp;&amp; isTextNode(pn)) {\n\t\t\t\tconst updated = {\n\t\t\t\t\t...(pn as CanvasTextData),\n\t\t\t\t\ttext: fullPrompt,\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\tcolor: promptColor,\n\t\t\t\t};\n\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === promptId);\n\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t\t}\n\t\t\tconst hasEdge = data.edges.some(\n\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === promptId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT\n\t\t\t);\n\t\t\tif (!hasEdge) {\n\t\t\t\tdata.edges.push({\n\t\t\t\t\tid: randomId(),\n\t\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\t\tfromSide: promptSide,\n\t\t\t\t\ttoNode: promptId,\n\t\t\t\t\ttoSide: promptToSide,\n\t\t\t\t\tlabel: EDGE_LABEL_PROMPT,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst newId = randomId();\n\t\t\tdata.nodes.push({\n\t\t\t\tid: newId,\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: fullPrompt,\n\t\t\t\tx: px,\n\t\t\t\ty: py,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tcolor: promptColor,\n\t\t\t} as CanvasTextData);\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\tfromSide: promptSide,\n\t\t\t\ttoNode: newId,\n\t\t\t\ttoSide: promptToSide,\n\t\t\t\tlabel: EDGE_LABEL_PROMPT,\n\t\t\t});\n\t\t}\n\t}\n}\n\n/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 534,
                "column": 1
              },
              "endPosition": {
                "line": 541,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 536,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 538,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 539,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 540,
            "isSignature": true
          },
          {
            "text": "const promptToSide =  promptSide === \"top\" ? \"bottom\" : \"top\";",
            "lineNumber": 704
          },
          {
            "lineNumber": 705
          },
          {
            "text": "\t\tif (promptId) {",
            "lineNumber": 706
          },
          {
            "text": "\t\t\tconst pn = getNodeById(data, promptId);",
            "lineNumber": 707
          },
          {
            "text": "\t\t\tif (pn &amp;&amp; isTextNode(pn)) {",
            "lineNumber": 708
          },
          {
            "text": "\t\t\t\tconst updated = {",
            "lineNumber": 709
          },
          {
            "text": "\t\t\t\t\t...(pn as CanvasTextData),",
            "lineNumber": 710
          },
          {
            "text": "\t\t\t\t\ttext: fullPrompt,",
            "lineNumber": 711
          },
          {
            "text": "\t\t\t\t\twidth,",
            "lineNumber": 712
          },
          {
            "text": "\t\t\t\t\theight,",
            "lineNumber": 713
          },
          {
            "text": "\t\t\t\t\tcolor: promptColor,",
            "lineNumber": 714
          },
          {
            "text": "\t\t\t\t};",
            "lineNumber": 715
          },
          {
            "text": "\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === promptId);",
            "lineNumber": 716
          },
          {
            "text": "\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 717
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 718
          },
          {
            "text": "\t\t\tconst hasEdge = data.edges.some(",
            "lineNumber": 719
          },
          {
            "text": "\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === promptId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT",
            "lineNumber": 720
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 721
          },
          {
            "text": "\t\t\tif (!hasEdge) {",
            "lineNumber": 722
          },
          {
            "text": "\t\t\t\tdata.edges.push({",
            "lineNumber": 723
          },
          {
            "text": "\t\t\t\t\tid: randomId(),",
            "lineNumber": 724
          },
          {
            "text": "\t\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 725
          },
          {
            "text": "\t\t\t\t\tfromSide: promptSide,",
            "lineNumber": 726
          },
          {
            "text": "\t\t\t\t\ttoNode: promptId,",
            "lineNumber": 727
          },
          {
            "text": "\t\t\t\t\ttoSide: promptToSide,",
            "lineNumber": 728
          },
          {
            "text": "\t\t\t\t\tlabel: EDGE_LABEL_PROMPT,",
            "lineNumber": 729
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 730
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 731
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 732
          },
          {
            "text": "\t\t\tconst newId = randomId();",
            "lineNumber": 733
          },
          {
            "text": "\t\t\tdata.nodes.push({",
            "lineNumber": 734
          },
          {
            "text": "\t\t\t\tid: newId,",
            "lineNumber": 735
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 736
          },
          {
            "text": "\t\t\t\ttext: fullPrompt,",
            "lineNumber": 737
          },
          {
            "text": "\t\t\t\tx: px,",
            "lineNumber": 738
          },
          {
            "text": "\t\t\t\ty: py,",
            "lineNumber": 739
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 740
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 741
          },
          {
            "text": "\t\t\t\tcolor: promptColor,",
            "lineNumber": 742
          },
          {
            "text": "\t\t\t} as CanvasTextData);",
            "lineNumber": 743
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 744
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 745
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 746
          },
          {
            "text": "\t\t\t\tfromSide: promptSide,",
            "lineNumber": 747
          },
          {
            "text": "\t\t\t\ttoNode: newId,",
            "lineNumber": 748
          },
          {
            "text": "\t\t\t\ttoSide: promptToSide,",
            "lineNumber": 749
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_PROMPT,",
            "lineNumber": 750
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 751
          },
          {
            "text": "\t\t}",
            "lineNumber": 752
          },
          {
            "text": "\t}",
            "lineNumber": 753
          },
          {
            "text": "}",
            "lineNumber": 754,
            "isSignature": true
          },
          {
            "lineNumber": 755
          },
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 756
          }
        ]
      },
      "score": 0.3025813102722168
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 158
          },
          "endPosition": {
            "line": 236,
            "column": 1
          }
        },
        "contents": "export async function syncCanvasRoleLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tsettings: ZettelPluginSettings,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\nconst thinkingNodeIds = new \n\n((e) =&gt; e.toNode)\n\t);\n\n\tfor (const node of data.nodes) {\n\t\tconst nodeEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||\n\t\t\tfindNodeElementByDataId(containerEl, node.id);\n\t\tif (!nodeEl) continue;\n\t\t// Append to root .canvas-node so position:absolute is relative to the full card (avoids overlapping file title)\n\t\tconst rootEl =\n\t\t\tnodeEl.classList.contains(\"canvas-node\")\n\t\t\t\t? nodeEl\n\t\t\t\t: (nodeEl.closest(\".canvas-node\") as HTMLElement | null) ?? nodeEl;\n\n\t\tlet labelText: string | null = null;\n\t\tconst role = getNodeRole(node, settings);\n\t\tif (role) {\n\t\t\tlabelText = getRoleLabel(role, settings);\n\t\t} else if (promptNodeIds.has(node.id)) {\n\t\t\tlabelText = \"Prompt\";\n\t\t} else if (thinkingNodeIds.has(node.id)) {\n\t\t\tlabelText = \"Thinking\";\n\t\t}\n\t\tif (labelText) {\n\t\t\tconst label = createLabelEl(labelText);\n\t\t\trootEl.prepend(label);\n\t\t}\n\n\t\tconst orderIndex = orderByNodeId.get(node.id);\n\t\tif (orderIndex != null) {\n\t\t\tconst badge = createOrderBadgeEl(orderIndex);\n\t\t\trootEl.prepend(badge);\n\t\t}\n\t}\n}\n\n/** Get center of an element in viewport coordinates. */\nfunction getElCenter(el: HTMLElement): { x: number; y: number } {\n\tconst r = el.getBoundingClientRect();\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 159,
                "column": 1
              },
              "endPosition": {
                "line": 159,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 159,
                "column": 8
              },
              "endPosition": {
                "line": 167,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function syncCanvasRoleLabels(",
            "lineNumber": 159,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 160,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 161,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 162,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 163,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 164,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 165,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 166,
            "isSignature": true
          },
          {
            "text": "const thinkingNodeIds = new ",
            "lineNumber": 194
          },
          {
            "lineNumber": 195
          },
          {
            "text": "((e) =&gt; e.toNode)",
            "lineNumber": 197
          },
          {
            "text": "\t);",
            "lineNumber": 198
          },
          {
            "lineNumber": 199
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 200
          },
          {
            "text": "\t\tconst nodeEl =",
            "lineNumber": 201
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||",
            "lineNumber": 202
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, node.id);",
            "lineNumber": 203
          },
          {
            "text": "\t\tif (!nodeEl) continue;",
            "lineNumber": 204
          },
          {
            "text": "\t\t// Append to root .canvas-node so position:absolute is relative to the full card (avoids overlapping file title)",
            "lineNumber": 205
          },
          {
            "text": "\t\tconst rootEl =",
            "lineNumber": 206
          },
          {
            "text": "\t\t\tnodeEl.classList.contains(\"canvas-node\")",
            "lineNumber": 207
          },
          {
            "text": "\t\t\t\t? nodeEl",
            "lineNumber": 208
          },
          {
            "text": "\t\t\t\t: (nodeEl.closest(\".canvas-node\") as HTMLElement | null) ?? nodeEl;",
            "lineNumber": 209
          },
          {
            "lineNumber": 210
          },
          {
            "text": "\t\tlet labelText: string | null = null;",
            "lineNumber": 211
          },
          {
            "text": "\t\tconst role = getNodeRole(node, settings);",
            "lineNumber": 212
          },
          {
            "text": "\t\tif (role) {",
            "lineNumber": 213
          },
          {
            "text": "\t\t\tlabelText = getRoleLabel(role, settings);",
            "lineNumber": 214
          },
          {
            "text": "\t\t} else if (promptNodeIds.has(node.id)) {",
            "lineNumber": 215
          },
          {
            "text": "\t\t\tlabelText = \"Prompt\";",
            "lineNumber": 216
          },
          {
            "text": "\t\t} else if (thinkingNodeIds.has(node.id)) {",
            "lineNumber": 217
          },
          {
            "text": "\t\t\tlabelText = \"Thinking\";",
            "lineNumber": 218
          },
          {
            "text": "\t\t}",
            "lineNumber": 219
          },
          {
            "text": "\t\tif (labelText) {",
            "lineNumber": 220
          },
          {
            "text": "\t\t\tconst label = createLabelEl(labelText);",
            "lineNumber": 221
          },
          {
            "text": "\t\t\trootEl.prepend(label);",
            "lineNumber": 222
          },
          {
            "text": "\t\t}",
            "lineNumber": 223
          },
          {
            "lineNumber": 224
          },
          {
            "text": "\t\tconst orderIndex = orderByNodeId.get(node.id);",
            "lineNumber": 225
          },
          {
            "text": "\t\tif (orderIndex != null) {",
            "lineNumber": 226
          },
          {
            "text": "\t\t\tconst badge = createOrderBadgeEl(orderIndex);",
            "lineNumber": 227
          },
          {
            "text": "\t\t\trootEl.prepend(badge);",
            "lineNumber": 228
          },
          {
            "text": "\t\t}",
            "lineNumber": 229
          },
          {
            "text": "\t}",
            "lineNumber": 230
          },
          {
            "text": "}",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "lineNumber": 232
          },
          {
            "text": "/** Get center of an element in viewport coordinates. */",
            "lineNumber": 233
          },
          {
            "text": "function getElCenter(el: HTMLElement): { x: number; y: number } {",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "\tconst r = el.getBoundingClientRect();",
            "lineNumber": 235
          },
          {
            "text": "}",
            "lineNumber": 237,
            "isSignature": true
          }
        ]
      },
      "score": 0.3009735345840454
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 94,
            "column": 1
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "/** Build tutorial canvas: columns with comment margins, node lane center, edges, groups. */\nfunction getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\tconst cOrange = tutorialColor(settings, \"colorOrange\");\n\tconst cPurple = tutorialColor(settings, \"colorPurple\");\n\tconst cBlue = tutorialColor(settings, \"colorBlue\");\n\tconst cYellow = tutorialColor(settings, \"colorYellow\");\n\tconst cGreen = tutorialColor(settings, \"colorGreen\");\n\n\t/** Plain text node (no role): use for labels/instructions so they are not treated as comment nodes. */\n\tconst n = (id: string, text: string, x: number, y: number, color: string, w: number, h: number) =&gt;\n\t\t({ id, type: \"text\" as const, text, x, y, width: w, height: h, color });\n\tconst e = (id: string, from: string, to: string, label?: string) =&gt; ({\n\t\tid,\n\t\tfromNode: from,\n\t\ttoNode: to,\n\t\tfromSide: \"bottom\" as const,\n\t\ttoSide: \"top\" as const,\n\t\tlabel: label ?? \"\",\n\t});\n\t/** Group node to visually separate a workflow block. */\n\tconst g = (id: string, x: number, y: number, w: number, h: number, label: string) =&gt;\n\t\t({ id, type: \"group\" as const, x, y, width: w, height: h, label });\n\n\t/** Column 1..6: x of left comment margin (column 1 starts right after welcome). */\n\tconst colLeft = (index: number) =&gt;\n\t\tTUT_LEFT + TUT_WELCOME_W + TUT_COL_GAP + (index - 1) * (TUT_COL_TOTAL_W + TUT_COL_GAP);\n\tconst commentLeftX = (colIndex: number) =&gt; colLeft(colIndex);\n\t/** Node lane: center x; offsetPx shifts right so alternating nodes make arrows more visible. */\n\tconst laneNodeX = (colIndex: number, offsetPx: number = 0) =&gt;\n\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + offsetPx;\n\tconst commentRightX = (colIndex: number) =&gt;\n\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP;\n\tconst LANE_OFFSET = 36;\n\n\t// —— Welcome: alone in first block, no overlap with column 1 ——\n\tconst welcome = \"welcome\";\n\tconst welcomeY = TUT_TOP;\n\n\t// —— Column 1: Primary (comment left, node → output in lane) ——\n\tconst col1 = 1;\n\tconst lab1 = \"lab-primary\";\n\tconst orangeNode = \"orange-example\";\n\tconst orangeOut = \"orange-out\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build tutorial canvas: columns with comment margins, node lane center, edges, groups. */",
            "lineNumber": 97
          },
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "text": "\tconst cOrange = tutorialColor(settings, \"colorOrange\");",
            "lineNumber": 99
          },
          {
            "text": "\tconst cPurple = tutorialColor(settings, \"colorPurple\");",
            "lineNumber": 100
          },
          {
            "text": "\tconst cBlue = tutorialColor(settings, \"colorBlue\");",
            "lineNumber": 101
          },
          {
            "text": "\tconst cYellow = tutorialColor(settings, \"colorYellow\");",
            "lineNumber": 102
          },
          {
            "text": "\tconst cGreen = tutorialColor(settings, \"colorGreen\");",
            "lineNumber": 103
          },
          {
            "lineNumber": 104
          },
          {
            "text": "\t/** Plain text node (no role): use for labels/instructions so they are not treated as comment nodes. */",
            "lineNumber": 105
          },
          {
            "text": "\tconst n = (id: string, text: string, x: number, y: number, color: string, w: number, h: number) =&gt;",
            "lineNumber": 106
          },
          {
            "text": "\t\t({ id, type: \"text\" as const, text, x, y, width: w, height: h, color });",
            "lineNumber": 107
          },
          {
            "text": "\tconst e = (id: string, from: string, to: string, label?: string) =&gt; ({",
            "lineNumber": 108
          },
          {
            "text": "\t\tid,",
            "lineNumber": 109
          },
          {
            "text": "\t\tfromNode: from,",
            "lineNumber": 110
          },
          {
            "text": "\t\ttoNode: to,",
            "lineNumber": 111
          },
          {
            "text": "\t\tfromSide: \"bottom\" as const,",
            "lineNumber": 112
          },
          {
            "text": "\t\ttoSide: \"top\" as const,",
            "lineNumber": 113
          },
          {
            "text": "\t\tlabel: label ?? \"\",",
            "lineNumber": 114
          },
          {
            "text": "\t});",
            "lineNumber": 115
          },
          {
            "text": "\t/** Group node to visually separate a workflow block. */",
            "lineNumber": 116
          },
          {
            "text": "\tconst g = (id: string, x: number, y: number, w: number, h: number, label: string) =&gt;",
            "lineNumber": 117
          },
          {
            "text": "\t\t({ id, type: \"group\" as const, x, y, width: w, height: h, label });",
            "lineNumber": 118
          },
          {
            "lineNumber": 119
          },
          {
            "text": "\t/** Column 1..6: x of left comment margin (column 1 starts right after welcome). */",
            "lineNumber": 120
          },
          {
            "text": "\tconst colLeft = (index: number) =&gt;",
            "lineNumber": 121
          },
          {
            "text": "\t\tTUT_LEFT + TUT_WELCOME_W + TUT_COL_GAP + (index - 1) * (TUT_COL_TOTAL_W + TUT_COL_GAP);",
            "lineNumber": 122
          },
          {
            "text": "\tconst commentLeftX = (colIndex: number) =&gt; colLeft(colIndex);",
            "lineNumber": 123
          },
          {
            "text": "\t/** Node lane: center x; offsetPx shifts right so alternating nodes make arrows more visible. */",
            "lineNumber": 124
          },
          {
            "text": "\tconst laneNodeX = (colIndex: number, offsetPx: number = 0) =&gt;",
            "lineNumber": 125
          },
          {
            "text": "\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + offsetPx;",
            "lineNumber": 126
          },
          {
            "text": "\tconst commentRightX = (colIndex: number) =&gt;",
            "lineNumber": 127
          },
          {
            "text": "\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP;",
            "lineNumber": 128
          },
          {
            "text": "\tconst LANE_OFFSET = 36;",
            "lineNumber": 129
          },
          {
            "lineNumber": 130
          },
          {
            "text": "\t// —— Welcome: alone in first block, no overlap with column 1 ——",
            "lineNumber": 131
          },
          {
            "text": "\tconst welcome = \"welcome\";",
            "lineNumber": 132
          },
          {
            "text": "\tconst welcomeY = TUT_TOP;",
            "lineNumber": 133
          },
          {
            "lineNumber": 134
          },
          {
            "text": "\t// —— Column 1: Primary (comment left, node → output in lane) ——",
            "lineNumber": 135
          },
          {
            "text": "\tconst col1 = 1;",
            "lineNumber": 136
          },
          {
            "text": "\tconst lab1 = \"lab-primary\";",
            "lineNumber": 137
          },
          {
            "text": "\tconst orangeNode = \"orange-example\";",
            "lineNumber": 138
          },
          {
            "text": "\tconst orangeOut = \"orange-out\";",
            "lineNumber": 139
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.2959713935852051
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 166,
            "column": 1
          },
          "endPosition": {
            "line": 180,
            "column": 84
          }
        },
        "contents": "/** Find the node id for an auxiliary edge from source with the given label (e.g. EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING). */\nexport function findAuxiliaryNodeForSource(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\tedgeLabel: string\n): string | null {\n\tconst edge = data.edges.find(\n\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === edgeLabel\n\t);\n\treturn edge ? edge.toNode : null;\n}\n\n/** Check if canvas has any output nodes (green nodes connected by output edges). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Find the node id for an auxiliary edge from source with the given label (e.g. EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING). */",
            "lineNumber": 169
          },
          {
            "text": "export function findAuxiliaryNodeForSource(",
            "lineNumber": 170,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 171,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 172,
            "isSignature": true
          },
          {
            "text": "\tedgeLabel: string",
            "lineNumber": 173,
            "isSignature": true
          },
          {
            "text": "): string | null {",
            "lineNumber": 174,
            "isSignature": true
          },
          {
            "text": "\tconst edge = data.edges.find(",
            "lineNumber": 175
          },
          {
            "text": "\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === edgeLabel",
            "lineNumber": 176
          },
          {
            "text": "\t);",
            "lineNumber": 177
          },
          {
            "text": "\treturn edge ? edge.toNode : null;",
            "lineNumber": 178
          },
          {
            "text": "}",
            "lineNumber": 179,
            "isSignature": true
          },
          {
            "lineNumber": 180
          },
          {
            "text": "/** Check if canvas has any output nodes (green nodes connected by output edges). */",
            "lineNumber": 181
          }
        ]
      },
      "score": 0.2899782657623291
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "column": 76
          },
          "endPosition": {
            "line": 43,
            "column": 99
          }
        },
        "contents": " from \"obsidian\";\nimport {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";\nimport {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";\nimport {CanvasTemplateModal} from \"./views/CanvasTemplateModal\";\nimport {duplicateCanvasTemplate, saveCanvasAsTemplate, isCanvasInTemplateFolder} from \"./canvas/canvasTemplates\";\nimport {\n\tdismissAllOutput as runnerDismissAllOutput,\n\tdismissOutput as runnerDismissOutput,\n\trunChain as runnerRunChain,\n\trunEntireCanvas as runnerRunEntireCanvas,\n\trunNode as runnerRunNode,\n} from \"./engine/runner\";\nimport {\n\tclearCanvasEdgeModeLabels,\n\tclearCanvasLegend,\n\tclearCanvasRoleLabels,\n\tsyncCanvasEdgeModeLabels,\n\tsyncCanvasRoleLabels,\n} from \"./canvas/canvasNodeLabels\";\nimport {hasOutputNodes, loadCanvasData, saveCanvasData} from \"./canvas/nodes\";\nimport type {CanvasData} from \"./canvas/types\";\nimport {EDGE_LABEL_OUTPUT} from \"./canvas/types\";\nimport {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";\nimport {getExample1CanvasData} from \"./tutorials/example1Data\";\nimport {getExample4CanvasData} from \"./tutorials/example4Data\";\n\n/** Layout constants: comment margins left/right, central lane for nodes, no overlap. */\nconst TUT_LEFT = 80;\nconst TUT_TOP = 50;\nconst TUT_WELCOME_W = 420;\nconst TUT_WELCOME_H = 118;\nconst TUT_WELCOME_BOTTOM_GAP = 70;\n/** Per-column: left comment margin | node lane | right comment margin. */\nconst TUT_COMMENT_W = 185;\nconst TUT_LANE_GAP = 22;\nconst TUT_NODE_LANE_W = 260;\nconst TUT_COL_TOTAL_W = TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP + TUT_COMMENT_W;\nconst TUT_COL_GAP = 85;\nconst TUT_NODE_H = 115;\nconst TUT_NODE_GAP = 58;\nconst TUT_LABEL_H = 88;\nconst TUT_GROUP_PAD = 18;\n\n/** Resolve role color from settings (fallback to default so tutorial always has a valid color). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": " from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";",
            "lineNumber": 2
          },
          {
            "text": "import {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";",
            "lineNumber": 3
          },
          {
            "text": "import {CanvasTemplateModal} from \"./views/CanvasTemplateModal\";",
            "lineNumber": 4
          },
          {
            "text": "import {duplicateCanvasTemplate, saveCanvasAsTemplate, isCanvasInTemplateFolder} from \"./canvas/canvasTemplates\";",
            "lineNumber": 5
          },
          {
            "text": "import {",
            "lineNumber": 6
          },
          {
            "text": "\tdismissAllOutput as runnerDismissAllOutput,",
            "lineNumber": 7
          },
          {
            "text": "\tdismissOutput as runnerDismissOutput,",
            "lineNumber": 8
          },
          {
            "text": "\trunChain as runnerRunChain,",
            "lineNumber": 9
          },
          {
            "text": "\trunEntireCanvas as runnerRunEntireCanvas,",
            "lineNumber": 10
          },
          {
            "text": "\trunNode as runnerRunNode,",
            "lineNumber": 11
          },
          {
            "text": "} from \"./engine/runner\";",
            "lineNumber": 12
          },
          {
            "text": "import {",
            "lineNumber": 13
          },
          {
            "text": "\tclearCanvasEdgeModeLabels,",
            "lineNumber": 14
          },
          {
            "text": "\tclearCanvasLegend,",
            "lineNumber": 15
          },
          {
            "text": "\tclearCanvasRoleLabels,",
            "lineNumber": 16
          },
          {
            "text": "\tsyncCanvasEdgeModeLabels,",
            "lineNumber": 17
          },
          {
            "text": "\tsyncCanvasRoleLabels,",
            "lineNumber": 18
          },
          {
            "text": "} from \"./canvas/canvasNodeLabels\";",
            "lineNumber": 19
          },
          {
            "text": "import {hasOutputNodes, loadCanvasData, saveCanvasData} from \"./canvas/nodes\";",
            "lineNumber": 20
          },
          {
            "text": "import type {CanvasData} from \"./canvas/types\";",
            "lineNumber": 21
          },
          {
            "text": "import {EDGE_LABEL_OUTPUT} from \"./canvas/types\";",
            "lineNumber": 22
          },
          {
            "text": "import {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";",
            "lineNumber": 23
          },
          {
            "text": "import {getExample1CanvasData} from \"./tutorials/example1Data\";",
            "lineNumber": 24
          },
          {
            "text": "import {getExample4CanvasData} from \"./tutorials/example4Data\";",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "/** Layout constants: comment margins left/right, central lane for nodes, no overlap. */",
            "lineNumber": 27
          },
          {
            "text": "const TUT_LEFT = 80;",
            "lineNumber": 28
          },
          {
            "text": "const TUT_TOP = 50;",
            "lineNumber": 29
          },
          {
            "text": "const TUT_WELCOME_W = 420;",
            "lineNumber": 30
          },
          {
            "text": "const TUT_WELCOME_H = 118;",
            "lineNumber": 31
          },
          {
            "text": "const TUT_WELCOME_BOTTOM_GAP = 70;",
            "lineNumber": 32
          },
          {
            "text": "/** Per-column: left comment margin | node lane | right comment margin. */",
            "lineNumber": 33
          },
          {
            "text": "const TUT_COMMENT_W = 185;",
            "lineNumber": 34
          },
          {
            "text": "const TUT_LANE_GAP = 22;",
            "lineNumber": 35
          },
          {
            "text": "const TUT_NODE_LANE_W = 260;",
            "lineNumber": 36
          },
          {
            "text": "const TUT_COL_TOTAL_W = TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP + TUT_COMMENT_W;",
            "lineNumber": 37
          },
          {
            "text": "const TUT_COL_GAP = 85;",
            "lineNumber": 38
          },
          {
            "text": "const TUT_NODE_H = 115;",
            "lineNumber": 39
          },
          {
            "text": "const TUT_NODE_GAP = 58;",
            "lineNumber": 40
          },
          {
            "text": "const TUT_LABEL_H = 88;",
            "lineNumber": 41
          },
          {
            "text": "const TUT_GROUP_PAD = 18;",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "/** Resolve role color from settings (fallback to default so tutorial always has a valid color). */",
            "lineNumber": 44
          }
        ]
      },
      "score": 0.27733200788497925
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "absolute|relative|position|edge|arrow",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "glob": "*.ts",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "absolute|relative|position|edge|arrow",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "outputMode": "content",
  "totalFiles": 13,
  "totalMatches": 193,
  "topFiles": [
    {
      "uri": "src/tutorials/example4Data.ts",
      "matchCount": 10
    },
    {
      "uri": "src/canvas/canvasNodeLabels.ts",
      "matchCount": 32
    },
    {
      "uri": "src/engine/runner.ts",
      "matchCount": 57
    },
    {
      "uri": "src/main.ts",
      "matchCount": 18
    },
    {
      "uri": "src/engine/canvasApi.ts",
      "matchCount": 2
    },
    {
      "uri": "src/canvas/nodes.ts",
      "matchCount": 1
    },
    {
      "uri": "src/canvas/types.ts",
      "matchCount": 32
    },
    {
      "uri": "src/canvas/types.test.ts",
      "matchCount": 21
    },
    {
      "uri": "src/canvas/canvasTemplates.ts",
      "matchCount": 4
    },
    {
      "uri": "src/tutorials/example1Data.ts",
      "matchCount": 4
    },
    {
      "uri": "src/views/ZettelControlsView.ts",
      "matchCount": 2
    },
    {
      "uri": "src/engine/state.ts",
      "matchCount": 9
    },
    {
      "uri": "src/engine/state.test.ts",
      "matchCount": 1
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fromEnd|toEnd|fromSide|toSide|endpoint",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "fromEnd|toEnd|fromSide|toSide|endpoint",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
  "outputMode": "content",
  "totalFiles": 3,
  "totalMatches": 16,
  "topFiles": [
    {
      "uri": "./src/engine/runner.ts",
      "matchCount": 10
    },
    {
      "uri": "./src/main.ts",
      "matchCount": 2
    },
    {
      "uri": "./src/canvas/types.test.ts",
      "matchCount": 4
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---



---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "\\.x\\s*=|\\.y\\s*=|fromEnd|toEnd|fromSide|toSide|getBoundingClientRect|getElCenter",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "\\.x\\s*=|\\.y\\s*=|fromEnd|toEnd|fromSide|toSide|getBoundingClientRect|getElCenter",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "outputMode": "content",
  "totalFiles": 4,
  "totalMatches": 26,
  "topFiles": [
    {
      "uri": "src/canvas/canvasNodeLabels.ts",
      "matchCount": 6
    },
    {
      "uri": "src/engine/runner.ts",
      "matchCount": 14
    },
    {
      "uri": "src/main.ts",
      "matchCount": 2
    },
    {
      "uri": "src/canvas/types.test.ts",
      "matchCount": 4
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Where is node position x y set when creating or updating canvas nodes?",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 242,
            "column": 1
          },
          "endPosition": {
            "line": 265,
            "column": 107
          }
        },
        "contents": "/** Copy color (and position/size) from live canvas nodes into data for non-auxiliary nodes so we don't overwrite user edits. */\nfunction mergePreserveUserNodeProps(\n\tdata: CanvasData,\n\tliveData: { nodes: Array&lt;{ id: string; color?: string; x?: number; y?: number; width?: number; height?: number }&gt; }\n): void {\n\tconst liveById = new Map(liveData.nodes.map((n) =&gt; [n.id, n]));\n\tconst auxiliaryIds = getAuxiliaryNodeIds(data);\n\tfor (const node of data.nodes) {\n\t\tif (auxiliaryIds.has(node.id)) continue;\n\t\tconst liveNode = liveById.get(node.id);\n\t\tif (!liveNode) continue;\n\t\tif (liveNode.color !== undefined &amp;&amp; liveNode.color !== \"\") {\n\t\t\t(node as { color?: string }).color = liveNode.color;\n\t\t}\n\t\tif (typeof liveNode.x === \"number\") (node as { x: number }).x = liveNode.x;\n\t\tif (typeof liveNode.y === \"number\") (node as { y: number }).y = liveNode.y;\n\t\tif (typeof liveNode.width === \"number\") (node as { width: number }).width = liveNode.width;\n\t\tif (typeof liveNode.height === \"number\") (node as { height: number }).height = liveNode.height;\n\t}\n}\n\n/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Copy color (and position/size) from live canvas nodes into data for non-auxiliary nodes so we don't overwrite user edits. */",
            "lineNumber": 245
          },
          {
            "text": "function mergePreserveUserNodeProps(",
            "lineNumber": 246,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 247,
            "isSignature": true
          },
          {
            "text": "\tliveData: { nodes: Array&lt;{ id: string; color?: string; x?: number; y?: number; width?: number; height?: number }&gt; }",
            "lineNumber": 248,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 249,
            "isSignature": true
          },
          {
            "text": "\tconst liveById = new Map(liveData.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 250
          },
          {
            "text": "\tconst auxiliaryIds = getAuxiliaryNodeIds(data);",
            "lineNumber": 251
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 252
          },
          {
            "text": "\t\tif (auxiliaryIds.has(node.id)) continue;",
            "lineNumber": 253
          },
          {
            "text": "\t\tconst liveNode = liveById.get(node.id);",
            "lineNumber": 254
          },
          {
            "text": "\t\tif (!liveNode) continue;",
            "lineNumber": 255
          },
          {
            "text": "\t\tif (liveNode.color !== undefined &amp;&amp; liveNode.color !== \"\") {",
            "lineNumber": 256
          },
          {
            "text": "\t\t\t(node as { color?: string }).color = liveNode.color;",
            "lineNumber": 257
          },
          {
            "text": "\t\t}",
            "lineNumber": 258
          },
          {
            "text": "\t\tif (typeof liveNode.x === \"number\") (node as { x: number }).x = liveNode.x;",
            "lineNumber": 259
          },
          {
            "text": "\t\tif (typeof liveNode.y === \"number\") (node as { y: number }).y = liveNode.y;",
            "lineNumber": 260
          },
          {
            "text": "\t\tif (typeof liveNode.width === \"number\") (node as { width: number }).width = liveNode.width;",
            "lineNumber": 261
          },
          {
            "text": "\t\tif (typeof liveNode.height === \"number\") (node as { height: number }).height = liveNode.height;",
            "lineNumber": 262
          },
          {
            "text": "\t}",
            "lineNumber": 263
          },
          {
            "text": "}",
            "lineNumber": 264,
            "isSignature": true
          },
          {
            "lineNumber": 265
          },
          {
            "text": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
            "lineNumber": 266
          }
        ]
      },
      "score": 0.3855246305465698
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 530,
            "column": 1
          },
          "endPosition": {
            "line": 753,
            "column": 1
          }
        },
        "contents": "/** Create or replace the Green output node (and optional prompt/thinking nodes) and ensure edges from source. Mutates data only. */\nfunction ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\tconst { fullPrompt, thinking } = options;\n\tconst promptId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_PROMPT);\n\tconst thinkingId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING);\n\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);\n\n\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;\n\tconst width = Math.max(320, sourceNode.width);\n\tconst height = 180;\n\tconst defaultX = sourceNode.x;\n\tconst extraExclude = [promptId, thinkingId].filter((id): id is string =&gt; id != null);\n\n\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(\n\t\tdata,\n\t\tsourceNode.id,\n\t\toutId,\n\t\tdefaultX,\n\t\tdefaultY,\n\t\twidth,\n\t\theight,\n\t\textraExclude\n\t);\n\tconst greenColor = settings.colorGreen;\n\n\t// 1. Ensure output node\n\tlet resolvedOutputId: string;\n\tif (outId) {\n\t\tresolvedOutputId = outId;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Create or replace the Green output node (and optional prompt/thinking nodes) and ensure edges from source. Mutates data only. */",
            "lineNumber": 533
          },
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 536,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 538,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 539,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 540,
            "isSignature": true
          },
          {
            "text": "\tconst { fullPrompt, thinking } = options;",
            "lineNumber": 541
          },
          {
            "text": "\tconst promptId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_PROMPT);",
            "lineNumber": 542
          },
          {
            "text": "\tconst thinkingId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING);",
            "lineNumber": 543
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);",
            "lineNumber": 544
          },
          {
            "lineNumber": 545
          },
          {
            "text": "\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;",
            "lineNumber": 546
          },
          {
            "text": "\tconst width = Math.max(320, sourceNode.width);",
            "lineNumber": 547
          },
          {
            "text": "\tconst height = 180;",
            "lineNumber": 548
          },
          {
            "text": "\tconst defaultX = sourceNode.x;",
            "lineNumber": 549
          },
          {
            "text": "\tconst extraExclude = [promptId, thinkingId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 550
          },
          {
            "lineNumber": 551
          },
          {
            "text": "\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(",
            "lineNumber": 552
          },
          {
            "text": "\t\tdata,",
            "lineNumber": 553
          },
          {
            "text": "\t\tsourceNode.id,",
            "lineNumber": 554
          },
          {
            "text": "\t\toutId,",
            "lineNumber": 555
          },
          {
            "text": "\t\tdefaultX,",
            "lineNumber": 556
          },
          {
            "text": "\t\tdefaultY,",
            "lineNumber": 557
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 558
          },
          {
            "text": "\t\theight,",
            "lineNumber": 559
          },
          {
            "text": "\t\textraExclude",
            "lineNumber": 560
          },
          {
            "text": "\t);",
            "lineNumber": 561
          },
          {
            "text": "\tconst greenColor = settings.colorGreen;",
            "lineNumber": 562
          },
          {
            "lineNumber": 563
          },
          {
            "text": "\t// 1. Ensure output node",
            "lineNumber": 564
          },
          {
            "text": "\tlet resolvedOutputId: string;",
            "lineNumber": 565
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 566
          },
          {
            "text": "\t\tresolvedOutputId = outId;",
            "lineNumber": 567
          },
          {
            "text": "}",
            "lineNumber": 754,
            "isSignature": true
          }
        ]
      },
      "score": 0.3612903952598572
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 449,
            "column": 1
          },
          "endPosition": {
            "line": 497,
            "column": 1
          }
        },
        "contents": "/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */\nfunction chooseOutputPositionXY(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\toutNodeId: string | null,\n\tdefaultX: number,\n\tdefaultY: number,\n\twidth: number,\n\theight: number,\n\textraExcludeIds: string[] = []\n): { x: number; y: number } {\n\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);\n\tif (outNodeId) excludeIds.add(outNodeId);\n\tfor (const id of extraExcludeIds) excludeIds.add(id);\n\tconst box = { x: 0, y: 0, width, height };\n\tfunction tryPosition(x: number, y: number): boolean {\n\t\tbox.x = x;\n\t\tbox.y = y;\n\t\tfor (const node of data.nodes) {\n\t\t\tif (excludeIds.has(node.id)) continue;\n\t\t\t// Expand other node by buffer so we keep at least OUTPUT_COLLISION_BUFFER gap\n\t\t\tconst expanded = {\n\t\t\t\tx: node.x - OUTPUT_COLLISION_BUFFER,\n\t\t\t\ty: node.y - OUTPUT_COLLISION_BUFFER,\n\t\t\t\twidth: node.width + 2 * OUTPUT_COLLISION_BUFFER,\n\t\t\t\theight: node.height + 2 * OUTPUT_COLLISION_BUFFER,\n\t\t\t};\n\t\t\tif (rectanglesOverlap(box, expanded)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {\n\t\tconst candidateY = defaultY + dy;\n\t\tfor (const dx of xOffsets()) {\n\t\t\tif (tryPosition(defaultX + dx, candidateY)) return { x: defaultX + dx, y: candidateY };\n\t\t}\n\t}\n\treturn { x: defaultX, y: defaultY };\n}\n\nfunction* xOffsets(): Generator&lt;number&gt; {\n\tyield 0;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */",
            "lineNumber": 452
          },
          {
            "text": "function chooseOutputPositionXY(",
            "lineNumber": 453,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 454,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 455,
            "isSignature": true
          },
          {
            "text": "\toutNodeId: string | null,",
            "lineNumber": 456,
            "isSignature": true
          },
          {
            "text": "\tdefaultX: number,",
            "lineNumber": 457,
            "isSignature": true
          },
          {
            "text": "\tdefaultY: number,",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "\twidth: number,",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "\theight: number,",
            "lineNumber": 460,
            "isSignature": true
          },
          {
            "text": "\textraExcludeIds: string[] = []",
            "lineNumber": 461,
            "isSignature": true
          },
          {
            "text": "): { x: number; y: number } {",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);",
            "lineNumber": 463
          },
          {
            "text": "\tif (outNodeId) excludeIds.add(outNodeId);",
            "lineNumber": 464
          },
          {
            "text": "\tfor (const id of extraExcludeIds) excludeIds.add(id);",
            "lineNumber": 465
          },
          {
            "text": "\tconst box = { x: 0, y: 0, width, height };",
            "lineNumber": 466
          },
          {
            "text": "\tfunction tryPosition(x: number, y: number): boolean {",
            "lineNumber": 467,
            "isSignature": true
          },
          {
            "text": "\t\tbox.x = x;",
            "lineNumber": 468
          },
          {
            "text": "\t\tbox.y = y;",
            "lineNumber": 469
          },
          {
            "text": "\t\tfor (const node of data.nodes) {",
            "lineNumber": 470
          },
          {
            "text": "\t\t\tif (excludeIds.has(node.id)) continue;",
            "lineNumber": 471
          },
          {
            "text": "\t\t\t// Expand other node by buffer so we keep at least OUTPUT_COLLISION_BUFFER gap",
            "lineNumber": 472
          },
          {
            "text": "\t\t\tconst expanded = {",
            "lineNumber": 473
          },
          {
            "text": "\t\t\t\tx: node.x - OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 474
          },
          {
            "text": "\t\t\t\ty: node.y - OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 475
          },
          {
            "text": "\t\t\t\twidth: node.width + 2 * OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 476
          },
          {
            "text": "\t\t\t\theight: node.height + 2 * OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 477
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 478
          },
          {
            "text": "\t\t\tif (rectanglesOverlap(box, expanded)) return false;",
            "lineNumber": 479
          },
          {
            "text": "\t\t}",
            "lineNumber": 480
          },
          {
            "text": "\t\treturn true;",
            "lineNumber": 481
          },
          {
            "text": "\t}",
            "lineNumber": 482,
            "isSignature": true
          },
          {
            "text": "\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {",
            "lineNumber": 483
          },
          {
            "text": "\t\tconst candidateY = defaultY + dy;",
            "lineNumber": 484
          },
          {
            "text": "\t\tfor (const dx of xOffsets()) {",
            "lineNumber": 485
          },
          {
            "text": "\t\t\tif (tryPosition(defaultX + dx, candidateY)) return { x: defaultX + dx, y: candidateY };",
            "lineNumber": 486
          },
          {
            "text": "\t\t}",
            "lineNumber": 487
          },
          {
            "text": "\t}",
            "lineNumber": 488
          },
          {
            "text": "\treturn { x: defaultX, y: defaultY };",
            "lineNumber": 489
          },
          {
            "text": "}",
            "lineNumber": 490,
            "isSignature": true
          },
          {
            "lineNumber": 491
          },
          {
            "text": "function* xOffsets(): Generator&lt;number&gt; {",
            "lineNumber": 492,
            "isSignature": true
          },
          {
            "text": "\tyield 0;",
            "lineNumber": 493
          },
          {
            "text": "}",
            "lineNumber": 498,
            "isSignature": true
          }
        ]
      },
      "score": 0.36022889614105225
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/canvasApi.ts",
        "range": {
          "startPosition": {
            "column": 86
          },
          "endPosition": {
            "line": 17,
            "column": 1
          }
        },
        "contents": "export interface LiveCanvas {\n\tcreateTextNode(options: {\n\t\ttext: string;\n\t\tpos: { x: number; y: number };\n\t\tsize: { width: number; height: number };\n\t\tsave?: boolean;\n\t\tfocus?: boolean;\n\t}): { id: string; x: number; y: number; width: number; height: number; moveTo: (pos: { x: number; y: number }) =&gt; void; resize: (size: { width: number; height: number }) =&gt; void };\n\taddNode(node: unknown): void;\n\trequestSave?: () =&gt; void;\n\tremoveNode?(node: unknown): void;\n\tnodes?: Map&lt;string, unknown&gt; | Iterable&lt;unknown&gt;;\n\t/** If present, used to refresh canvas after edge label updates (Obsidian canvas view). */\n\tsetData?(data: unknown): void;\n\t/** If present, returns current canvas data from the view (used to preserve user edits like node color when saving). */\n\tgetData?(): { nodes: Array&lt;{ id: string; color?: string; x?: number; y?: number; width?: number; height?: number; [k: string]: unknown }&gt;; edges: unknown[] } | undefined;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export interface LiveCanvas {",
            "lineNumber": 2,
            "isSignature": true
          },
          {
            "text": "\tcreateTextNode(options: {",
            "lineNumber": 3
          },
          {
            "text": "\t\ttext: string;",
            "lineNumber": 4
          },
          {
            "text": "\t\tpos: { x: number; y: number };",
            "lineNumber": 5
          },
          {
            "text": "\t\tsize: { width: number; height: number };",
            "lineNumber": 6
          },
          {
            "text": "\t\tsave?: boolean;",
            "lineNumber": 7
          },
          {
            "text": "\t\tfocus?: boolean;",
            "lineNumber": 8
          },
          {
            "text": "\t}): { id: string; x: number; y: number; width: number; height: number; moveTo: (pos: { x: number; y: number }) =&gt; void; resize: (size: { width: number; height: number }) =&gt; void };",
            "lineNumber": 9
          },
          {
            "text": "\taddNode(node: unknown): void;",
            "lineNumber": 10
          },
          {
            "text": "\trequestSave?: () =&gt; void;",
            "lineNumber": 11
          },
          {
            "text": "\tremoveNode?(node: unknown): void;",
            "lineNumber": 12
          },
          {
            "text": "\tnodes?: Map&lt;string, unknown&gt; | Iterable&lt;unknown&gt;;",
            "lineNumber": 13
          },
          {
            "text": "\t/** If present, used to refresh canvas after edge label updates (Obsidian canvas view). */",
            "lineNumber": 14
          },
          {
            "text": "\tsetData?(data: unknown): void;",
            "lineNumber": 15
          },
          {
            "text": "\t/** If present, returns current canvas data from the view (used to preserve user edits like node color when saving). */",
            "lineNumber": 16
          },
          {
            "text": "\tgetData?(): { nodes: Array&lt;{ id: string; color?: string; x?: number; y?: number; width?: number; height?: number; [k: string]: unknown }&gt;; edges: unknown[] } | undefined;",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "text": "}",
            "lineNumber": 18,
            "isSignature": true
          }
        ]
      },
      "score": 0.35747575759887695
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 533
          },
          "endPosition": {
            "line": 753,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\n\tif (outId) {\n\t\tresolvedOutputId = outId;\n\t\tconst outNode = getNodeById(data, outId);\n\t\tif (outNode &amp;&amp; isTextNode(outNode)) {\n\t\t\tconst existingX = (outNode as CanvasTextData).x;\n\t\t\tconst existingY = (outNode as CanvasTextData).y;\n\t\t\tconst updated = {\n\t\t\t\t...(outNode as CanvasTextData),\n\t\t\t\ttext,\n\t\t\t\tx: existingX,\n\t\t\t\ty: existingY,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t};\n\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);\n\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t}\n\t\tconst hasOutputEdge = data.edges.some(\n\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t\t);\n\t\tif (!hasOutputEdge) {\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: outId,\n\t\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tconst newNodeId = randomId();\n\t\tresolvedOutputId = newNodeId;\n\t\tconst newTextNode: CanvasTextData = {\n\t\t\tid: newNodeId,\n\t\t\ttype: \"text\",\n\t\t\ttext,\n\t\t\tx: chosenX,\n\t\t\ty: chosenY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tcolor: greenColor,\n\t\t};\n\t\tdata.nodes.push(newTextNode);\n\t\tdata.edges.push({\n\t\t\tid: randomId(),\n\t\t\tfromNode: sourceNode.id,\n\t\t\ttoNode: newNodeId,\n\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t});\n\t}\n\n\tconst outputNode = getNodeById(data, resolvedOutputId);\n\tconst outputY = outputNode &amp;&amp; \"y\" in outputNode ? (outputNode as { y: number }).y : chosenY;\n\n\t// 2. Ensure thinking node (above output) when setting on and thinking present\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 534,
                "column": 1
              },
              "endPosition": {
                "line": 541,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 536,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 538,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 539,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 540,
            "isSignature": true
          },
          {
            "lineNumber": 565
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 566
          },
          {
            "text": "\t\tresolvedOutputId = outId;",
            "lineNumber": 567
          },
          {
            "text": "\t\tconst outNode = getNodeById(data, outId);",
            "lineNumber": 568
          },
          {
            "text": "\t\tif (outNode &amp;&amp; isTextNode(outNode)) {",
            "lineNumber": 569
          },
          {
            "text": "\t\t\tconst existingX = (outNode as CanvasTextData).x;",
            "lineNumber": 570
          },
          {
            "text": "\t\t\tconst existingY = (outNode as CanvasTextData).y;",
            "lineNumber": 571
          },
          {
            "text": "\t\t\tconst updated = {",
            "lineNumber": 572
          },
          {
            "text": "\t\t\t\t...(outNode as CanvasTextData),",
            "lineNumber": 573
          },
          {
            "text": "\t\t\t\ttext,",
            "lineNumber": 574
          },
          {
            "text": "\t\t\t\tx: existingX,",
            "lineNumber": 575
          },
          {
            "text": "\t\t\t\ty: existingY,",
            "lineNumber": 576
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 577
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 578
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 579
          },
          {
            "text": "\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);",
            "lineNumber": 580
          },
          {
            "text": "\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 581
          },
          {
            "text": "\t\t}",
            "lineNumber": 582
          },
          {
            "text": "\t\tconst hasOutputEdge = data.edges.some(",
            "lineNumber": 583
          },
          {
            "text": "\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 584
          },
          {
            "text": "\t\t);",
            "lineNumber": 585
          },
          {
            "text": "\t\tif (!hasOutputEdge) {",
            "lineNumber": 586
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 587
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 588
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 589
          },
          {
            "text": "\t\t\t\ttoNode: outId,",
            "lineNumber": 590
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 591
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 592
          },
          {
            "text": "\t\t}",
            "lineNumber": 593
          },
          {
            "text": "\t} else {",
            "lineNumber": 594
          },
          {
            "text": "\t\tconst newNodeId = randomId();",
            "lineNumber": 595
          },
          {
            "text": "\t\tresolvedOutputId = newNodeId;",
            "lineNumber": 596
          },
          {
            "text": "\t\tconst newTextNode: CanvasTextData = {",
            "lineNumber": 597
          },
          {
            "text": "\t\t\tid: newNodeId,",
            "lineNumber": 598
          },
          {
            "text": "\t\t\ttype: \"text\",",
            "lineNumber": 599
          },
          {
            "text": "\t\t\ttext,",
            "lineNumber": 600
          },
          {
            "text": "\t\t\tx: chosenX,",
            "lineNumber": 601
          },
          {
            "text": "\t\t\ty: chosenY,",
            "lineNumber": 602
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 603
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 604
          },
          {
            "text": "\t\t\tcolor: greenColor,",
            "lineNumber": 605
          },
          {
            "text": "\t\t};",
            "lineNumber": 606
          },
          {
            "text": "\t\tdata.nodes.push(newTextNode);",
            "lineNumber": 607
          },
          {
            "text": "\t\tdata.edges.push({",
            "lineNumber": 608
          },
          {
            "text": "\t\t\tid: randomId(),",
            "lineNumber": 609
          },
          {
            "text": "\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 610
          },
          {
            "text": "\t\t\ttoNode: newNodeId,",
            "lineNumber": 611
          },
          {
            "text": "\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 612
          },
          {
            "text": "\t\t});",
            "lineNumber": 613
          },
          {
            "text": "\t}",
            "lineNumber": 614
          },
          {
            "lineNumber": 615
          },
          {
            "text": "\tconst outputNode = getNodeById(data, resolvedOutputId);",
            "lineNumber": 616
          },
          {
            "text": "\tconst outputY = outputNode &amp;&amp; \"y\" in outputNode ? (outputNode as { y: number }).y : chosenY;",
            "lineNumber": 617
          },
          {
            "lineNumber": 618
          },
          {
            "text": "\t// 2. Ensure thinking node (above output) when setting on and thinking present",
            "lineNumber": 619
          },
          {
            "text": "}",
            "lineNumber": 754,
            "isSignature": true
          }
        ]
      },
      "score": 0.3399454355239868
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 158
          },
          "endPosition": {
            "line": 236,
            "column": 1
          }
        },
        "contents": "export async function syncCanvasRoleLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tsettings: ZettelPluginSettings,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\nconst thinkingNodeIds = new \n\n((e) =&gt; e.toNode)\n\t);\n\n\tfor (const node of data.nodes) {\n\t\tconst nodeEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||\n\t\t\tfindNodeElementByDataId(containerEl, node.id);\n\t\tif (!nodeEl) continue;\n\t\t// Append to root .canvas-node so position:absolute is relative to the full card (avoids overlapping file title)\n\t\tconst rootEl =\n\t\t\tnodeEl.classList.contains(\"canvas-node\")\n\t\t\t\t? nodeEl\n\t\t\t\t: (nodeEl.closest(\".canvas-node\") as HTMLElement | null) ?? nodeEl;\n\n\t\tlet labelText: string | null = null;\n\t\tconst role = getNodeRole(node, settings);\n\t\tif (role) {\n\t\t\tlabelText = getRoleLabel(role, settings);\n\t\t} else if (promptNodeIds.has(node.id)) {\n\t\t\tlabelText = \"Prompt\";\n\t\t} else if (thinkingNodeIds.has(node.id)) {\n\t\t\tlabelText = \"Thinking\";\n\t\t}\n\t\tif (labelText) {\n\t\t\tconst label = createLabelEl(labelText);\n\t\t\trootEl.prepend(label);\n\t\t}\n\n\t\tconst orderIndex = orderByNodeId.get(node.id);\n\t\tif (orderIndex != null) {\n\t\t\tconst badge = createOrderBadgeEl(orderIndex);\n\t\t\trootEl.prepend(badge);\n\t\t}\n\t}\n}\n\n/** Get center of an element in viewport coordinates. */\nfunction getElCenter(el: HTMLElement): { x: number; y: number } {\n\tconst r = el.getBoundingClientRect();\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 159,
                "column": 1
              },
              "endPosition": {
                "line": 159,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 159,
                "column": 8
              },
              "endPosition": {
                "line": 167,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function syncCanvasRoleLabels(",
            "lineNumber": 159,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 160,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 161,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 162,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 163,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 164,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 165,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 166,
            "isSignature": true
          },
          {
            "text": "const thinkingNodeIds = new ",
            "lineNumber": 194
          },
          {
            "lineNumber": 195
          },
          {
            "text": "((e) =&gt; e.toNode)",
            "lineNumber": 197
          },
          {
            "text": "\t);",
            "lineNumber": 198
          },
          {
            "lineNumber": 199
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 200
          },
          {
            "text": "\t\tconst nodeEl =",
            "lineNumber": 201
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||",
            "lineNumber": 202
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, node.id);",
            "lineNumber": 203
          },
          {
            "text": "\t\tif (!nodeEl) continue;",
            "lineNumber": 204
          },
          {
            "text": "\t\t// Append to root .canvas-node so position:absolute is relative to the full card (avoids overlapping file title)",
            "lineNumber": 205
          },
          {
            "text": "\t\tconst rootEl =",
            "lineNumber": 206
          },
          {
            "text": "\t\t\tnodeEl.classList.contains(\"canvas-node\")",
            "lineNumber": 207
          },
          {
            "text": "\t\t\t\t? nodeEl",
            "lineNumber": 208
          },
          {
            "text": "\t\t\t\t: (nodeEl.closest(\".canvas-node\") as HTMLElement | null) ?? nodeEl;",
            "lineNumber": 209
          },
          {
            "lineNumber": 210
          },
          {
            "text": "\t\tlet labelText: string | null = null;",
            "lineNumber": 211
          },
          {
            "text": "\t\tconst role = getNodeRole(node, settings);",
            "lineNumber": 212
          },
          {
            "text": "\t\tif (role) {",
            "lineNumber": 213
          },
          {
            "text": "\t\t\tlabelText = getRoleLabel(role, settings);",
            "lineNumber": 214
          },
          {
            "text": "\t\t} else if (promptNodeIds.has(node.id)) {",
            "lineNumber": 215
          },
          {
            "text": "\t\t\tlabelText = \"Prompt\";",
            "lineNumber": 216
          },
          {
            "text": "\t\t} else if (thinkingNodeIds.has(node.id)) {",
            "lineNumber": 217
          },
          {
            "text": "\t\t\tlabelText = \"Thinking\";",
            "lineNumber": 218
          },
          {
            "text": "\t\t}",
            "lineNumber": 219
          },
          {
            "text": "\t\tif (labelText) {",
            "lineNumber": 220
          },
          {
            "text": "\t\t\tconst label = createLabelEl(labelText);",
            "lineNumber": 221
          },
          {
            "text": "\t\t\trootEl.prepend(label);",
            "lineNumber": 222
          },
          {
            "text": "\t\t}",
            "lineNumber": 223
          },
          {
            "lineNumber": 224
          },
          {
            "text": "\t\tconst orderIndex = orderByNodeId.get(node.id);",
            "lineNumber": 225
          },
          {
            "text": "\t\tif (orderIndex != null) {",
            "lineNumber": 226
          },
          {
            "text": "\t\t\tconst badge = createOrderBadgeEl(orderIndex);",
            "lineNumber": 227
          },
          {
            "text": "\t\t\trootEl.prepend(badge);",
            "lineNumber": 228
          },
          {
            "text": "\t\t}",
            "lineNumber": 229
          },
          {
            "text": "\t}",
            "lineNumber": 230
          },
          {
            "text": "}",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "lineNumber": 232
          },
          {
            "text": "/** Get center of an element in viewport coordinates. */",
            "lineNumber": 233
          },
          {
            "text": "function getElCenter(el: HTMLElement): { x: number; y: number } {",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "\tconst r = el.getBoundingClientRect();",
            "lineNumber": 235
          },
          {
            "text": "}",
            "lineNumber": 237,
            "isSignature": true
          }
        ]
      },
      "score": 0.30432385206222534
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 533
          },
          "endPosition": {
            "line": 753,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\n\n\t// 2. Ensure thinking node (above output) when setting on and thinking present\n\tif (settings.showThinkingNode &amp;&amp; thinking != null &amp;&amp; thinking.length &gt; 0) {\n\t\tconst thinkingSide = chooseFreeSideForAuxiliaryEdge(data, sourceNode.id);\n\t\tconst thinkingDefaultY = outputY - height - GREEN_NODE_PADDING;\n\t\tconst thinkingExclude = [sourceNode.id, resolvedOutputId, promptId].filter((id): id is string =&gt; id != null);\n\t\tconst { x: tx, y: ty } = chooseOutputPositionXY(\n\t\t\tdata,\n\t\t\tsourceNode.id,\n\t\t\tthinkingId,\n\t\t\tdefaultX,\n\t\t\tthinkingDefaultY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tthinkingExclude\n\t\t);\n\t\tconst thinkingColor = shadeColor(settings.colorGreen, 0.15);\n\n\t\tif (thinkingId) {\n\t\t\tconst tn = getNodeById(data, thinkingId);\n\t\t\tif (tn &amp;&amp; isTextNode(tn)) {\n\t\t\t\tconst updated = {\n\t\t\t\t\t...(tn as CanvasTextData),\n\t\t\t\t\ttext: thinking,\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\tcolor: thinkingColor,\n\t\t\t\t};\n\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === thinkingId);\n\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t\t}\n\t\t\tconst hasEdge = data.edges.some(\n\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === thinkingId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING\n\t\t\t);\n\t\t\tif (!hasEdge) {\n\t\t\t\tdata.edges.push({\n\t\t\t\t\tid: randomId(),\n\t\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\t\tfromSide: thinkingSide,\n\t\t\t\t\ttoNode: thinkingId,\n\t\t\t\t\ttoSide: thinkingSide === \"left\" ? \"right\" : thinkingSide === \"right\" ? \"left\" : thinkingSide === \"top\" ? \"bottom\" : \"top\",\n\t\t\t\t\tlabel: EDGE_LABEL_THINKING,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst newId = randomId();\n\t\t\tdata.nodes.push({\n\t\t\t\tid: newId,\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: thinking,\n\t\t\t\tx: tx,\n\t\t\t\ty: ty,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tcolor: thinkingColor,\n\t\t\t} as CanvasTextData);\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\tfromSide: thinkingSide,\n\t\t\t\ttoNode: newId,\n\t\t\t\ttoSide: thinkingSide === \"left\" ? \"right\" : thinkingSide === \"right\" ? \"left\" : thinkingSide === \"top\" ? \"bottom\" : \"top\",\n\t\t\t\tlabel: EDGE_LABEL_THINKING,\n\t\t\t});\n\t\t}\n\t}\n\n\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 534,
                "column": 1
              },
              "endPosition": {
                "line": 541,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 536,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 538,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 539,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 540,
            "isSignature": true
          },
          {
            "lineNumber": 617
          },
          {
            "lineNumber": 618
          },
          {
            "text": "\t// 2. Ensure thinking node (above output) when setting on and thinking present",
            "lineNumber": 619
          },
          {
            "text": "\tif (settings.showThinkingNode &amp;&amp; thinking != null &amp;&amp; thinking.length &gt; 0) {",
            "lineNumber": 620
          },
          {
            "text": "\t\tconst thinkingSide = chooseFreeSideForAuxiliaryEdge(data, sourceNode.id);",
            "lineNumber": 621
          },
          {
            "text": "\t\tconst thinkingDefaultY = outputY - height - GREEN_NODE_PADDING;",
            "lineNumber": 622
          },
          {
            "text": "\t\tconst thinkingExclude = [sourceNode.id, resolvedOutputId, promptId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 623
          },
          {
            "text": "\t\tconst { x: tx, y: ty } = chooseOutputPositionXY(",
            "lineNumber": 624
          },
          {
            "text": "\t\t\tdata,",
            "lineNumber": 625
          },
          {
            "text": "\t\t\tsourceNode.id,",
            "lineNumber": 626
          },
          {
            "text": "\t\t\tthinkingId,",
            "lineNumber": 627
          },
          {
            "text": "\t\t\tdefaultX,",
            "lineNumber": 628
          },
          {
            "text": "\t\t\tthinkingDefaultY,",
            "lineNumber": 629
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 630
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 631
          },
          {
            "text": "\t\t\tthinkingExclude",
            "lineNumber": 632
          },
          {
            "text": "\t\t);",
            "lineNumber": 633
          },
          {
            "text": "\t\tconst thinkingColor = shadeColor(settings.colorGreen, 0.15);",
            "lineNumber": 634
          },
          {
            "lineNumber": 635
          },
          {
            "text": "\t\tif (thinkingId) {",
            "lineNumber": 636
          },
          {
            "text": "\t\t\tconst tn = getNodeById(data, thinkingId);",
            "lineNumber": 637
          },
          {
            "text": "\t\t\tif (tn &amp;&amp; isTextNode(tn)) {",
            "lineNumber": 638
          },
          {
            "text": "\t\t\t\tconst updated = {",
            "lineNumber": 639
          },
          {
            "text": "\t\t\t\t\t...(tn as CanvasTextData),",
            "lineNumber": 640
          },
          {
            "text": "\t\t\t\t\ttext: thinking,",
            "lineNumber": 641
          },
          {
            "text": "\t\t\t\t\twidth,",
            "lineNumber": 642
          },
          {
            "text": "\t\t\t\t\theight,",
            "lineNumber": 643
          },
          {
            "text": "\t\t\t\t\tcolor: thinkingColor,",
            "lineNumber": 644
          },
          {
            "text": "\t\t\t\t};",
            "lineNumber": 645
          },
          {
            "text": "\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === thinkingId);",
            "lineNumber": 646
          },
          {
            "text": "\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 647
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 648
          },
          {
            "text": "\t\t\tconst hasEdge = data.edges.some(",
            "lineNumber": 649
          },
          {
            "text": "\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === thinkingId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING",
            "lineNumber": 650
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 651
          },
          {
            "text": "\t\t\tif (!hasEdge) {",
            "lineNumber": 652
          },
          {
            "text": "\t\t\t\tdata.edges.push({",
            "lineNumber": 653
          },
          {
            "text": "\t\t\t\t\tid: randomId(),",
            "lineNumber": 654
          },
          {
            "text": "\t\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 655
          },
          {
            "text": "\t\t\t\t\tfromSide: thinkingSide,",
            "lineNumber": 656
          },
          {
            "text": "\t\t\t\t\ttoNode: thinkingId,",
            "lineNumber": 657
          },
          {
            "text": "\t\t\t\t\ttoSide: thinkingSide === \"left\" ? \"right\" : thinkingSide === \"right\" ? \"left\" : thinkingSide === \"top\" ? \"bottom\" : \"top\",",
            "lineNumber": 658
          },
          {
            "text": "\t\t\t\t\tlabel: EDGE_LABEL_THINKING,",
            "lineNumber": 659
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 660
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 661
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 662
          },
          {
            "text": "\t\t\tconst newId = randomId();",
            "lineNumber": 663
          },
          {
            "text": "\t\t\tdata.nodes.push({",
            "lineNumber": 664
          },
          {
            "text": "\t\t\t\tid: newId,",
            "lineNumber": 665
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 666
          },
          {
            "text": "\t\t\t\ttext: thinking,",
            "lineNumber": 667
          },
          {
            "text": "\t\t\t\tx: tx,",
            "lineNumber": 668
          },
          {
            "text": "\t\t\t\ty: ty,",
            "lineNumber": 669
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 670
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 671
          },
          {
            "text": "\t\t\t\tcolor: thinkingColor,",
            "lineNumber": 672
          },
          {
            "text": "\t\t\t} as CanvasTextData);",
            "lineNumber": 673
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 674
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 675
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 676
          },
          {
            "text": "\t\t\t\tfromSide: thinkingSide,",
            "lineNumber": 677
          },
          {
            "text": "\t\t\t\ttoNode: newId,",
            "lineNumber": 678
          },
          {
            "text": "\t\t\t\ttoSide: thinkingSide === \"left\" ? \"right\" : thinkingSide === \"right\" ? \"left\" : thinkingSide === \"top\" ? \"bottom\" : \"top\",",
            "lineNumber": 679
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_THINKING,",
            "lineNumber": 680
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 681
          },
          {
            "text": "\t\t}",
            "lineNumber": 682
          },
          {
            "text": "\t}",
            "lineNumber": 683
          },
          {
            "lineNumber": 684
          },
          {
            "text": "\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present",
            "lineNumber": 685
          },
          {
            "text": "}",
            "lineNumber": 754,
            "isSignature": true
          }
        ]
      },
      "score": 0.29498815536499023
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 753,
            "column": 1
          },
          "endPosition": {
            "line": 788,
            "column": 93
          }
        },
        "contents": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */\nexport async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return { ok: false, message: \"Node not found.\" };\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };\n\tconst parentIds = getParentIdsSortedByY(nodeId, data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tfor (const pid of parentIds) {\n\t\tif (getNodeResult(canvasKey, pid) == null) {\n\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);\n\t\t}\n\t}\n\ttry {\n\t\tsetRunningNodeId(canvasKey, nodeId);\n\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t} finally {\n\t\tsetRunningNodeId(canvasKey, null);\n\t}\n}\n\nconst CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 756
          },
          {
            "text": "export async function runNode(",
            "lineNumber": 757,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 758,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 759,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 760,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 761,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 762,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 763,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 764
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 765
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 766
          },
          {
            "text": "\tif (!node) return { ok: false, message: \"Node not found.\" };",
            "lineNumber": 767
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 768
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 769
          },
          {
            "text": "\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };",
            "lineNumber": 770
          },
          {
            "text": "\tconst parentIds = getParentIdsSortedByY(nodeId, data);",
            "lineNumber": 771
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 772
          },
          {
            "text": "\tfor (const pid of parentIds) {",
            "lineNumber": 773
          },
          {
            "text": "\t\tif (getNodeResult(canvasKey, pid) == null) {",
            "lineNumber": 774
          },
          {
            "text": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);",
            "lineNumber": 775
          },
          {
            "text": "\t\t}",
            "lineNumber": 776
          },
          {
            "text": "\t}",
            "lineNumber": 777
          },
          {
            "text": "\ttry {",
            "lineNumber": 778
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, nodeId);",
            "lineNumber": 779
          },
          {
            "text": "\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);",
            "lineNumber": 780
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 781
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 782
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 783
          },
          {
            "text": "\t} finally {",
            "lineNumber": 784
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 785
          },
          {
            "text": "\t}",
            "lineNumber": 786
          },
          {
            "text": "}",
            "lineNumber": 787,
            "isSignature": true
          },
          {
            "lineNumber": 788
          },
          {
            "text": "const CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";",
            "lineNumber": 789
          }
        ]
      },
      "score": 0.29347193241119385
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 266
          },
          "endPosition": {
            "line": 310,
            "column": 117
          }
        },
        "contents": "async function updateEdgeLabelsAndSave(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tedgeModes: Map&lt;string, EdgeInputMode&gt;,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\n\t// #endregion\n\tif (liveData?.nodes) {\n\t\tmergePreserveUserNodeProps(data, liveData);\n\t\t// #region agent log\n\t\tconst nodeAfterMerge = getNodeById(data, nodeId);\n\t\tfetch(\"http://127.0.0.1:7243/ingest/453147b6-6b57-40b4-a769-82c9dd3c5ee7\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ location: \"runner.ts:updateEdgeLabelsAndSave\", message: \"after merge\", data: { nodeId, nodeColorAfter: nodeAfterMerge ? (nodeAfterMerge as { color?: string }).color : undefined }, timestamp: Date.now(), sessionId: \"debug-session\", hypothesisId: \"C\" }) }).catch(() =&gt; {});\n\t\t// #endregion\n\t}\n\t// Always persist so output node/edge mutations from ensureOutputNodeAndEdge are saved\n\tliveCanvas?.setData?.(data);\n\tif (liveCanvas?.requestSave) liveCanvas.requestSave(); // so Obsidian marks canvas dirty and won't overwrite on tab switch\n\tconst saved = await saveCanvasData(vault, canvasFilePath, data);\n\tif (!saved) new Notice(\"Failed to save canvas.\");\n}\n\n/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 267,
                "column": 1
              },
              "endPosition": {
                "line": 275,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "async function updateEdgeLabelsAndSave(",
            "lineNumber": 267,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 268,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 269,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 270,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 271,
            "isSignature": true
          },
          {
            "text": "\tedgeModes: Map&lt;string, EdgeInputMode&gt;,",
            "lineNumber": 272,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 273,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 274,
            "isSignature": true
          },
          {
            "lineNumber": 295
          },
          {
            "text": "\t// #endregion",
            "lineNumber": 296
          },
          {
            "text": "\tif (liveData?.nodes) {",
            "lineNumber": 297
          },
          {
            "text": "\t\tmergePreserveUserNodeProps(data, liveData);",
            "lineNumber": 298
          },
          {
            "text": "\t\t// #region agent log",
            "lineNumber": 299
          },
          {
            "text": "\t\tconst nodeAfterMerge = getNodeById(data, nodeId);",
            "lineNumber": 300
          },
          {
            "text": "\t\tfetch(\"http://127.0.0.1:7243/ingest/453147b6-6b57-40b4-a769-82c9dd3c5ee7\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ location: \"runner.ts:updateEdgeLabelsAndSave\", message: \"after merge\", data: { nodeId, nodeColorAfter: nodeAfterMerge ? (nodeAfterMerge as { color?: string }).color : undefined }, timestamp: Date.now(), sessionId: \"debug-session\", hypothesisId: \"C\" }) }).catch(() =&gt; {});",
            "lineNumber": 301
          },
          {
            "text": "\t\t// #endregion",
            "lineNumber": 302
          },
          {
            "text": "\t}",
            "lineNumber": 303
          },
          {
            "text": "\t// Always persist so output node/edge mutations from ensureOutputNodeAndEdge are saved",
            "lineNumber": 304
          },
          {
            "text": "\tliveCanvas?.setData?.(data);",
            "lineNumber": 305
          },
          {
            "text": "\tif (liveCanvas?.requestSave) liveCanvas.requestSave(); // so Obsidian marks canvas dirty and won't overwrite on tab switch",
            "lineNumber": 306
          },
          {
            "text": "\tconst saved = await saveCanvasData(vault, canvasFilePath, data);",
            "lineNumber": 307
          },
          {
            "text": "\tif (!saved) new Notice(\"Failed to save canvas.\");",
            "lineNumber": 308
          },
          {
            "text": "}",
            "lineNumber": 309,
            "isSignature": true
          },
          {
            "lineNumber": 310
          },
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 311
          }
        ]
      },
      "score": 0.2897849977016449
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 133,
            "column": 50
          },
          "endPosition": {
            "line": 168,
            "column": 125
          }
        },
        "contents": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */\nexport function findOutputNodeForSource(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\tsettings: ZettelPluginSettings\n): string | null {\n\tconst outputEdge = data.edges.find(\n\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t);\n\tif (outputEdge) return outputEdge.toNode;\n\tconst source = getNodeById(data, sourceNodeId);\n\tif (!source) return null;\n\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);\n\tif (!greenColor) return null;\n\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;\n\tconst toleranceAbove = 30; // allow small layout drift above default\n\tconst candidates: { id: string; centerY: number }[] = [];\n\tfor (const node of data.nodes) {\n\t\tif (node.id === sourceNodeId) continue;\n\t\tif (normalizeColor(node.color) !== greenColor) continue;\n\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;\n\t\tif (node.y &lt; expectedY - toleranceAbove || node.y &gt; expectedY + OUTPUT_POSITION_FALLBACK_MAX_Y) continue;\n\t\tconst centerY = node.y + (node.height ?? 0) / 2;\n\t\tcandidates.push({ id: node.id, centerY });\n\t}\n\tif (candidates.length === 0) return null;\n\t// Prefer the green whose center is closest to expectedY (avoids wrong match when sources are stacked)\n\tconst best = candidates.reduce((a, b) =&gt;\n\t\tMath.abs(a.centerY - expectedY) &lt;= Math.abs(b.centerY - expectedY) ? a : b\n\t);\n\treturn best.id;\n}\n\n/** Find the node id for an auxiliary edge from source with the given label (e.g. EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
            "lineNumber": 136
          },
          {
            "text": "export function findOutputNodeForSource(",
            "lineNumber": 137,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 138,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 139,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 140,
            "isSignature": true
          },
          {
            "text": "): string | null {",
            "lineNumber": 141,
            "isSignature": true
          },
          {
            "text": "\tconst outputEdge = data.edges.find(",
            "lineNumber": 142
          },
          {
            "text": "\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 143
          },
          {
            "text": "\t);",
            "lineNumber": 144
          },
          {
            "text": "\tif (outputEdge) return outputEdge.toNode;",
            "lineNumber": 145
          },
          {
            "text": "\tconst source = getNodeById(data, sourceNodeId);",
            "lineNumber": 146
          },
          {
            "text": "\tif (!source) return null;",
            "lineNumber": 147
          },
          {
            "text": "\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);",
            "lineNumber": 148
          },
          {
            "text": "\tif (!greenColor) return null;",
            "lineNumber": 149
          },
          {
            "text": "\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;",
            "lineNumber": 150
          },
          {
            "text": "\tconst toleranceAbove = 30; // allow small layout drift above default",
            "lineNumber": 151
          },
          {
            "text": "\tconst candidates: { id: string; centerY: number }[] = [];",
            "lineNumber": 152
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 153
          },
          {
            "text": "\t\tif (node.id === sourceNodeId) continue;",
            "lineNumber": 154
          },
          {
            "text": "\t\tif (normalizeColor(node.color) !== greenColor) continue;",
            "lineNumber": 155
          },
          {
            "text": "\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;",
            "lineNumber": 156
          },
          {
            "text": "\t\tif (node.y &lt; expectedY - toleranceAbove || node.y &gt; expectedY + OUTPUT_POSITION_FALLBACK_MAX_Y) continue;",
            "lineNumber": 157
          },
          {
            "text": "\t\tconst centerY = node.y + (node.height ?? 0) / 2;",
            "lineNumber": 158
          },
          {
            "text": "\t\tcandidates.push({ id: node.id, centerY });",
            "lineNumber": 159
          },
          {
            "text": "\t}",
            "lineNumber": 160
          },
          {
            "text": "\tif (candidates.length === 0) return null;",
            "lineNumber": 161
          },
          {
            "text": "\t// Prefer the green whose center is closest to expectedY (avoids wrong match when sources are stacked)",
            "lineNumber": 162
          },
          {
            "text": "\tconst best = candidates.reduce((a, b) =&gt;",
            "lineNumber": 163
          },
          {
            "text": "\t\tMath.abs(a.centerY - expectedY) &lt;= Math.abs(b.centerY - expectedY) ? a : b",
            "lineNumber": 164
          },
          {
            "text": "\t);",
            "lineNumber": 165
          },
          {
            "text": "\treturn best.id;",
            "lineNumber": 166
          },
          {
            "text": "}",
            "lineNumber": 167,
            "isSignature": true
          },
          {
            "lineNumber": 168
          },
          {
            "text": "/** Find the node id for an auxiliary edge from source with the given label (e.g. EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING). */",
            "lineNumber": 169
          }
        ]
      },
      "score": 0.2859841585159302
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 97
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\n\n\tconst nodes: CanvasData[\"nodes\"] = [\n\t\t// Groups first (render behind)\n\t\tgroupWelcome,\n\t\tgroupCol1,\n\t\tgroupCol2,\n\t\tgroupCol3,\n\t\tgroupCol4,\n\t\tgroupCol5,\n\t\tgroupCol6,\n\t\t// Welcome: plain text (no color = no role; not connected, does not add to prompt)\n\t\tn(welcome, \"Welcome to Zettel Thinking Board. Each column is a separate showcase. Nodes run top to bottom. Right-click a card → Run node or Run chain. Uncolored or unused-color cards are not connected to any node and do not add to the prompt.\", TUT_LEFT, welcomeY, \"\", TUT_WELCOME_W, 132),\n\n\t\t// Column 1: label = plain text; nodes in lane have roles\n\t\tn(lab1, \"Primary model: sends prompt to Ollama. Set the model in Zettel Controls.\", commentLeftX(col1), orangeY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(orangeNode, \"What is 2+2? Reply in one sentence.\", laneNodeX(col1, 0), orangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(orangeOut, \"\", laneNodeX(col1, LANE_OFFSET), orangeOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 2\n\t\tn(lab2a, \"Secondary model (same idea, different model).\", commentLeftX(col2), purpleY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(purpleNode, \"Summarize in 5 words: The quick brown fox jumps.\", laneNodeX(col2, 0), purpleY, cPurple, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(purpleOut, \"\", laneNodeX(col2, LANE_OFFSET), purpleOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(lab2b, \"Text: input text; passed to next node as-is (pass-through).\", commentRightX(col2), yellowY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(yellowNode, \"I'm input text. My text is passed to the next node (concatenated).\", laneNodeX(col2, 0), yellowY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(lab2c, \"Python: runs code. Use variable input for parent text.\", commentLeftX(col2), blueY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(blueNode, \"print('Python says:', (input or '')[:80] or '(no input)')\\n# input = text from parent\", laneNodeX(col2, LANE_OFFSET), blueY, cBlue, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 3\n\t\tn\n,\n\t];\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 98,
                "column": 1
              },
              "endPosition": {
                "line": 99,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "lineNumber": 257
          },
          {
            "lineNumber": 258
          },
          {
            "text": "\tconst nodes: CanvasData[\"nodes\"] = [",
            "lineNumber": 259
          },
          {
            "text": "\t\t// Groups first (render behind)",
            "lineNumber": 260
          },
          {
            "text": "\t\tgroupWelcome,",
            "lineNumber": 261
          },
          {
            "text": "\t\tgroupCol1,",
            "lineNumber": 262
          },
          {
            "text": "\t\tgroupCol2,",
            "lineNumber": 263
          },
          {
            "text": "\t\tgroupCol3,",
            "lineNumber": 264
          },
          {
            "text": "\t\tgroupCol4,",
            "lineNumber": 265
          },
          {
            "text": "\t\tgroupCol5,",
            "lineNumber": 266
          },
          {
            "text": "\t\tgroupCol6,",
            "lineNumber": 267
          },
          {
            "text": "\t\t// Welcome: plain text (no color = no role; not connected, does not add to prompt)",
            "lineNumber": 268
          },
          {
            "text": "\t\tn(welcome, \"Welcome to Zettel Thinking Board. Each column is a separate showcase. Nodes run top to bottom. Right-click a card → Run node or Run chain. Uncolored or unused-color cards are not connected to any node and do not add to the prompt.\", TUT_LEFT, welcomeY, \"\", TUT_WELCOME_W, 132),",
            "lineNumber": 269
          },
          {
            "lineNumber": 270
          },
          {
            "text": "\t\t// Column 1: label = plain text; nodes in lane have roles",
            "lineNumber": 271
          },
          {
            "text": "\t\tn(lab1, \"Primary model: sends prompt to Ollama. Set the model in Zettel Controls.\", commentLeftX(col1), orangeY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 272
          },
          {
            "text": "\t\tn(orangeNode, \"What is 2+2? Reply in one sentence.\", laneNodeX(col1, 0), orangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 273
          },
          {
            "text": "\t\tn(orangeOut, \"\", laneNodeX(col1, LANE_OFFSET), orangeOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 274
          },
          {
            "lineNumber": 275
          },
          {
            "text": "\t\t// Column 2",
            "lineNumber": 276
          },
          {
            "text": "\t\tn(lab2a, \"Secondary model (same idea, different model).\", commentLeftX(col2), purpleY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 277
          },
          {
            "text": "\t\tn(purpleNode, \"Summarize in 5 words: The quick brown fox jumps.\", laneNodeX(col2, 0), purpleY, cPurple, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 278
          },
          {
            "text": "\t\tn(purpleOut, \"\", laneNodeX(col2, LANE_OFFSET), purpleOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 279
          },
          {
            "text": "\t\tn(lab2b, \"Text: input text; passed to next node as-is (pass-through).\", commentRightX(col2), yellowY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 280
          },
          {
            "text": "\t\tn(yellowNode, \"I'm input text. My text is passed to the next node (concatenated).\", laneNodeX(col2, 0), yellowY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 281
          },
          {
            "text": "\t\tn(lab2c, \"Python: runs code. Use variable input for parent text.\", commentLeftX(col2), blueY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 282
          },
          {
            "text": "\t\tn(blueNode, \"print('Python says:', (input or '')[:80] or '(no input)')\\n# input = text from parent\", laneNodeX(col2, LANE_OFFSET), blueY, cBlue, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 283
          },
          {
            "text": "\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 284
          },
          {
            "lineNumber": 285
          },
          {
            "text": "\t\t// Column 3",
            "lineNumber": 286
          },
          {
            "text": "\t\tn",
            "lineNumber": 287
          },
          {
            "text": ",",
            "lineNumber": 300
          },
          {
            "text": "\t];",
            "lineNumber": 301
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.2670859098434448
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 150,
            "column": 1
          },
          "endPosition": {
            "line": 230,
            "column": 1
          }
        },
        "contents": "/**\n * Sync floating role labels for the active canvas: for each node whose color maps to a role,\n * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first.\n * Uses the live canvas node map to find each node's DOM element (.canvas-node).\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasRoleLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tsettings: ZettelPluginSettings,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tif (!settings.showNodeRoleLabels) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.nodes) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).\n\tclearCanvasRoleLabels(containerEl);\n\tsyncCanvasLegend(containerEl, settings);\n\n\tconst order = getTopologicalOrder(data, settings);\n\tconst orderByNodeId = new Map&lt;string, number&gt;();\n\tif (order) {\n\t\torder.forEach((nodeId, index) =&gt; orderByNodeId.set(nodeId, index + 1));\n\t}\n\n\tconst promptNodeIds = new Set(\n\t\tdata.edges\n\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT)\n\t\t\t.map((e) =&gt; e.toNode)\n\t);\n\tconst thinkingNodeIds = new Set(\n\t\tdata.edges\n\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING)\n\t\t\t.map((e) =&gt; e.toNode)\n\t);\n\n\tfor (const node of data.nodes)\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/**",
            "lineNumber": 153
          },
          {
            "text": " * Sync floating role labels for the active canvas: for each node whose color maps to a role,",
            "lineNumber": 154
          },
          {
            "text": " * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first.",
            "lineNumber": 155
          },
          {
            "text": " * Uses the live canvas node map to find each node's DOM element (.canvas-node).",
            "lineNumber": 156
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 157
          },
          {
            "text": " */",
            "lineNumber": 158
          },
          {
            "text": "export async function syncCanvasRoleLabels(",
            "lineNumber": 159,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 160,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 161,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 162,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 163,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 164,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 165,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 166,
            "isSignature": true
          },
          {
            "text": "\tif (!settings.showNodeRoleLabels) {",
            "lineNumber": 167
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 168
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 169
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 170
          },
          {
            "text": "\t}",
            "lineNumber": 171
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 172
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 173
          },
          {
            "text": "\tif (!data?.nodes) {",
            "lineNumber": 174
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 175
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 176
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 177
          },
          {
            "text": "\t}",
            "lineNumber": 178
          },
          {
            "text": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).",
            "lineNumber": 179
          },
          {
            "text": "\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 180
          },
          {
            "text": "\tsyncCanvasLegend(containerEl, settings);",
            "lineNumber": 181
          },
          {
            "lineNumber": 182
          },
          {
            "text": "\tconst order = getTopologicalOrder(data, settings);",
            "lineNumber": 183
          },
          {
            "text": "\tconst orderByNodeId = new Map&lt;string, number&gt;();",
            "lineNumber": 184
          },
          {
            "text": "\tif (order) {",
            "lineNumber": 185
          },
          {
            "text": "\t\torder.forEach((nodeId, index) =&gt; orderByNodeId.set(nodeId, index + 1));",
            "lineNumber": 186
          },
          {
            "text": "\t}",
            "lineNumber": 187
          },
          {
            "lineNumber": 188
          },
          {
            "text": "\tconst promptNodeIds = new Set(",
            "lineNumber": 189
          },
          {
            "text": "\t\tdata.edges",
            "lineNumber": 190
          },
          {
            "text": "\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT)",
            "lineNumber": 191
          },
          {
            "text": "\t\t\t.map((e) =&gt; e.toNode)",
            "lineNumber": 192
          },
          {
            "text": "\t);",
            "lineNumber": 193
          },
          {
            "text": "\tconst thinkingNodeIds = new Set(",
            "lineNumber": 194
          },
          {
            "text": "\t\tdata.edges",
            "lineNumber": 195
          },
          {
            "text": "\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING)",
            "lineNumber": 196
          },
          {
            "text": "\t\t\t.map((e) =&gt; e.toNode)",
            "lineNumber": 197
          },
          {
            "text": "\t);",
            "lineNumber": 198
          },
          {
            "lineNumber": 199
          },
          {
            "text": "\tfor (const node of data.nodes)",
            "lineNumber": 200
          },
          {
            "text": "}",
            "lineNumber": 231,
            "isSignature": true
          }
        ]
      },
      "score": 0.2657760977745056
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 533
          },
          "endPosition": {
            "line": 755,
            "column": 107
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\nconst promptToSide =  promptSide === \"top\" ? \"bottom\" : \"top\";\n\n\t\tif (promptId) {\n\t\t\tconst pn = getNodeById(data, promptId);\n\t\t\tif (pn &amp;&amp; isTextNode(pn)) {\n\t\t\t\tconst updated = {\n\t\t\t\t\t...(pn as CanvasTextData),\n\t\t\t\t\ttext: fullPrompt,\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\tcolor: promptColor,\n\t\t\t\t};\n\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === promptId);\n\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t\t}\n\t\t\tconst hasEdge = data.edges.some(\n\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === promptId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT\n\t\t\t);\n\t\t\tif (!hasEdge) {\n\t\t\t\tdata.edges.push({\n\t\t\t\t\tid: randomId(),\n\t\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\t\tfromSide: promptSide,\n\t\t\t\t\ttoNode: promptId,\n\t\t\t\t\ttoSide: promptToSide,\n\t\t\t\t\tlabel: EDGE_LABEL_PROMPT,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst newId = randomId();\n\t\t\tdata.nodes.push({\n\t\t\t\tid: newId,\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: fullPrompt,\n\t\t\t\tx: px,\n\t\t\t\ty: py,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tcolor: promptColor,\n\t\t\t} as CanvasTextData);\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\tfromSide: promptSide,\n\t\t\t\ttoNode: newId,\n\t\t\t\ttoSide: promptToSide,\n\t\t\t\tlabel: EDGE_LABEL_PROMPT,\n\t\t\t});\n\t\t}\n\t}\n}\n\n/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 534,
                "column": 1
              },
              "endPosition": {
                "line": 541,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 536,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 538,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 539,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 540,
            "isSignature": true
          },
          {
            "text": "const promptToSide =  promptSide === \"top\" ? \"bottom\" : \"top\";",
            "lineNumber": 704
          },
          {
            "lineNumber": 705
          },
          {
            "text": "\t\tif (promptId) {",
            "lineNumber": 706
          },
          {
            "text": "\t\t\tconst pn = getNodeById(data, promptId);",
            "lineNumber": 707
          },
          {
            "text": "\t\t\tif (pn &amp;&amp; isTextNode(pn)) {",
            "lineNumber": 708
          },
          {
            "text": "\t\t\t\tconst updated = {",
            "lineNumber": 709
          },
          {
            "text": "\t\t\t\t\t...(pn as CanvasTextData),",
            "lineNumber": 710
          },
          {
            "text": "\t\t\t\t\ttext: fullPrompt,",
            "lineNumber": 711
          },
          {
            "text": "\t\t\t\t\twidth,",
            "lineNumber": 712
          },
          {
            "text": "\t\t\t\t\theight,",
            "lineNumber": 713
          },
          {
            "text": "\t\t\t\t\tcolor: promptColor,",
            "lineNumber": 714
          },
          {
            "text": "\t\t\t\t};",
            "lineNumber": 715
          },
          {
            "text": "\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === promptId);",
            "lineNumber": 716
          },
          {
            "text": "\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 717
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 718
          },
          {
            "text": "\t\t\tconst hasEdge = data.edges.some(",
            "lineNumber": 719
          },
          {
            "text": "\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === promptId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT",
            "lineNumber": 720
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 721
          },
          {
            "text": "\t\t\tif (!hasEdge) {",
            "lineNumber": 722
          },
          {
            "text": "\t\t\t\tdata.edges.push({",
            "lineNumber": 723
          },
          {
            "text": "\t\t\t\t\tid: randomId(),",
            "lineNumber": 724
          },
          {
            "text": "\t\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 725
          },
          {
            "text": "\t\t\t\t\tfromSide: promptSide,",
            "lineNumber": 726
          },
          {
            "text": "\t\t\t\t\ttoNode: promptId,",
            "lineNumber": 727
          },
          {
            "text": "\t\t\t\t\ttoSide: promptToSide,",
            "lineNumber": 728
          },
          {
            "text": "\t\t\t\t\tlabel: EDGE_LABEL_PROMPT,",
            "lineNumber": 729
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 730
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 731
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 732
          },
          {
            "text": "\t\t\tconst newId = randomId();",
            "lineNumber": 733
          },
          {
            "text": "\t\t\tdata.nodes.push({",
            "lineNumber": 734
          },
          {
            "text": "\t\t\t\tid: newId,",
            "lineNumber": 735
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 736
          },
          {
            "text": "\t\t\t\ttext: fullPrompt,",
            "lineNumber": 737
          },
          {
            "text": "\t\t\t\tx: px,",
            "lineNumber": 738
          },
          {
            "text": "\t\t\t\ty: py,",
            "lineNumber": 739
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 740
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 741
          },
          {
            "text": "\t\t\t\tcolor: promptColor,",
            "lineNumber": 742
          },
          {
            "text": "\t\t\t} as CanvasTextData);",
            "lineNumber": 743
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 744
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 745
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 746
          },
          {
            "text": "\t\t\t\tfromSide: promptSide,",
            "lineNumber": 747
          },
          {
            "text": "\t\t\t\ttoNode: newId,",
            "lineNumber": 748
          },
          {
            "text": "\t\t\t\ttoSide: promptToSide,",
            "lineNumber": 749
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_PROMPT,",
            "lineNumber": 750
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 751
          },
          {
            "text": "\t\t}",
            "lineNumber": 752
          },
          {
            "text": "\t}",
            "lineNumber": 753
          },
          {
            "text": "}",
            "lineNumber": 754,
            "isSignature": true
          },
          {
            "lineNumber": 755
          },
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 756
          }
        ]
      },
      "score": 0.2638092041015625
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "column": 76
          },
          "endPosition": {
            "line": 43,
            "column": 99
          }
        },
        "contents": " from \"obsidian\";\nimport {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";\nimport {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";\nimport {CanvasTemplateModal} from \"./views/CanvasTemplateModal\";\nimport {duplicateCanvasTemplate, saveCanvasAsTemplate, isCanvasInTemplateFolder} from \"./canvas/canvasTemplates\";\nimport {\n\tdismissAllOutput as runnerDismissAllOutput,\n\tdismissOutput as runnerDismissOutput,\n\trunChain as runnerRunChain,\n\trunEntireCanvas as runnerRunEntireCanvas,\n\trunNode as runnerRunNode,\n} from \"./engine/runner\";\nimport {\n\tclearCanvasEdgeModeLabels,\n\tclearCanvasLegend,\n\tclearCanvasRoleLabels,\n\tsyncCanvasEdgeModeLabels,\n\tsyncCanvasRoleLabels,\n} from \"./canvas/canvasNodeLabels\";\nimport {hasOutputNodes, loadCanvasData, saveCanvasData} from \"./canvas/nodes\";\nimport type {CanvasData} from \"./canvas/types\";\nimport {EDGE_LABEL_OUTPUT} from \"./canvas/types\";\nimport {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";\nimport {getExample1CanvasData} from \"./tutorials/example1Data\";\nimport {getExample4CanvasData} from \"./tutorials/example4Data\";\n\n/** Layout constants: comment margins left/right, central lane for nodes, no overlap. */\nconst TUT_LEFT = 80;\nconst TUT_TOP = 50;\nconst TUT_WELCOME_W = 420;\nconst TUT_WELCOME_H = 118;\nconst TUT_WELCOME_BOTTOM_GAP = 70;\n/** Per-column: left comment margin | node lane | right comment margin. */\nconst TUT_COMMENT_W = 185;\nconst TUT_LANE_GAP = 22;\nconst TUT_NODE_LANE_W = 260;\nconst TUT_COL_TOTAL_W = TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP + TUT_COMMENT_W;\nconst TUT_COL_GAP = 85;\nconst TUT_NODE_H = 115;\nconst TUT_NODE_GAP = 58;\nconst TUT_LABEL_H = 88;\nconst TUT_GROUP_PAD = 18;\n\n/** Resolve role color from settings (fallback to default so tutorial always has a valid color). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": " from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";",
            "lineNumber": 2
          },
          {
            "text": "import {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";",
            "lineNumber": 3
          },
          {
            "text": "import {CanvasTemplateModal} from \"./views/CanvasTemplateModal\";",
            "lineNumber": 4
          },
          {
            "text": "import {duplicateCanvasTemplate, saveCanvasAsTemplate, isCanvasInTemplateFolder} from \"./canvas/canvasTemplates\";",
            "lineNumber": 5
          },
          {
            "text": "import {",
            "lineNumber": 6
          },
          {
            "text": "\tdismissAllOutput as runnerDismissAllOutput,",
            "lineNumber": 7
          },
          {
            "text": "\tdismissOutput as runnerDismissOutput,",
            "lineNumber": 8
          },
          {
            "text": "\trunChain as runnerRunChain,",
            "lineNumber": 9
          },
          {
            "text": "\trunEntireCanvas as runnerRunEntireCanvas,",
            "lineNumber": 10
          },
          {
            "text": "\trunNode as runnerRunNode,",
            "lineNumber": 11
          },
          {
            "text": "} from \"./engine/runner\";",
            "lineNumber": 12
          },
          {
            "text": "import {",
            "lineNumber": 13
          },
          {
            "text": "\tclearCanvasEdgeModeLabels,",
            "lineNumber": 14
          },
          {
            "text": "\tclearCanvasLegend,",
            "lineNumber": 15
          },
          {
            "text": "\tclearCanvasRoleLabels,",
            "lineNumber": 16
          },
          {
            "text": "\tsyncCanvasEdgeModeLabels,",
            "lineNumber": 17
          },
          {
            "text": "\tsyncCanvasRoleLabels,",
            "lineNumber": 18
          },
          {
            "text": "} from \"./canvas/canvasNodeLabels\";",
            "lineNumber": 19
          },
          {
            "text": "import {hasOutputNodes, loadCanvasData, saveCanvasData} from \"./canvas/nodes\";",
            "lineNumber": 20
          },
          {
            "text": "import type {CanvasData} from \"./canvas/types\";",
            "lineNumber": 21
          },
          {
            "text": "import {EDGE_LABEL_OUTPUT} from \"./canvas/types\";",
            "lineNumber": 22
          },
          {
            "text": "import {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";",
            "lineNumber": 23
          },
          {
            "text": "import {getExample1CanvasData} from \"./tutorials/example1Data\";",
            "lineNumber": 24
          },
          {
            "text": "import {getExample4CanvasData} from \"./tutorials/example4Data\";",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "/** Layout constants: comment margins left/right, central lane for nodes, no overlap. */",
            "lineNumber": 27
          },
          {
            "text": "const TUT_LEFT = 80;",
            "lineNumber": 28
          },
          {
            "text": "const TUT_TOP = 50;",
            "lineNumber": 29
          },
          {
            "text": "const TUT_WELCOME_W = 420;",
            "lineNumber": 30
          },
          {
            "text": "const TUT_WELCOME_H = 118;",
            "lineNumber": 31
          },
          {
            "text": "const TUT_WELCOME_BOTTOM_GAP = 70;",
            "lineNumber": 32
          },
          {
            "text": "/** Per-column: left comment margin | node lane | right comment margin. */",
            "lineNumber": 33
          },
          {
            "text": "const TUT_COMMENT_W = 185;",
            "lineNumber": 34
          },
          {
            "text": "const TUT_LANE_GAP = 22;",
            "lineNumber": 35
          },
          {
            "text": "const TUT_NODE_LANE_W = 260;",
            "lineNumber": 36
          },
          {
            "text": "const TUT_COL_TOTAL_W = TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP + TUT_COMMENT_W;",
            "lineNumber": 37
          },
          {
            "text": "const TUT_COL_GAP = 85;",
            "lineNumber": 38
          },
          {
            "text": "const TUT_NODE_H = 115;",
            "lineNumber": 39
          },
          {
            "text": "const TUT_NODE_GAP = 58;",
            "lineNumber": 40
          },
          {
            "text": "const TUT_LABEL_H = 88;",
            "lineNumber": 41
          },
          {
            "text": "const TUT_GROUP_PAD = 18;",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "/** Resolve role color from settings (fallback to default so tutorial always has a valid color). */",
            "lineNumber": 44
          }
        ]
      },
      "score": 0.26360180974006653
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 533
          },
          "endPosition": {
            "line": 753,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\n\n\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present\n\tif (settings.showPromptInOutput &amp;&amp; fullPrompt != null &amp;&amp; fullPrompt.length &gt; 0) {\n\t\tconst promptSide = chooseFreeSideForAuxiliaryEdge(data, sourceNode.id);\n\t\tconst thinkingNodeId = settings.showThinkingNode &amp;&amp; thinking ? findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING) : null;\n\t\tconst anchorNode = thinkingNodeId ? getNodeById(data, thinkingNodeId) : outputNode;\n\t\tconst anchorY = anchorNode &amp;&amp; \"y\" in anchorNode ? (anchorNode as { y: number }).y : outputY;\n\t\tconst promptDefaultY = anchorY - height - GREEN_NODE_PADDING;\n\t\tconst promptExclude = [sourceNode.id, resolvedOutputId, thinkingId, promptId].filter((id): id is string =&gt; id != null);\n\t\tconst { x: px, y: py } = chooseOutputPositionXY(\n\t\t\tdata,\n\t\t\tsourceNode.id,\n\t\t\tpromptId,\n\t\t\tdefaultX,\n\t\t\tpromptDefaultY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tpromptExclude\n\t\t);\n\t\tconst promptColor = shadeColor(settings.colorGreen, 0.25);\n\t\tconst promptToSide = promptSide === \"left\" ? \"right\" : promptSide === \"right\" ? \"left\" : promptSide === \"top\" ? \"bottom\" : \"top\";\n\n\t\tif (promptId)\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 534,
                "column": 1
              },
              "endPosition": {
                "line": 541,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 534,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 535,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 536,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 537,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 538,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 539,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 540,
            "isSignature": true
          },
          {
            "lineNumber": 683
          },
          {
            "lineNumber": 684
          },
          {
            "text": "\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present",
            "lineNumber": 685
          },
          {
            "text": "\tif (settings.showPromptInOutput &amp;&amp; fullPrompt != null &amp;&amp; fullPrompt.length &gt; 0) {",
            "lineNumber": 686
          },
          {
            "text": "\t\tconst promptSide = chooseFreeSideForAuxiliaryEdge(data, sourceNode.id);",
            "lineNumber": 687
          },
          {
            "text": "\t\tconst thinkingNodeId = settings.showThinkingNode &amp;&amp; thinking ? findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING) : null;",
            "lineNumber": 688
          },
          {
            "text": "\t\tconst anchorNode = thinkingNodeId ? getNodeById(data, thinkingNodeId) : outputNode;",
            "lineNumber": 689
          },
          {
            "text": "\t\tconst anchorY = anchorNode &amp;&amp; \"y\" in anchorNode ? (anchorNode as { y: number }).y : outputY;",
            "lineNumber": 690
          },
          {
            "text": "\t\tconst promptDefaultY = anchorY - height - GREEN_NODE_PADDING;",
            "lineNumber": 691
          },
          {
            "text": "\t\tconst promptExclude = [sourceNode.id, resolvedOutputId, thinkingId, promptId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 692
          },
          {
            "text": "\t\tconst { x: px, y: py } = chooseOutputPositionXY(",
            "lineNumber": 693
          },
          {
            "text": "\t\t\tdata,",
            "lineNumber": 694
          },
          {
            "text": "\t\t\tsourceNode.id,",
            "lineNumber": 695
          },
          {
            "text": "\t\t\tpromptId,",
            "lineNumber": 696
          },
          {
            "text": "\t\t\tdefaultX,",
            "lineNumber": 697
          },
          {
            "text": "\t\t\tpromptDefaultY,",
            "lineNumber": 698
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 699
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 700
          },
          {
            "text": "\t\t\tpromptExclude",
            "lineNumber": 701
          },
          {
            "text": "\t\t);",
            "lineNumber": 702
          },
          {
            "text": "\t\tconst promptColor = shadeColor(settings.colorGreen, 0.25);",
            "lineNumber": 703
          },
          {
            "text": "\t\tconst promptToSide = promptSide === \"left\" ? \"right\" : promptSide === \"right\" ? \"left\" : promptSide === \"top\" ? \"bottom\" : \"top\";",
            "lineNumber": 704
          },
          {
            "lineNumber": 705
          },
          {
            "text": "\t\tif (promptId)",
            "lineNumber": 706
          },
          {
            "text": "}",
            "lineNumber": 754,
            "isSignature": true
          }
        ]
      },
      "score": 0.2610805630683899
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 87,
            "column": 1
          },
          "endPosition": {
            "line": 107,
            "column": 1
          }
        },
        "contents": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */\nexport function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));\n\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withY = fromIds\n\t\t.map((id) =&gt; {\n\t\t\tconst node = nodeMap.get(id);\n\t\t\treturn node ? { id, y: node.y } : null;\n\t\t})\n\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);\n\twithY.sort((a, b) =&gt; a.y - b.y);\n\treturn withY.map((x) =&gt; x.id);\n}\n\n/** Get node by id from canvas data. */\nexport function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */",
            "lineNumber": 90
          },
          {
            "text": "export function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));",
            "lineNumber": 92
          },
          {
            "text": "\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];",
            "lineNumber": 93
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 94
          },
          {
            "text": "\tconst withY = fromIds",
            "lineNumber": 95
          },
          {
            "text": "\t\t.map((id) =&gt; {",
            "lineNumber": 96
          },
          {
            "text": "\t\t\tconst node = nodeMap.get(id);",
            "lineNumber": 97
          },
          {
            "text": "\t\t\treturn node ? { id, y: node.y } : null;",
            "lineNumber": 98
          },
          {
            "text": "\t\t})",
            "lineNumber": 99
          },
          {
            "text": "\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);",
            "lineNumber": 100
          },
          {
            "text": "\twithY.sort((a, b) =&gt; a.y - b.y);",
            "lineNumber": 101
          },
          {
            "text": "\treturn withY.map((x) =&gt; x.id);",
            "lineNumber": 102
          },
          {
            "text": "}",
            "lineNumber": 103,
            "isSignature": true
          },
          {
            "lineNumber": 104
          },
          {
            "text": "/** Get node by id from canvas data. */",
            "lineNumber": 105
          },
          {
            "text": "export function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {",
            "lineNumber": 106,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 107
          },
          {
            "text": "}",
            "lineNumber": 108,
            "isSignature": true
          }
        ]
      },
      "score": 0.2585274577140808
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 94,
            "column": 1
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "/** Build tutorial canvas: columns with comment margins, node lane center, edges, groups. */\nfunction getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\tconst cOrange = tutorialColor(settings, \"colorOrange\");\n\tconst cPurple = tutorialColor(settings, \"colorPurple\");\n\tconst cBlue = tutorialColor(settings, \"colorBlue\");\n\tconst cYellow = tutorialColor(settings, \"colorYellow\");\n\tconst cGreen = tutorialColor(settings, \"colorGreen\");\n\n\t/** Plain text node (no role): use for labels/instructions so they are not treated as comment nodes. */\n\tconst n = (id: string, text: string, x: number, y: number, color: string, w: number, h: number) =&gt;\n\t\t({ id, type: \"text\" as const, text, x, y, width: w, height: h, color });\n\tconst e = (id: string, from: string, to: string, label?: string) =&gt; ({\n\t\tid,\n\t\tfromNode: from,\n\t\ttoNode: to,\n\t\tfromSide: \"bottom\" as const,\n\t\ttoSide: \"top\" as const,\n\t\tlabel: label ?? \"\",\n\t});\n\t/** Group node to visually separate a workflow block. */\n\tconst g = (id: string, x: number, y: number, w: number, h: number, label: string) =&gt;\n\t\t({ id, type: \"group\" as const, x, y, width: w, height: h, label });\n\n\t/** Column 1..6: x of left comment margin (column 1 starts right after welcome). */\n\tconst colLeft = (index: number) =&gt;\n\t\tTUT_LEFT + TUT_WELCOME_W + TUT_COL_GAP + (index - 1) * (TUT_COL_TOTAL_W + TUT_COL_GAP);\n\tconst commentLeftX = (colIndex: number) =&gt; colLeft(colIndex);\n\t/** Node lane: center x; offsetPx shifts right so alternating nodes make arrows more visible. */\n\tconst laneNodeX = (colIndex: number, offsetPx: number = 0) =&gt;\n\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + offsetPx;\n\tconst commentRightX = (colIndex: number) =&gt;\n\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP;\n\tconst LANE_OFFSET = 36;\n\n\t// —— Welcome: alone in first block, no overlap with column 1 ——\n\tconst welcome = \"welcome\";\n\tconst welcomeY = TUT_TOP;\n\n\t// —— Column 1: Primary (comment left, node → output in lane) ——\n\tconst col1 = 1;\n\tconst lab1 = \"lab-primary\";\n\tconst orangeNode = \"orange-example\";\n\tconst orangeOut = \"orange-out\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build tutorial canvas: columns with comment margins, node lane center, edges, groups. */",
            "lineNumber": 97
          },
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "text": "\tconst cOrange = tutorialColor(settings, \"colorOrange\");",
            "lineNumber": 99
          },
          {
            "text": "\tconst cPurple = tutorialColor(settings, \"colorPurple\");",
            "lineNumber": 100
          },
          {
            "text": "\tconst cBlue = tutorialColor(settings, \"colorBlue\");",
            "lineNumber": 101
          },
          {
            "text": "\tconst cYellow = tutorialColor(settings, \"colorYellow\");",
            "lineNumber": 102
          },
          {
            "text": "\tconst cGreen = tutorialColor(settings, \"colorGreen\");",
            "lineNumber": 103
          },
          {
            "lineNumber": 104
          },
          {
            "text": "\t/** Plain text node (no role): use for labels/instructions so they are not treated as comment nodes. */",
            "lineNumber": 105
          },
          {
            "text": "\tconst n = (id: string, text: string, x: number, y: number, color: string, w: number, h: number) =&gt;",
            "lineNumber": 106
          },
          {
            "text": "\t\t({ id, type: \"text\" as const, text, x, y, width: w, height: h, color });",
            "lineNumber": 107
          },
          {
            "text": "\tconst e = (id: string, from: string, to: string, label?: string) =&gt; ({",
            "lineNumber": 108
          },
          {
            "text": "\t\tid,",
            "lineNumber": 109
          },
          {
            "text": "\t\tfromNode: from,",
            "lineNumber": 110
          },
          {
            "text": "\t\ttoNode: to,",
            "lineNumber": 111
          },
          {
            "text": "\t\tfromSide: \"bottom\" as const,",
            "lineNumber": 112
          },
          {
            "text": "\t\ttoSide: \"top\" as const,",
            "lineNumber": 113
          },
          {
            "text": "\t\tlabel: label ?? \"\",",
            "lineNumber": 114
          },
          {
            "text": "\t});",
            "lineNumber": 115
          },
          {
            "text": "\t/** Group node to visually separate a workflow block. */",
            "lineNumber": 116
          },
          {
            "text": "\tconst g = (id: string, x: number, y: number, w: number, h: number, label: string) =&gt;",
            "lineNumber": 117
          },
          {
            "text": "\t\t({ id, type: \"group\" as const, x, y, width: w, height: h, label });",
            "lineNumber": 118
          },
          {
            "lineNumber": 119
          },
          {
            "text": "\t/** Column 1..6: x of left comment margin (column 1 starts right after welcome). */",
            "lineNumber": 120
          },
          {
            "text": "\tconst colLeft = (index: number) =&gt;",
            "lineNumber": 121
          },
          {
            "text": "\t\tTUT_LEFT + TUT_WELCOME_W + TUT_COL_GAP + (index - 1) * (TUT_COL_TOTAL_W + TUT_COL_GAP);",
            "lineNumber": 122
          },
          {
            "text": "\tconst commentLeftX = (colIndex: number) =&gt; colLeft(colIndex);",
            "lineNumber": 123
          },
          {
            "text": "\t/** Node lane: center x; offsetPx shifts right so alternating nodes make arrows more visible. */",
            "lineNumber": 124
          },
          {
            "text": "\tconst laneNodeX = (colIndex: number, offsetPx: number = 0) =&gt;",
            "lineNumber": 125
          },
          {
            "text": "\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + offsetPx;",
            "lineNumber": 126
          },
          {
            "text": "\tconst commentRightX = (colIndex: number) =&gt;",
            "lineNumber": 127
          },
          {
            "text": "\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP;",
            "lineNumber": 128
          },
          {
            "text": "\tconst LANE_OFFSET = 36;",
            "lineNumber": 129
          },
          {
            "lineNumber": 130
          },
          {
            "text": "\t// —— Welcome: alone in first block, no overlap with column 1 ——",
            "lineNumber": 131
          },
          {
            "text": "\tconst welcome = \"welcome\";",
            "lineNumber": 132
          },
          {
            "text": "\tconst welcomeY = TUT_TOP;",
            "lineNumber": 133
          },
          {
            "lineNumber": 134
          },
          {
            "text": "\t// —— Column 1: Primary (comment left, node → output in lane) ——",
            "lineNumber": 135
          },
          {
            "text": "\tconst col1 = 1;",
            "lineNumber": 136
          },
          {
            "text": "\tconst lab1 = \"lab-primary\";",
            "lineNumber": 137
          },
          {
            "text": "\tconst orangeNode = \"orange-example\";",
            "lineNumber": 138
          },
          {
            "text": "\tconst orangeOut = \"orange-out\";",
            "lineNumber": 139
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.25845539569854736
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 308,
            "column": 1
          },
          "endPosition": {
            "line": 426,
            "column": 1
          }
        },
        "contents": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */\nasync function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return \"\";\n\t// #region agent log\n\tfetch(\"http://127.0.0.1:7243/ingest/453147b6-6b57-40b4-a769-82c9dd3c5ee7\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ location: \"runner.ts:runSingleNode\", message: \"entry node color from loaded data\", data: { nodeId, nodeType: (node as { type?: string }).type, nodeColor: (node as { color?: string }).color }, timestamp: Date.now(), sessionId: \"debug-session\", hypothesisId: \"A\" }) }).catch(() =&gt; {});\n\t// #endregion\n\tconst role = getNodeRole(node, settings);\n\tif (!role || role === \"yellow\" || role === \"green\") {\n\t\t// Yellow = text (input pass-through): merge parent results with own content, same as AI/Python nodes\n\t\tif (role === \"yellow\") {\n\t\t\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\t\t\tconst nodeInput = await getNodeContent(node, app.vault);\n\t\t\tconst { concatenatedPart, template } = buildInputWithVariables(\n\t\t\t\tcanvasKey,\n\t\t\t\tnodeInput,\n\t\t\t\tincoming\n\t\t\t);\n\t\t\tconst fullContent =\n\t\t\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\t\t\tsetNodeResult(canvasKey, nodeId, fullContent);\n\t\t\treturn fullContent;\n\t\t}\n\t\treturn \"\";\n\t}\n\t// For Python (blue) text nodes, auto-wrap content in &#96;&#96;&#96;python ... &#96;&#96;&#96; so # comments render correctly\n\tif (role === \"blue\" &amp;&amp; isTextNode(node))\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 311
          },
          {
            "text": "async function runSingleNode(",
            "lineNumber": 312,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 313,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 314,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 315,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 316,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 317,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 318,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 319,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 320,
            "isSignature": true
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 321
          },
          {
            "text": "\tif (!node) return \"\";",
            "lineNumber": 322
          },
          {
            "text": "\t// #region agent log",
            "lineNumber": 323
          },
          {
            "text": "\tfetch(\"http://127.0.0.1:7243/ingest/453147b6-6b57-40b4-a769-82c9dd3c5ee7\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ location: \"runner.ts:runSingleNode\", message: \"entry node color from loaded data\", data: { nodeId, nodeType: (node as { type?: string }).type, nodeColor: (node as { color?: string }).color }, timestamp: Date.now(), sessionId: \"debug-session\", hypothesisId: \"A\" }) }).catch(() =&gt; {});",
            "lineNumber": 324
          },
          {
            "text": "\t// #endregion",
            "lineNumber": 325
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 326
          },
          {
            "text": "\tif (!role || role === \"yellow\" || role === \"green\") {",
            "lineNumber": 327
          },
          {
            "text": "\t\t// Yellow = text (input pass-through): merge parent results with own content, same as AI/Python nodes",
            "lineNumber": 328
          },
          {
            "text": "\t\tif (role === \"yellow\") {",
            "lineNumber": 329
          },
          {
            "text": "\t\t\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 330
          },
          {
            "text": "\t\t\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 331
          },
          {
            "text": "\t\t\tconst { concatenatedPart, template } = buildInputWithVariables(",
            "lineNumber": 332
          },
          {
            "text": "\t\t\t\tcanvasKey,",
            "lineNumber": 333
          },
          {
            "text": "\t\t\t\tnodeInput,",
            "lineNumber": 334
          },
          {
            "text": "\t\t\t\tincoming",
            "lineNumber": 335
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 336
          },
          {
            "text": "\t\t\tconst fullContent =",
            "lineNumber": 337
          },
          {
            "text": "\t\t\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 338
          },
          {
            "text": "\t\t\tsetNodeResult(canvasKey, nodeId, fullContent);",
            "lineNumber": 339
          },
          {
            "text": "\t\t\treturn fullContent;",
            "lineNumber": 340
          },
          {
            "text": "\t\t}",
            "lineNumber": 341
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 342
          },
          {
            "text": "\t}",
            "lineNumber": 343
          },
          {
            "text": "\t// For Python (blue) text nodes, auto-wrap content in &#96;&#96;&#96;python ... &#96;&#96;&#96; so # comments render correctly",
            "lineNumber": 344
          },
          {
            "text": "\tif (role === \"blue\" &amp;&amp; isTextNode(node))",
            "lineNumber": 345
          },
          {
            "text": "}",
            "lineNumber": 427,
            "isSignature": true
          }
        ]
      },
      "score": 0.25410449504852295
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/nodes.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 34,
            "column": 1
          }
        },
        "contents": "import type {Vault} from \"obsidian\";\nimport type {AllCanvasNodeData, CanvasData, CanvasFileData, CanvasTextData} from \"obsidian/canvas\";\nimport {\n\tgetFileNodePath,\n\tgetNodeById,\n\tgetNodeRole,\n\tgetParentIdsSortedByY,\n\tgetTextNodeContent,\n\tisFileNode,\n\tisTextNode,\n} from \"./types\";\nimport type {ZettelPluginSettings} from \"../settings\";\n\n/** Load canvas data from vault by reading the canvas file (JSON). */\nexport async function loadCanvasData(vault: Vault, filePath: string): Promise&lt;CanvasData | null&gt; {\n\ttry {\n\t\tconst raw = await vault.adapter.read(filePath);\n\t\tconst data = JSON.parse(raw) as CanvasData;\n\t\tif (data &amp;&amp; Array.isArray(data.nodes) &amp;&amp; Array.isArray(data.edges)) return data;\n\t} catch {\n\t\t// ignore\n\t}\n\treturn null;\n}\n\n/** Save canvas data to vault (writes the canvas file). */\nexport async function saveCanvasData(vault: Vault, filePath: string, data: CanvasData): Promise&lt;boolean&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {Vault} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import type {AllCanvasNodeData, CanvasData, CanvasFileData, CanvasTextData} from \"obsidian/canvas\";",
            "lineNumber": 2
          },
          {
            "text": "import {",
            "lineNumber": 3
          },
          {
            "text": "\tgetFileNodePath,",
            "lineNumber": 4
          },
          {
            "text": "\tgetNodeById,",
            "lineNumber": 5
          },
          {
            "text": "\tgetNodeRole,",
            "lineNumber": 6
          },
          {
            "text": "\tgetParentIdsSortedByY,",
            "lineNumber": 7
          },
          {
            "text": "\tgetTextNodeContent,",
            "lineNumber": 8
          },
          {
            "text": "\tisFileNode,",
            "lineNumber": 9
          },
          {
            "text": "\tisTextNode,",
            "lineNumber": 10
          },
          {
            "text": "} from \"./types\";",
            "lineNumber": 11
          },
          {
            "text": "import type {ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 12
          },
          {
            "lineNumber": 13
          },
          {
            "text": "/** Load canvas data from vault by reading the canvas file (JSON). */",
            "lineNumber": 14
          },
          {
            "text": "export async function loadCanvasData(vault: Vault, filePath: string): Promise&lt;CanvasData | null&gt; {",
            "lineNumber": 15,
            "isSignature": true
          },
          {
            "text": "\ttry {",
            "lineNumber": 16
          },
          {
            "text": "\t\tconst raw = await vault.adapter.read(filePath);",
            "lineNumber": 17
          },
          {
            "text": "\t\tconst data = JSON.parse(raw) as CanvasData;",
            "lineNumber": 18
          },
          {
            "text": "\t\tif (data &amp;&amp; Array.isArray(data.nodes) &amp;&amp; Array.isArray(data.edges)) return data;",
            "lineNumber": 19
          },
          {
            "text": "\t} catch {",
            "lineNumber": 20
          },
          {
            "text": "\t\t// ignore",
            "lineNumber": 21
          },
          {
            "text": "\t}",
            "lineNumber": 22
          },
          {
            "text": "\treturn null;",
            "lineNumber": 23
          },
          {
            "text": "}",
            "lineNumber": 24,
            "isSignature": true
          },
          {
            "lineNumber": 25
          },
          {
            "text": "/** Save canvas data to vault (writes the canvas file). */",
            "lineNumber": 26
          },
          {
            "text": "export async function saveCanvasData(vault: Vault, filePath: string, data: CanvasData): Promise&lt;boolean&gt; {",
            "lineNumber": 27,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 28
          },
          {
            "text": "}",
            "lineNumber": 35,
            "isSignature": true
          }
        ]
      },
      "score": 0.24292290210723877
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 311
          },
          "endPosition": {
            "line": 426,
            "column": 1
          }
        },
        "contents": "async function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\n\t\treturn \"\";\n\t}\n\t// For Python (blue) text nodes, auto-wrap content in &#96;&#96;&#96;python ... &#96;&#96;&#96; so # comments render correctly\n\tif (role === \"blue\" &amp;&amp; isTextNode(node)) {\n\t\tconst raw = getTextNodeContent(node as CanvasTextData);\n\t\tif (!isPythonCodeFenced(raw)) {\n\t\t\t(node as CanvasTextData).text = ensurePythonCodeFence(raw);\n\t\t\tconst liveData = liveCanvas?.getData?.();\n\t\t\tif (liveData?.nodes) mergePreserveUserNodeProps(data, liveData);\n\t\t\tliveCanvas?.setData?.(data);\n\t\t\tif (liveCanvas?.requestSave) liveCanvas.requestSave();\n\t\t\tawait saveCanvasData(app.vault, canvasFilePath, data);\n\t\t}\n\t}\n\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\tconst nodeInput = await getNodeContent(node, app.vault);\n\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(\n\t\tcanvasKey,\n\t\tnodeInput,\n\t\tincoming\n\t);\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n\t\tconst temperature = settings.ollamaOrangeTemperature ?? DEFAULT_SETTINGS.ollamaOrangeTemperature;\n\t\tconst result = await ollamaGenerate({\n\t\t\tmodel,\n\t\t\tprompt: fullPrompt,\n\t\t\tstream: false,\n\t\t\toptions: { temperature },\n\t\t});\n\t\tsetNodeResult(canvasKey, nodeId, result.response);\n\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {\n\t\t\tfullPrompt,\n\t\t\tthinking: result.thinking,\n\t\t});\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result.response;\n\t}\n\tif (role === \"purple\") {\n\t\tconst model = settings.ollamaPurpleModel || \"llama2\";\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 312,
                "column": 1
              },
              "endPosition": {
                "line": 321,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "async function runSingleNode(",
            "lineNumber": 312,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 313,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 314,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 315,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 316,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 317,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 318,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 319,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 320,
            "isSignature": true
          },
          {
            "lineNumber": 341
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 342
          },
          {
            "text": "\t}",
            "lineNumber": 343
          },
          {
            "text": "\t// For Python (blue) text nodes, auto-wrap content in &#96;&#96;&#96;python ... &#96;&#96;&#96; so # comments render correctly",
            "lineNumber": 344
          },
          {
            "text": "\tif (role === \"blue\" &amp;&amp; isTextNode(node)) {",
            "lineNumber": 345
          },
          {
            "text": "\t\tconst raw = getTextNodeContent(node as CanvasTextData);",
            "lineNumber": 346
          },
          {
            "text": "\t\tif (!isPythonCodeFenced(raw)) {",
            "lineNumber": 347
          },
          {
            "text": "\t\t\t(node as CanvasTextData).text = ensurePythonCodeFence(raw);",
            "lineNumber": 348
          },
          {
            "text": "\t\t\tconst liveData = liveCanvas?.getData?.();",
            "lineNumber": 349
          },
          {
            "text": "\t\t\tif (liveData?.nodes) mergePreserveUserNodeProps(data, liveData);",
            "lineNumber": 350
          },
          {
            "text": "\t\t\tliveCanvas?.setData?.(data);",
            "lineNumber": 351
          },
          {
            "text": "\t\t\tif (liveCanvas?.requestSave) liveCanvas.requestSave();",
            "lineNumber": 352
          },
          {
            "text": "\t\t\tawait saveCanvasData(app.vault, canvasFilePath, data);",
            "lineNumber": 353
          },
          {
            "text": "\t\t}",
            "lineNumber": 354
          },
          {
            "text": "\t}",
            "lineNumber": 355
          },
          {
            "text": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 356
          },
          {
            "text": "\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 357
          },
          {
            "text": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(",
            "lineNumber": 358
          },
          {
            "text": "\t\tcanvasKey,",
            "lineNumber": 359
          },
          {
            "text": "\t\tnodeInput,",
            "lineNumber": 360
          },
          {
            "text": "\t\tincoming",
            "lineNumber": 361
          },
          {
            "text": "\t);",
            "lineNumber": 362
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 363
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 364
          },
          {
            "lineNumber": 365
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 366
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 367
          },
          {
            "text": "\t\tconst temperature = settings.ollamaOrangeTemperature ?? DEFAULT_SETTINGS.ollamaOrangeTemperature;",
            "lineNumber": 368
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({",
            "lineNumber": 369
          },
          {
            "text": "\t\t\tmodel,",
            "lineNumber": 370
          },
          {
            "text": "\t\t\tprompt: fullPrompt,",
            "lineNumber": 371
          },
          {
            "text": "\t\t\tstream: false,",
            "lineNumber": 372
          },
          {
            "text": "\t\t\toptions: { temperature },",
            "lineNumber": 373
          },
          {
            "text": "\t\t});",
            "lineNumber": 374
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result.response);",
            "lineNumber": 375
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {",
            "lineNumber": 376
          },
          {
            "text": "\t\t\tfullPrompt,",
            "lineNumber": 377
          },
          {
            "text": "\t\t\tthinking: result.thinking,",
            "lineNumber": 378
          },
          {
            "text": "\t\t});",
            "lineNumber": 379
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 380
          },
          {
            "text": "\t\treturn result.response;",
            "lineNumber": 381
          },
          {
            "text": "\t}",
            "lineNumber": 382
          },
          {
            "text": "\tif (role === \"purple\") {",
            "lineNumber": 383
          },
          {
            "text": "\t\tconst model = settings.ollamaPurpleModel || \"llama2\";",
            "lineNumber": 384
          },
          {
            "text": "}",
            "lineNumber": 427,
            "isSignature": true
          }
        ]
      },
      "score": 0.24277305603027344
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 324,
            "column": 1
          },
          "endPosition": {
            "line": 902,
            "column": 1
          }
        },
        "contents": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */\nlet debugNodeMenuFired = false;\n\nexport default class ZettelThinkingBoardPlugin extends Plugin {\n\tsettings: ZettelPluginSettings;\n\n\tasync onload() {\n\t\ttry {\n\t\t\tawait this.loadSettings();\n\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));\n\n\t\t\tthis.registerView(\n\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,\n\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)\n\t\t\t);\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"open-zettel-controls\",\n\t\t\t\tname: \"Open Zettel Controls\",\n\t\t\t\tcallback: () =&gt; this.activateZettelControls(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"create-tutorial-canvas\",\n\t\t\t\tname: \"Create tutorial canvas\",\n\t\t\t\tcallback: () =&gt; this.createTutorialCanvas(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"duplicate-canvas-template\",\n\t\t\t\tname: \"Duplicate canvas template\",\n\t\t\t\tcallback: () =&gt; this.duplicateCanvasTemplate(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"save-canvas-as-template\",\n\t\t\t\tname: \"Save canvas as template\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tthis.saveCanvasAsTemplate();\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"edit-canvas-template\",\n\t\t\t\tname: \"Edit canvas template\",\n\t\t\t\tcallback: () =&gt; this.editCanvasTemplate(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-node\",\n\t\t\t\tname: \"Run node\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand\n\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 327
          },
          {
            "text": "let debugNodeMenuFired = false;",
            "lineNumber": 328
          },
          {
            "lineNumber": 329
          },
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 330,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings;",
            "lineNumber": 331
          },
          {
            "lineNumber": 332
          },
          {
            "text": "\tasync onload() {",
            "lineNumber": 333
          },
          {
            "text": "\t\ttry {",
            "lineNumber": 334
          },
          {
            "text": "\t\t\tawait this.loadSettings();",
            "lineNumber": 335
          },
          {
            "text": "\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));",
            "lineNumber": 336
          },
          {
            "lineNumber": 337
          },
          {
            "text": "\t\t\tthis.registerView(",
            "lineNumber": 338
          },
          {
            "text": "\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,",
            "lineNumber": 339
          },
          {
            "text": "\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)",
            "lineNumber": 340
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 341
          },
          {
            "lineNumber": 342
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 343
          },
          {
            "text": "\t\t\t\tid: \"open-zettel-controls\",",
            "lineNumber": 344
          },
          {
            "text": "\t\t\t\tname: \"Open Zettel Controls\",",
            "lineNumber": 345
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.activateZettelControls(),",
            "lineNumber": 346
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 347
          },
          {
            "lineNumber": 348
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 349
          },
          {
            "text": "\t\t\t\tid: \"create-tutorial-canvas\",",
            "lineNumber": 350
          },
          {
            "text": "\t\t\t\tname: \"Create tutorial canvas\",",
            "lineNumber": 351
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.createTutorialCanvas(),",
            "lineNumber": 352
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 353
          },
          {
            "lineNumber": 354
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 355
          },
          {
            "text": "\t\t\t\tid: \"duplicate-canvas-template\",",
            "lineNumber": 356
          },
          {
            "text": "\t\t\t\tname: \"Duplicate canvas template\",",
            "lineNumber": 357
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.duplicateCanvasTemplate(),",
            "lineNumber": 358
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 359
          },
          {
            "lineNumber": 360
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 361
          },
          {
            "text": "\t\t\t\tid: \"save-canvas-as-template\",",
            "lineNumber": 362
          },
          {
            "text": "\t\t\t\tname: \"Save canvas as template\",",
            "lineNumber": 363
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 364
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 365
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 366
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 367
          },
          {
            "text": "\t\t\t\t\tthis.saveCanvasAsTemplate();",
            "lineNumber": 368
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 369
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 370
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 371
          },
          {
            "lineNumber": 372
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 373
          },
          {
            "text": "\t\t\t\tid: \"edit-canvas-template\",",
            "lineNumber": 374
          },
          {
            "text": "\t\t\t\tname: \"Edit canvas template\",",
            "lineNumber": 375
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.editCanvasTemplate(),",
            "lineNumber": 376
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 377
          },
          {
            "lineNumber": 378
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 379
          },
          {
            "text": "\t\t\t\tid: \"run-node\",",
            "lineNumber": 380
          },
          {
            "text": "\t\t\t\tname: \"Run node\",",
            "lineNumber": 381
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 382
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 383
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 384
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 385
          },
          {
            "text": "\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu",
            "lineNumber": 386
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");",
            "lineNumber": 387
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 388
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 389
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 390
          },
          {
            "lineNumber": 391
          },
          {
            "text": "\t\t\tthis.addCommand",
            "lineNumber": 392
          },
          {
            "lineNumber": 402
          },
          {
            "text": "\t}",
            "lineNumber": 595
          },
          {
            "text": "}",
            "lineNumber": 903,
            "isSignature": true
          }
        ]
      },
      "score": 0.23734240233898163
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 97
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\n\tconst col1 = 1;\n\tconst lab1 = \"lab-primary\";\n\tconst orangeNode = \"orange-example\";\n\tconst orangeOut = \"orange-out\";\n\tlet y1 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\tconst orangeY = y1;\n\ty1 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst orangeOutY = y1;\n\n\t// —— Column 2: Purple, Yellow, Blue (comments in margins, nodes in lane) ——\n\tconst col2 = 2;\n\tconst lab2a = \"lab-purple\";\n\tconst purpleNode = \"purple-example\";\n\tconst purpleOut = \"purple-out\";\n\tconst lab2b = \"lab-yellow\";\n\tconst yellowNode = \"yellow-example\";\n\tconst lab2c = \"lab-blue\";\n\tconst blueNode = \"blue-example\";\n\tconst blueOut = \"blue-out\";\n\tlet y2 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\tconst purpleY = y2;\n\ty2 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst purpleOutY = y2;\n\ty2 += TUT_NODE_H + TUT_NODE_GAP + 20;\n\tconst yellowY = y2;\n\ty2 += TUT_NODE_H + TUT_NODE_GAP + 20;\n\tconst blueY = y2;\n\ty2 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst blueOutY = y2;\n\n\t// —— Column 3: Concatenation ——\n\tconst col3 = 3;\n\tconst lab3 = \"lab-concat\";\n\tconst concatComment = \"concat-comment\";\n\tconst concatOrange = \"concat-orange\";\n\tconst concatOut = \"concat-out\";\n\tlet y3 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\tconst concatCommentY = y3;\n\ty3 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst concatOrangeY = y3;\n\ty3 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst concatOutY = y3;\n\n\t// —— Column 4: Variable injection ——\n\tconst col4 = 4;\n\tconst lab4 = \"lab-inject\";\n\tconst injectFirst = \"inject-first\";\n\tconst injectSecond = \"inject-second\";\n\tconst injectOut = \"inject-out\";\n\tlet y4 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\tconst injectFirstY = y4;\n\ty4 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst injectSecondY = y4;\n\ty4 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst injectOutY = y4;\n\n\t// —— Column 5 &amp; 6: Comments only (left margin + optional right), no nodes in lane ——\n\tconst col5 = 5;\n\tconst col6 = 6;\n\tconst lab5 = \"lab-commands\";\n\tconst lab6 = \"lab-sidebar\";\n\tconst y5 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\tconst y6 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\n\t// Group bounds (x, y, w, h) for each workflow block\n\tconst TUT_WELCOME_CARD_H = 132;\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 98,
                "column": 1
              },
              "endPosition": {
                "line": 99,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "lineNumber": 135
          },
          {
            "text": "\tconst col1 = 1;",
            "lineNumber": 136
          },
          {
            "text": "\tconst lab1 = \"lab-primary\";",
            "lineNumber": 137
          },
          {
            "text": "\tconst orangeNode = \"orange-example\";",
            "lineNumber": 138
          },
          {
            "text": "\tconst orangeOut = \"orange-out\";",
            "lineNumber": 139
          },
          {
            "text": "\tlet y1 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 140
          },
          {
            "text": "\tconst orangeY = y1;",
            "lineNumber": 141
          },
          {
            "text": "\ty1 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 142
          },
          {
            "text": "\tconst orangeOutY = y1;",
            "lineNumber": 143
          },
          {
            "lineNumber": 144
          },
          {
            "text": "\t// —— Column 2: Purple, Yellow, Blue (comments in margins, nodes in lane) ——",
            "lineNumber": 145
          },
          {
            "text": "\tconst col2 = 2;",
            "lineNumber": 146
          },
          {
            "text": "\tconst lab2a = \"lab-purple\";",
            "lineNumber": 147
          },
          {
            "text": "\tconst purpleNode = \"purple-example\";",
            "lineNumber": 148
          },
          {
            "text": "\tconst purpleOut = \"purple-out\";",
            "lineNumber": 149
          },
          {
            "text": "\tconst lab2b = \"lab-yellow\";",
            "lineNumber": 150
          },
          {
            "text": "\tconst yellowNode = \"yellow-example\";",
            "lineNumber": 151
          },
          {
            "text": "\tconst lab2c = \"lab-blue\";",
            "lineNumber": 152
          },
          {
            "text": "\tconst blueNode = \"blue-example\";",
            "lineNumber": 153
          },
          {
            "text": "\tconst blueOut = \"blue-out\";",
            "lineNumber": 154
          },
          {
            "text": "\tlet y2 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 155
          },
          {
            "text": "\tconst purpleY = y2;",
            "lineNumber": 156
          },
          {
            "text": "\ty2 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 157
          },
          {
            "text": "\tconst purpleOutY = y2;",
            "lineNumber": 158
          },
          {
            "text": "\ty2 += TUT_NODE_H + TUT_NODE_GAP + 20;",
            "lineNumber": 159
          },
          {
            "text": "\tconst yellowY = y2;",
            "lineNumber": 160
          },
          {
            "text": "\ty2 += TUT_NODE_H + TUT_NODE_GAP + 20;",
            "lineNumber": 161
          },
          {
            "text": "\tconst blueY = y2;",
            "lineNumber": 162
          },
          {
            "text": "\ty2 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 163
          },
          {
            "text": "\tconst blueOutY = y2;",
            "lineNumber": 164
          },
          {
            "lineNumber": 165
          },
          {
            "text": "\t// —— Column 3: Concatenation ——",
            "lineNumber": 166
          },
          {
            "text": "\tconst col3 = 3;",
            "lineNumber": 167
          },
          {
            "text": "\tconst lab3 = \"lab-concat\";",
            "lineNumber": 168
          },
          {
            "text": "\tconst concatComment = \"concat-comment\";",
            "lineNumber": 169
          },
          {
            "text": "\tconst concatOrange = \"concat-orange\";",
            "lineNumber": 170
          },
          {
            "text": "\tconst concatOut = \"concat-out\";",
            "lineNumber": 171
          },
          {
            "text": "\tlet y3 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 172
          },
          {
            "text": "\tconst concatCommentY = y3;",
            "lineNumber": 173
          },
          {
            "text": "\ty3 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 174
          },
          {
            "text": "\tconst concatOrangeY = y3;",
            "lineNumber": 175
          },
          {
            "text": "\ty3 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 176
          },
          {
            "text": "\tconst concatOutY = y3;",
            "lineNumber": 177
          },
          {
            "lineNumber": 178
          },
          {
            "text": "\t// —— Column 4: Variable injection ——",
            "lineNumber": 179
          },
          {
            "text": "\tconst col4 = 4;",
            "lineNumber": 180
          },
          {
            "text": "\tconst lab4 = \"lab-inject\";",
            "lineNumber": 181
          },
          {
            "text": "\tconst injectFirst = \"inject-first\";",
            "lineNumber": 182
          },
          {
            "text": "\tconst injectSecond = \"inject-second\";",
            "lineNumber": 183
          },
          {
            "text": "\tconst injectOut = \"inject-out\";",
            "lineNumber": 184
          },
          {
            "text": "\tlet y4 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 185
          },
          {
            "text": "\tconst injectFirstY = y4;",
            "lineNumber": 186
          },
          {
            "text": "\ty4 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 187
          },
          {
            "text": "\tconst injectSecondY = y4;",
            "lineNumber": 188
          },
          {
            "text": "\ty4 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 189
          },
          {
            "text": "\tconst injectOutY = y4;",
            "lineNumber": 190
          },
          {
            "lineNumber": 191
          },
          {
            "text": "\t// —— Column 5 &amp; 6: Comments only (left margin + optional right), no nodes in lane ——",
            "lineNumber": 192
          },
          {
            "text": "\tconst col5 = 5;",
            "lineNumber": 193
          },
          {
            "text": "\tconst col6 = 6;",
            "lineNumber": 194
          },
          {
            "text": "\tconst lab5 = \"lab-commands\";",
            "lineNumber": 195
          },
          {
            "text": "\tconst lab6 = \"lab-sidebar\";",
            "lineNumber": 196
          },
          {
            "text": "\tconst y5 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 197
          },
          {
            "text": "\tconst y6 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 198
          },
          {
            "lineNumber": 199
          },
          {
            "text": "\t// Group bounds (x, y, w, h) for each workflow block",
            "lineNumber": 200
          },
          {
            "text": "\tconst TUT_WELCOME_CARD_H = 132;",
            "lineNumber": 201
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.23320549726486206
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 66,
            "column": 1
          },
          "endPosition": {
            "line": 96,
            "column": 92
          }
        },
        "contents": "/** Build combined tutorial canvas: 3 workflows showcasing concatenation, variable injection, and Python state. */\nfunction getCombinedTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\tconst wf1 = getExample1CanvasData();\n\tconst wf23 = getExample4CanvasData();\n\tconst wf23Nodes = wf23.nodes.map((node) =&gt; ({\n\t\t...node,\n\t\tid: TUTORIAL_WORKFLOWS_23_ID_PREFIX + node.id,\n\t\tx: (node as { x: number }).x + TUTORIAL_WORKFLOWS_23_X_OFFSET,\n\t\tcolor: applyColorSettings(node.color, settings),\n\t}));\n\tconst wf23Edges = wf23.edges.map((edge, i) =&gt; ({\n\t\t...edge,\n\t\tid: &#96;${TUTORIAL_WORKFLOWS_23_ID_PREFIX}edge-${i}&#96;,\n\t\tfromNode: TUTORIAL_WORKFLOWS_23_ID_PREFIX + edge.fromNode,\n\t\ttoNode: TUTORIAL_WORKFLOWS_23_ID_PREFIX + edge.toNode,\n\t\tlabel: edge.label,\n\t}));\n\t// Apply color settings to workflow 1 as well\n\tconst wf1NodesWithColors = wf1.nodes.map((node) =&gt; ({\n\t\t...node,\n\t\tcolor: applyColorSettings(node.color, settings),\n\t}));\n\treturn {\n\t\tnodes: [...wf1NodesWithColors, ...wf23Nodes],\n\t\tedges: [...wf1.edges, ...wf23Edges],\n\t};\n}\n\n/** Build tutorial canvas: columns with comment margins, node lane center, edges, groups. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build combined tutorial canvas: 3 workflows showcasing concatenation, variable injection, and Python state. */",
            "lineNumber": 69
          },
          {
            "text": "function getCombinedTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 70,
            "isSignature": true
          },
          {
            "text": "\tconst wf1 = getExample1CanvasData();",
            "lineNumber": 71
          },
          {
            "text": "\tconst wf23 = getExample4CanvasData();",
            "lineNumber": 72
          },
          {
            "text": "\tconst wf23Nodes = wf23.nodes.map((node) =&gt; ({",
            "lineNumber": 73
          },
          {
            "text": "\t\t...node,",
            "lineNumber": 74
          },
          {
            "text": "\t\tid: TUTORIAL_WORKFLOWS_23_ID_PREFIX + node.id,",
            "lineNumber": 75
          },
          {
            "text": "\t\tx: (node as { x: number }).x + TUTORIAL_WORKFLOWS_23_X_OFFSET,",
            "lineNumber": 76
          },
          {
            "text": "\t\tcolor: applyColorSettings(node.color, settings),",
            "lineNumber": 77
          },
          {
            "text": "\t}));",
            "lineNumber": 78
          },
          {
            "text": "\tconst wf23Edges = wf23.edges.map((edge, i) =&gt; ({",
            "lineNumber": 79
          },
          {
            "text": "\t\t...edge,",
            "lineNumber": 80
          },
          {
            "text": "\t\tid: &#96;${TUTORIAL_WORKFLOWS_23_ID_PREFIX}edge-${i}&#96;,",
            "lineNumber": 81
          },
          {
            "text": "\t\tfromNode: TUTORIAL_WORKFLOWS_23_ID_PREFIX + edge.fromNode,",
            "lineNumber": 82
          },
          {
            "text": "\t\ttoNode: TUTORIAL_WORKFLOWS_23_ID_PREFIX + edge.toNode,",
            "lineNumber": 83
          },
          {
            "text": "\t\tlabel: edge.label,",
            "lineNumber": 84
          },
          {
            "text": "\t}));",
            "lineNumber": 85
          },
          {
            "text": "\t// Apply color settings to workflow 1 as well",
            "lineNumber": 86
          },
          {
            "text": "\tconst wf1NodesWithColors = wf1.nodes.map((node) =&gt; ({",
            "lineNumber": 87
          },
          {
            "text": "\t\t...node,",
            "lineNumber": 88
          },
          {
            "text": "\t\tcolor: applyColorSettings(node.color, settings),",
            "lineNumber": 89
          },
          {
            "text": "\t}));",
            "lineNumber": 90
          },
          {
            "text": "\treturn {",
            "lineNumber": 91
          },
          {
            "text": "\t\tnodes: [...wf1NodesWithColors, ...wf23Nodes],",
            "lineNumber": 92
          },
          {
            "text": "\t\tedges: [...wf1.edges, ...wf23Edges],",
            "lineNumber": 93
          },
          {
            "text": "\t};",
            "lineNumber": 94
          },
          {
            "text": "}",
            "lineNumber": 95,
            "isSignature": true
          },
          {
            "lineNumber": 96
          },
          {
            "text": "/** Build tutorial canvas: columns with comment margins, node lane center, edges, groups. */",
            "lineNumber": 97
          }
        ]
      },
      "score": 0.22683550417423248
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 131,
            "column": 1
          },
          "endPosition": {
            "line": 143,
            "column": 101
          }
        },
        "contents": "/** Create a label element using Obsidian's canvas-node-label class (same as file nodes). */\nfunction createLabelEl(text: string): HTMLElement {\n\tconst el = document.createElement(\"div\");\n\tel.setAttribute(\"class\", &#96;${LABEL_CLASS} canvas-node-label&#96;);\n\tel.setAttribute(LABEL_DATA_ATTR, \"1\");\n\tel.style.pointerEvents = \"none\"; // ensure label never blocks node drag even if CSS is overridden\n\tel.textContent = text;\n\treturn el;\n}\n\n/** Create the concatenation-order badge (top-right of node). Number is 1-based; top of order = 1. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Create a label element using Obsidian's canvas-node-label class (same as file nodes). */",
            "lineNumber": 134
          },
          {
            "text": "function createLabelEl(text: string): HTMLElement {",
            "lineNumber": 135,
            "isSignature": true
          },
          {
            "text": "\tconst el = document.createElement(\"div\");",
            "lineNumber": 136
          },
          {
            "text": "\tel.setAttribute(\"class\", &#96;${LABEL_CLASS} canvas-node-label&#96;);",
            "lineNumber": 137
          },
          {
            "text": "\tel.setAttribute(LABEL_DATA_ATTR, \"1\");",
            "lineNumber": 138
          },
          {
            "text": "\tel.style.pointerEvents = \"none\"; // ensure label never blocks node drag even if CSS is overridden",
            "lineNumber": 139
          },
          {
            "text": "\tel.textContent = text;",
            "lineNumber": 140
          },
          {
            "text": "\treturn el;",
            "lineNumber": 141
          },
          {
            "text": "}",
            "lineNumber": 142,
            "isSignature": true
          },
          {
            "lineNumber": 143
          },
          {
            "text": "/** Create the concatenation-order badge (top-right of node). Number is 1-based; top of order = 1. */",
            "lineNumber": 144
          }
        ]
      },
      "score": 0.22562336921691895
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/nodes.ts",
        "range": {
          "startPosition": {
            "line": 23,
            "column": 1
          },
          "endPosition": {
            "line": 56,
            "column": 1
          }
        },
        "contents": "/** Save canvas data to vault (writes the canvas file). */\nexport async function saveCanvasData(vault: Vault, filePath: string, data: CanvasData): Promise&lt;boolean&gt; {\n\ttry {\n\t\tconst raw = JSON.stringify(data);\n\t\tawait vault.adapter.write(filePath, raw);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/** Get input content for a node: text node content or full file content. */\nexport async function getNodeContent(\n\tnode: AllCanvasNodeData,\n\tvault: Vault\n): Promise&lt;string&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Save canvas data to vault (writes the canvas file). */",
            "lineNumber": 26
          },
          {
            "text": "export async function saveCanvasData(vault: Vault, filePath: string, data: CanvasData): Promise&lt;boolean&gt; {",
            "lineNumber": 27,
            "isSignature": true
          },
          {
            "text": "\ttry {",
            "lineNumber": 28
          },
          {
            "text": "\t\tconst raw = JSON.stringify(data);",
            "lineNumber": 29
          },
          {
            "text": "\t\tawait vault.adapter.write(filePath, raw);",
            "lineNumber": 30
          },
          {
            "text": "\t\treturn true;",
            "lineNumber": 31
          },
          {
            "text": "\t} catch {",
            "lineNumber": 32
          },
          {
            "text": "\t\treturn false;",
            "lineNumber": 33
          },
          {
            "text": "\t}",
            "lineNumber": 34
          },
          {
            "text": "}",
            "lineNumber": 35,
            "isSignature": true
          },
          {
            "lineNumber": 36
          },
          {
            "text": "/** Get input content for a node: text node content or full file content. */",
            "lineNumber": 37
          },
          {
            "text": "export async function getNodeContent(",
            "lineNumber": 38,
            "isSignature": true
          },
          {
            "text": "\tnode: AllCanvasNodeData,",
            "lineNumber": 39,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault",
            "lineNumber": 40,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 41,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 42
          },
          {
            "text": "}",
            "lineNumber": 57,
            "isSignature": true
          }
        ]
      },
      "score": 0.2189321517944336
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

Checking how the canvas is updated when we save data and whether node positions are in canvas vs. viewport coordinates:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "setData|getData|pos\\.|\\.pos|canvas.*position",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "setData|getData|pos\\.|\\.pos|canvas.*position",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "outputMode": "content",
  "totalFiles": 4,
  "totalMatches": 28,
  "topFiles": [
    {
      "uri": "src/canvas/canvasNodeLabels.ts",
      "matchCount": 1
    },
    {
      "uri": "src/engine/runner.ts",
      "matchCount": 9
    },
    {
      "uri": "src/main.ts",
      "matchCount": 16
    },
    {
      "uri": "src/engine/canvasApi.ts",
      "matchCount": 2
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

Searching for edge endpoint handling and Obsidian canvas node/edge structure:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fromEnd|toEnd|fromSide|toSide",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
  "contextBefore": 0,
  "contextAfter": 0,
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "fromEnd|toEnd|fromSide|toSide",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
  "outputMode": "content",
  "totalFiles": 3,
  "totalMatches": 16,
  "topFiles": [
    {
      "uri": "./src/engine/runner.ts",
      "matchCount": 10
    },
    {
      "uri": "./src/main.ts",
      "matchCount": 2
    },
    {
      "uri": "./src/canvas/types.test.ts",
      "matchCount": 4
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="web_search">
<details>
            <summary>Tool use: **web_search** • Searched web `undefined` • **1** results</summary>
        
| Title | URL | Chunk |
|-------|-----|-------|
| Web search results for query: Obsidian canvas plugin edge fromEnd toEnd node position coordinates |  | Links:<br/>1. [Search code, repositories, users, issues, pull requests...](https://github.com/quorafind/obsidian-canvas-node-resize)<br/>2. [Search code, repositories, users, issues, pull requests...](https://github.com/aarongilly/obsidian-semantic-canvas-plugin)<br/>3. [Search code, repositories, users, issues, pull requests...](https://github.com/obsidianmd/obsidian-api/blob/master/canvas.d.ts)<br/>4. [Canvas - Obsidian Help](https://help.obsidian.md/plugins/canvas)<br/>5. [Janik von Rotz](https://janikvonrotz.ch/2023/06/07/convert-obsidian-canvas-to-svg/)<br/><br/># Obsidian Canvas Plugin: Edge and Node Properties<br/><br/>Based on the official Obsidian API documentation, here's what you need to know about canvas edges and node positions:<br/><br/>## Node Position Coordinates[3]<br/><br/>Canvas nodes have the following positional properties:<br/>- **x**: number (horizontal position)<br/>- **y**: number (vertical position)<br/>- **width**: number (node width)<br/>- **height**: number (node height)<br/>- **id**: string (unique identifier)<br/><br/>## Edge Properties[3]<br/><br/>Canvas edges connect nodes and include:<br/>- **id**: string (unique identifier)<br/>- **fromNode**: string (ID of the source node)<br/>- **toNode**: string (ID of the destination node)<br/>- **fromSide**: string (optional since v1.7.2 - which side of source node the edge starts from: "top", "bottom", "left", or "right")<br/>- **toSide**: string (optional since v1.7.2 - which side of destination node the edge ends at)<br/><br/>Note: The `fromEnd` and `toEnd` properties you mentioned in your query don't appear in the official canvas.d.ts specification. The edges use `fromSide` and `toSide` instead to specify which side of each node the connection is made.[3]<br/><br/>## Canvas File Format<br/><br/>Canvas data is stored as `.canvas` files using the JSON Canvas open format.[4] The file structure contains a `nodes` array and an `edges` array with the properties listed above.[5] |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

Checking the canvas types and how the tutorial builds edges:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "CanvasEdgeData|CanvasData|edges",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "CanvasEdgeData|CanvasData|edges",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts",
  "outputMode": "content",
  "totalFiles": 1,
  "totalMatches": 22,
  "topFiles": [
    {
      "uri": "src/canvas/types.ts",
      "matchCount": 22
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

Checking for existing debug logs to remove or repurpose and locating where we push the output edge:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "127\\.0\\.0\\.1:7243|ingest/",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "127\\.0\\.0\\.1:7243|ingest/",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "outputMode": "content",
  "totalFiles": 1,
  "totalMatches": 3,
  "topFiles": [
    {
      "uri": "src/engine/runner.ts",
      "matchCount": 3
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

Adding instrumentation to test hypotheses about the arrow/edge gap. Creating a short task list and inserting the logs.


---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Add debug instrumentation for edge/position hypotheses
- [ ] Clear debug.log and ask user to reproduce
- [ ] Analyze logs and fix with evidence
- [ ] Verify fix with post-fix logs

</details>
</tool-use>

---

Adding instrumentation: logging when we create the output edge (with/without fromSide/toSide), node positions used for placement, and data right before setData.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

Logging the output edge after both branches so we record it when the edge already existed.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

Checking the file: the edit may have broken the if/else flow.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

Fixing the broken if/else: the new-node branch should run when `!outId`.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

Moving the "output edge after ensure" log to after both branches so `resolvedOutputId` is defined when `!outId`.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

The string to replace was not found in the file.

---



---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---



---

The string to replace was not found in the file.

---



---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---



---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Add debug instrumentation for edge/position hypotheses
- [-] Clear debug.log and ask user to reproduce
- [ ] Analyze logs and fix with evidence
- [ ] Verify fix with post-fix logs

</details>
</tool-use>

---

Clearing the debug log file and providing reproduction steps:


---

File not found: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/.cursor/debug.log

---

Instrumentation is in place. Here’s the current picture and what to do next.

**Hypotheses being tested**

1. **Hypothesis A**: The run→output edge is created **without** `fromSide`/`toSide`, so Obsidian draws it center-to-center and the arrow doesn’t meet the node border.
2. **Hypothesis B**: `getData()` returns node positions in a different coordinate system; we merge them and persist, so nodes (and thus edge endpoints) end up offset.
3. **Hypothesis C**: The output edge is correct in our `data` (e.g. has sides) but something we pass to `setData` or Obsidian’s handling strips or ignores it.
4. **Hypothesis D**: Output node position (`chosenX`/`chosenY`) or source position is in the wrong space, so the green node is offset and the arrow appears to miss.
5. **Hypothesis E**: Same as A for the **new** output node branch: we never set `fromSide`/`toSide` on the new edge.

Instrumentation added:

- **ensureOutputNodeAndEdge**: logs source/output positions (D), and when we push the output edge (existing and new) logs whether the edge has `fromSide`/`toSide` (A, E). After ensuring the output node/edge, logs the output edge’s `fromSide`/`toSide` (A).
- **updateEdgeLabelsAndSave**: right before `setData(data)`, logs the output edge’s `fromSide`/`toSide` (C).
- **mergePreserveUserNodeProps**: on the first merged node, logs `data` vs `live` x/y (B).

<reproduction_steps>
1. Build the plugin: run `npm run build` in the plugin folder.
2. Restart Obsidian (or reload the plugin) so the new build is loaded.
3. Open a canvas that uses run→output (e.g. run an orange/LLM node so a green output node and its edge are created, or use an existing canvas that already has that arrow).
4. Reproduce the issue: confirm there is a visible gap between the arrow tip and the edge of the note (run node → output node).
5. If you have an existing `.cursor/debug.log` in the plugin folder, delete it for a clean run, then run the action that creates or updates the output edge (e.g. run the node again, or open the canvas and trigger a save).
6. Click **Proceed** when done so the new logs can be analyzed.
</reproduction_steps>

After you reproduce and proceed, I’ll read `.cursor/debug.log`, evaluate each hypothesis (CONFIRMED/REJECTED/INCONCLUSIVE) with log evidence, and only then apply a fix and keep the instrumentation for a verification run.

---

_**User**_

@/Users/caffae/.cursor/projects/Users-caffae-Notes-TestPlugin-obsidian-plugins-Zettel-Thinking-Board/terminals/1.txt:38-64 

---

_**Agent (model default, mode Agent)**_

Fixing the control flow so TypeScript recognizes `resolvedOutputId` is always assigned.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

Converting the two separate `if` blocks into a single `if/else` so TypeScript recognizes `resolvedOutputId` is always assigned.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---



---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2** • Run command: cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build</summary>

```bash
cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build
```

```

&gt; zettel-thinking-board@1.0.6 build
&gt; tsc -noEmit -skipLibCheck &amp;&amp; node esbuild.config.mjs production


```
</details>
</tool-use>

---

The build was failing because TypeScript couldn’t prove that `resolvedOutputId` is always set. The logic was:

- `if (outId)` → set `resolvedOutputId = outId`
- `if (!outId)` → set `resolvedOutputId = newNodeId`

With two separate `if` blocks, the compiler doesn’t treat them as mutually exclusive, so it thinks there’s a path where neither runs and `resolvedOutputId` is never assigned.

I changed the second block to `else` so you have a single `if (outId) { ... } else { ... }`. That way exactly one branch runs and `resolvedOutputId` is always assigned, so the “used before being assigned” errors go away.

Build completes successfully now. You can run your reproduction steps again when ready.

---

_**User**_

In a vault with other plugins, I find that the position of the edges and the edge labels are wrong, but in another vault I find that it is alright I don't know why 

---

_**Agent (model default, mode Agent)**_

Investigating why edge and label positions differ between vaults. Searching the codebase for where we compute and apply those positions:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "getBoundingClientRect|getScreenCTM|containerEl|transform|position",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "getBoundingClientRect|getScreenCTM|containerEl|transform|position",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts",
  "outputMode": "content",
  "totalFiles": 1,
  "totalMatches": 40,
  "topFiles": [
    {
      "uri": "src/canvas/canvasNodeLabels.ts",
      "matchCount": 40
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

Checking how we obtain `containerEl` when syncing labels and whether the SVG is nested:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "syncCanvasEdgeModeLabels|syncCanvasRoleLabels|containerEl|roleLabelsContainerEl",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "syncCanvasEdgeModeLabels|syncCanvasRoleLabels|containerEl|roleLabelsContainerEl",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts",
  "outputMode": "content",
  "totalFiles": 1,
  "totalMatches": 44,
  "topFiles": [
    {
      "uri": "src/main.ts",
      "matchCount": 44
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>
</tool-use>

---

Adding instrumentation to capture why edge/label positions differ between vaults.


---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Add instrumentation for vault-specific edge/label position
- [ ] User reproduce in problematic vault, then analyze logs
- [ ] Fix with evidence and verify

</details>
</tool-use>

---



---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>

</tool-use>

---

Using a module-level flag so we log only the first edge once per sync:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>

</tool-use>

---



---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>

</tool-use>

---

Resetting the flag at the start of each sync so we log once per sync.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>

</tool-use>

---

Adding bestDist (distance from target to chosen path midpoint) to the first-edge log to detect wrong-path matching.


---

Cancelled

---

_**User**_

The bug is fixed. Please check that we have removed the debugging instrumentation

---

_**Agent (model default, mode Agent)**_

Searching the codebase for remaining debug instrumentation:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "127\\.0\\.0\\.1:7243|ingest/453147b6|#region agent log|#endregion|syncCanvasEdgeModeLabelsFirstEdgeLogged",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "127\\.0\\.0\\.1:7243|ingest/453147b6|#region agent log|#endregion|syncCanvasEdgeModeLabelsFirstEdgeLogged",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "outputMode": "content",
  "totalFiles": 1,
  "totalMatches": 27,
  "topFiles": [
    {
      "uri": "src/engine/runner.ts",
      "matchCount": 27
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---



---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "127\\.0\\.0\\.1:7243|ingest/|#region agent|#endregion|syncCanvasEdgeModeLabelsFirstEdgeLogged",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "127\\.0\\.0\\.1:7243|ingest/|#region agent|#endregion|syncCanvasEdgeModeLabelsFirstEdgeLogged",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts",
  "outputMode": "content",
  "totalFiles": 0,
  "totalMatches": 0,
  "topFiles": []
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fetch\\(|agent log|FirstEdgeLogged",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "fetch\\(|agent log|FirstEdgeLogged",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts",
  "outputMode": "content",
  "totalFiles": 0,
  "totalMatches": 0,
  "topFiles": []
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/canvasNodeLabels.ts</summary>

</details>
</tool-use>

---

Removing remaining debug instrumentation from `runner.ts`. `canvasNodeLabels.ts` is already clean.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

Verifying no remaining instrumentation and that the build passes:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "7243|ingest/|#region agent|#endregion",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Additional data:

```json
{
  "isPruned": true,
  "pattern": "7243|ingest/|#region agent|#endregion",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "outputMode": "content",
  "totalFiles": 0,
  "totalMatches": 0,
  "topFiles": []
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2** • Run command: cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build</summary>

```bash
cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build
```

```

&gt; zettel-thinking-board@1.0.6 build
&gt; tsc -noEmit -skipLibCheck &amp;&amp; node esbuild.config.mjs production


```
</details>
</tool-use>

---

Summary of what was done:

**Removed from `src/engine/runner.ts`:**
- **mergePreserveUserNodeProps**: `firstMergeLogged` and the fetch log for the first node merge.
- **updateEdgeLabelsAndSave**: All three log blocks (before merge, after merge, before setData output edge).
- **runSingleNode**: The entry fetch log.
- **ensureOutputNodeAndEdge**: The “positions” log, both “output edge pushed” logs, and the “output edge after ensure” log.

**Preserved the fix:** When adding the run→output edge (existing output node and new output node), the code still sets `fromSide: "bottom"` and `toSide: "top"` so the arrow connects at the node edges instead of the centers.

**`src/canvas/canvasNodeLabels.ts`:** No debug instrumentation was present (it was already clean or had been reverted).

**Verification:** Grep shows no remaining `7243`, `ingest/`, or `#region agent` in `src`, and `npm run build` completes successfully.

---

_**User**_

/recurring-bug-to-rules save the fix for the positioning of edges and nodes bug

---

_**Agent (model default, mode Agent)**_

Checking for `.cursor/rules/plugin-coding.mdc` and adding the edges/nodes positioning fix.


---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "undefined" • **0** result in **1** directory</summary>

Directory: **/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board** (0 file)

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="list_dir_v2">
<details>
<summary>Tool use: **list_dir_v2**</summary>


Parameters:

```json
{
  "targetDirectory": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/.cursor"
}
```
Additional data:

```json
{
  "isPruned": true,
  "rootPath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/.cursor",
  "totalDirs": 2,
  "totalFiles": 2,
  "topEntries": [
    {
      "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/.cursor/skills",
      "isDir": true,
      "numFiles": 0
    },
    {
      "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/.cursor/debug.log",
      "isDir": false
    }
  ],
  "extensionCounts": {}
}
```
Status: **completed**


</details>
</tool-use>

---



---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/.cursor/skills/recurring-bug-to-rules/SKILL.md</summary>

</details>
</tool-use>

---



---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/.cursor/rules/plugin-coding.mdc</summary>

</details>

</tool-use>

---

Created `.cursor/rules/plugin-coding.mdc` and added the edge/node positioning fix:

- **What was wrong:** Edges without `fromSide`/`toSide` are drawn center-to-center, so the arrow doesn’t meet the node border.
- **Fix:** Set `fromSide: "bottom"` and `toSide: "top"` on the run→output edge (and use the right sides for other layouts).
- **How to avoid:** Whenever adding an edge to `data.edges`, always set `fromSide` and `toSide` to match the layout so arrows attach at node edges.

The rule uses `alwaysApply: true` so it’s in context when working in this plugin. For future recurring bugs, add new `## [Short name]` sections to the same file.

---

