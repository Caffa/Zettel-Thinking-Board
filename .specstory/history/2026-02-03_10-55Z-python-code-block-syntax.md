<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session f9f441e0-c1a4-491d-b368-2fed932c2e83 (2026-02-03 10:55Z) -->

# Python code block syntax (2026-02-03 10:55Z)

_**User**_

Is there any way to do Python code syntax inside the Python blocks? So that #comments will render as comments instead of headings.

---

_**Agent (model default, mode Agent)**_


Searching the codebase for where Python blocks are rendered and how they're displayed.


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "python|code block|syntax|highlight",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
  "glob": "*.{ts,tsx,css,html}",
  "caseInsensitive": true
}
```
Result:

```json
{
  "success": {
    "pattern": "python|code block|syntax|highlight",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "./src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 33,
                  "content": "/** True if the role is non-AI (Python or text pass-through); prefer running these first for early output. */"
                },
                {
                  "lineNumber": 138,
                  "content": "/** Sort ready queue: non-AI (Python, text) first for early output, then by y. */"
                },
                {
                  "lineNumber": 225,
                  "content": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */"
                },
                {
                  "lineNumber": 300,
                  "content": "\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);"
                }
              ]
            },
            {
              "file": "./src/views/ZettelControlsView.ts",
              "matches": [
                {
                  "lineNumber": 126,
                  "content": "\t\t\t.setName(\"Restart Python kernel\")"
                },
                {
                  "lineNumber": 143,
                  "content": "\t\tenvDesc.setText(\"Key-value pairs for Python (not persisted).\");"
                },
                {
                  "lineNumber": 172,
                  "content": "\t\tconsoleTip.setText(\"In Python cards, call obsidian_log('your message') to see output here.\");"
                },
                {
                  "lineNumber": 197,
                  "content": "\t\t\t\"Each color is a different way to work with text: one color might ask an AI a question, another might run a short Python snippet, and the green card is where the result shows up.\","
                },
                {
                  "lineNumber": 201,
                  "content": "\t\t\t\"The green card is where answers and results appear. It gets created or updated when you run an AI or Python card.\","
                }
              ]
            },
            {
              "file": "./src/main.ts",
              "matches": [
                {
                  "lineNumber": 231,
                  "content": "\t\tn(lab2c, \"Python: runs code. Use variable input for parent text.\", commentLeftX(col2), blueY, \"\", TUT_COMMENT_W, TUT_LABEL_H),"
                },
                {
                  "lineNumber": 232,
                  "content": "\t\tn(blueNode, \"print('Python says:', (input or '')[:80] or '(no input)')\\n# input = text from parent\", laneNodeX(col2, LANE_OFFSET), blueY, cBlue, TUT_NODE_LANE_W, TUT_NODE_H),"
                },
                {
                  "lineNumber": 249,
                  "content": "\t\tn(lab6, \"Sidebar: Open Zettel Controls. There: pick Ollama models and Temperature; restart Python kernel; env vars; Console (obsidian_log in Python cards).\", commentLeftX(col6), y6, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 145),"
                },
                {
                  "lineNumber": 661,
                  "content": "\tgetKernelForActiveCanvas(): import(\"./engine/pythonKernel\").PythonKernel | null {"
                },
                {
                  "lineNumber": 664,
                  "content": "\t\treturn getKernelForCanvas(view.file.path, this.settings.pythonPath);"
                }
              ]
            },
            {
              "file": "./src/canvas/canvasNodeLabels.ts",
              "matches": [
                {
                  "lineNumber": 89,
                  "content": "/** Build and append the legend to the canvas container (vanilla DOM, no innerHTML). Order: primary → tertiary, then Python, Text, Output. */"
                },
                {
                  "lineNumber": 136,
                  "content": " * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first."
                }
              ]
            },
            {
              "file": "./src/settings.ts",
              "matches": [
                {
                  "lineNumber": 15,
                  "content": "\tblue: \"Python\","
                },
                {
                  "lineNumber": 23,
                  "content": "/** All roles that have a configurable node color. Canonical display order: primary → secondary → tertiary, then Python, Text, Output. */"
                },
                {
                  "lineNumber": 31,
                  "content": "\tblue: \"Python node\","
                },
                {
                  "lineNumber": 95,
                  "content": "\tpythonPath: string;"
                },
                {
                  "lineNumber": 115,
                  "content": "\tpythonPath: \"python3\","
                },
                {
                  "lineNumber": 388,
                  "content": "\t\t// Execution: model blocks (each: model + label + color) then Python"
                },
                {
                  "lineNumber": 408,
                  "content": "\t\t\t.setName(\"Python path\")"
                },
                {
                  "lineNumber": 409,
                  "content": "\t\t\t.setDesc(\"Path to Python executable for Python nodes (e.g. python3 or /usr/bin/python3)\")"
                },
                {
                  "lineNumber": 411,
                  "content": "\t\t\t\t.setPlaceholder(\"python3\")"
                },
                {
                  "lineNumber": 412,
                  "content": "\t\t\t\t.setValue(s.pythonPath)"
                },
                {
                  "lineNumber": 414,
                  "content": "\t\t\t\t\ts.pythonPath = value || \"python3\";"
                },
                {
                  "lineNumber": 427,
                  "content": "\t\t\t\"Python node\","
                },
                {
                  "lineNumber": 428,
                  "content": "\t\t\t\"Color for the Python node on the canvas\""
                },
                {
                  "lineNumber": 447,
                  "content": "\t\t\t.setDesc(\"Show a floating label above each node (e.g. Text, Python) based on its color\")"
                }
              ]
            },
            {
              "file": "./src/engine/pythonKernel.ts",
              "matches": [
                {
                  "lineNumber": 1,
                  "content": "/** Stub prepended to user Python script so obsidian_log() is available. Writes to stderr with OBSIDIAN_LOG prefix for side panel. */"
                },
                {
                  "lineNumber": 11,
                  "content": "export interface PythonKernel {"
                },
                {
                  "lineNumber": 17,
                  "content": "export function createPythonKernel(pythonPath: string): PythonKernel {"
                },
                {
                  "lineNumber": 29,
                  "content": "\t\t\t\tchild = spawn(pythonPath, [\"-u\", \"-i\"], {"
                },
                {
                  "lineNumber": 60,
                  "content": "\t\t\t\t\t\tpendingReject(new Error(&#96;Python exited with code ${code ?? \"unknown\"}&#96;));"
                },
                {
                  "lineNumber": 75,
                  "content": "\t\tif (!child?.stdin) throw new Error(\"Python process not running\");"
                },
                {
                  "lineNumber": 101,
                  "content": "\t\t\t\t\tpendingReject(new Error(\"Python execution timeout (60s)\"));"
                }
              ]
            },
            {
              "file": "./src/engine/kernelManager.ts",
              "matches": [
                {
                  "lineNumber": 1,
                  "content": "import type {PythonKernel} from \"./pythonKernel\";"
                },
                {
                  "lineNumber": 2,
                  "content": "import {createPythonKernel} from \"./pythonKernel\";"
                },
                {
                  "lineNumber": 5,
                  "content": "const kernels = new Map&lt;string, PythonKernel&gt;();"
                },
                {
                  "lineNumber": 7,
                  "content": "export function getKernelForCanvas(canvasKey: string, pythonPath: string): PythonKernel {"
                },
                {
                  "lineNumber": 10,
                  "content": "\t\tk = createPythonKernel(pythonPath);"
                }
              ]
            }
          ],
          "totalLines": 42,
          "totalMatchedLines": 42
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "#.*comment|heading|createEl|createDiv",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": true
}
```
Result:

```json
{
  "success": {
    "pattern": "#.*comment|heading|createEl|createDiv",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/views/ZettelControlsView.ts",
              "matches": [
                {
                  "lineNumber": 47,
                  "content": "\t\tconst scrollWrap = this.containerEl.createDiv({ cls: \"ztb-controls-view-content\" });"
                },
                {
                  "lineNumber": 48,
                  "content": "\t\tconst el = scrollWrap.createDiv({ cls: \"ztb-controls-container\" });"
                },
                {
                  "lineNumber": 51,
                  "content": "\t\tel.createEl(\"h4\", { text: \"Model mapping\", cls: \"ztb-section-title\" });"
                },
                {
                  "lineNumber": 52,
                  "content": "\t\tconst modelGroupsContainer = el.createDiv({ cls: \"ztb-controls-model-groups\" });"
                },
                {
                  "lineNumber": 53,
                  "content": "\t\tconst loadingEl = modelGroupsContainer.createDiv({ cls: \"ztb-ollama-loading\" });"
                },
                {
                  "lineNumber": 64,
                  "content": "\t\t\tconst group = parent.createDiv({ cls: \"ztb-controls-model-group\" });"
                },
                {
                  "lineNumber": 65,
                  "content": "\t\t\tconst header = group.createDiv({ cls: \"ztb-controls-model-group-header\" });"
                },
                {
                  "lineNumber": 124,
                  "content": "\t\tel.createEl(\"h4\", { text: \"Kernel controls\", cls: \"ztb-section-title\" });"
                },
                {
                  "lineNumber": 141,
                  "content": "\t\tel.createEl(\"h4\", { text: \"Environment variables\", cls: \"ztb-section-title\" });"
                },
                {
                  "lineNumber": 142,
                  "content": "\t\tconst envDesc = el.createEl(\"p\", { cls: \"ztb-env-desc\" });"
                },
                {
                  "lineNumber": 144,
                  "content": "\t\tconst envList = el.createDiv({ cls: \"ztb-env-list\" });"
                },
                {
                  "lineNumber": 146,
                  "content": "\t\t\tconst row = envList.createDiv({ cls: \"ztb-env-row\" });"
                },
                {
                  "lineNumber": 147,
                  "content": "\t\t\tconst keyInp = row.createEl(\"input\", { type: \"text\", cls: \"ztb-env-key\" });"
                },
                {
                  "lineNumber": 150,
                  "content": "\t\t\tconst valInp = row.createEl(\"input\", { type: \"text\", cls: \"ztb-env-val\" });"
                },
                {
                  "lineNumber": 160,
                  "content": "\t\t\trow.createEl(\"button\", { text: \"Remove\", cls: \"ztb-env-remove\" }).addEventListener(\"click\", () =&gt; {"
                },
                {
                  "lineNumber": 166,
                  "content": "\t\tconst addBtn = el.createEl(\"button\", { text: \"Add variable\", cls: \"ztb-env-add\" });"
                },
                {
                  "lineNumber": 170,
                  "content": "\t\tel.createEl(\"h4\", { text: \"Console\", cls: \"ztb-section-title\" });"
                },
                {
                  "lineNumber": 171,
                  "content": "\t\tconst consoleTip = el.createEl(\"p\", { cls: \"ztb-controls-tip\" });"
                },
                {
                  "lineNumber": 173,
                  "content": "\t\tconst consoleEl = el.createDiv({ cls: \"ztb-console\" });"
                },
                {
                  "lineNumber": 175,
                  "content": "\t\t\tconst p = consoleEl.createEl(\"p\", { cls: \"ztb-console-line\" });"
                },
                {
                  "lineNumber": 192,
                  "content": "\t\tel.createEl(\"h4\", { text: \"Guide tips\", cls: \"ztb-section-title\" });"
                },
                {
                  "lineNumber": 193,
                  "content": "\t\tconst guideDetails = el.createEl(\"details\", { cls: \"ztb-guide-details\" });"
                },
                {
                  "lineNumber": 194,
                  "content": "\t\tguideDetails.createEl(\"summary\", { cls: \"ztb-guide-summary\", text: \"How to use the canvas\" });"
                },
                {
                  "lineNumber": 195,
                  "content": "\t\tconst guideList = guideDetails.createEl(\"ul\", { cls: \"ztb-guide-list\" });"
                },
                {
                  "lineNumber": 206,
                  "content": "\t\t\tconst li = guideList.createEl(\"li\");"
                }
              ]
            },
            {
              "file": "src/main.ts",
              "matches": [
                {
                  "lineNumber": 604,
                  "content": "\t\tconst bar = containerEl.createDiv({ cls: ZettelThinkingBoardPlugin.ZTB_TOOLBAR_CLASS });"
                },
                {
                  "lineNumber": 605,
                  "content": "\t\tconst runBtn = bar.createEl(\"button\", { cls: \"ztb-toolbar-btn\" });"
                },
                {
                  "lineNumber": 610,
                  "content": "\t\tconst dismissBtn = bar.createEl(\"button\", { cls: \"ztb-toolbar-btn\" });"
                }
              ]
            },
            {
              "file": "src/canvas/canvasNodeLabels.ts",
              "matches": [
                {
                  "lineNumber": 78,
                  "content": "\tconst swatch = document.createElement(\"span\");"
                },
                {
                  "lineNumber": 93,
                  "content": "\tconst legend = document.createElement(\"div\");"
                },
                {
                  "lineNumber": 95,
                  "content": "\tconst title = document.createElement(\"div\");"
                },
                {
                  "lineNumber": 102,
                  "content": "\t\tconst row = document.createElement(\"div\");"
                },
                {
                  "lineNumber": 105,
                  "content": "\t\tconst text = document.createElement(\"span\");"
                },
                {
                  "lineNumber": 111,
                  "content": "\tconst otherRow = document.createElement(\"div\");"
                },
                {
                  "lineNumber": 113,
                  "content": "\tconst otherSwatch = document.createElement(\"span\");"
                },
                {
                  "lineNumber": 117,
                  "content": "\tconst otherText = document.createElement(\"span\");"
                },
                {
                  "lineNumber": 127,
                  "content": "\tconst el = document.createElement(\"div\");"
                },
                {
                  "lineNumber": 281,
                  "content": "\t\tconst labelGroup = document.createElementNS(SVG_NS, \"g\");"
                },
                {
                  "lineNumber": 292,
                  "content": "\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");"
                },
                {
                  "lineNumber": 300,
                  "content": "\t\tconst textEl = document.createElementNS(SVG_NS, \"text\");"
                }
              ]
            },
            {
              "file": "src/settings.ts",
              "matches": [
                {
                  "lineNumber": 182,
                  "content": "\tconst details = containerEl.createEl(\"details\", { cls: \"ztb-model-block\" });"
                },
                {
                  "lineNumber": 186,
                  "content": "\tconst summary = details.createEl(\"summary\", { cls: \"ztb-model-block-summary\" });"
                },
                {
                  "lineNumber": 187,
                  "content": "\tconst content = details.createDiv({ cls: \"ztb-model-block-content\" });"
                },
                {
                  "lineNumber": 286,
                  "content": "\tconst row = containerEl.createDiv({ cls: \"setting-item\" });"
                },
                {
                  "lineNumber": 287,
                  "content": "\tconst info = row.createDiv({ cls: \"setting-item-info\" });"
                },
                {
                  "lineNumber": 288,
                  "content": "\tinfo.createEl(\"div\", { cls: \"setting-item-name\", text: label });"
                },
                {
                  "lineNumber": 289,
                  "content": "\tinfo.createEl(\"div\", { cls: \"setting-item-description\", text: desc });"
                },
                {
                  "lineNumber": 290,
                  "content": "\tconst control = row.createDiv({ cls: \"setting-item-control\" });"
                },
                {
                  "lineNumber": 302,
                  "content": "\tconst dropdown = control.createEl(\"select\", { cls: \"dropdown\" });"
                },
                {
                  "lineNumber": 304,
                  "content": "\t\tconst opt = dropdown.createEl(\"option\", { text: p.label });"
                },
                {
                  "lineNumber": 308,
                  "content": "\tconst customOpt = dropdown.createEl(\"option\", { text: \"Custom (hex)\" });"
                },
                {
                  "lineNumber": 343,
                  "content": "\tconst customHex = control.createEl(\"input\", {"
                },
                {
                  "lineNumber": 385,
                  "content": "\t\tconst hint = containerEl.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });"
                },
                {
                  "lineNumber": 389,
                  "content": "\t\tconst executionSection = containerEl.createDiv({ cls: \"ztb-settings-section\" });"
                },
                {
                  "lineNumber": 390,
                  "content": "\t\texecutionSection.createEl(\"h4\", { text: \"Execution\", cls: \"ztb-section-title\" });"
                },
                {
                  "lineNumber": 391,
                  "content": "\t\tconst ollamaContainer = executionSection.createDiv({ cls: \"ztb-ollama-settings\" });"
                },
                {
                  "lineNumber": 392,
                  "content": "\t\tconst loadingEl = ollamaContainer.createDiv({ cls: \"ztb-ollama-loading\" });"
                },
                {
                  "lineNumber": 398,
                  "content": "\t\t\t\tconst fallback = ollamaContainer.createDiv({ cls: \"ztb-ollama-fallback\" });"
                },
                {
                  "lineNumber": 399,
                  "content": "\t\t\t\tfallback.createEl(\"p\", { text: \"Ollama not reachable or no models. Enter model names manually.\" });"
                },
                {
                  "lineNumber": 419,
                  "content": "\t\tconst displaySection = containerEl.createDiv({ cls: \"ztb-settings-section\" });"
                },
                {
                  "lineNumber": 420,
                  "content": "\t\tdisplaySection.createEl(\"h4\", { text: \"Display\", cls: \"ztb-section-title\" });"
                },
                {
                  "lineNumber": 421,
                  "content": "\t\tconst displayHint = displaySection.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });"
                }
              ]
            }
          ],
          "totalLines": 62,
          "totalMatchedLines": 62
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---


Checking how canvas node content is rendered (where Python/code appears):


---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Where is canvas node text or content rendered or displayed on the canvas?",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 131,
            "column": 1
          },
          "endPosition": {
            "line": 180,
            "column": 1
          }
        },
        "contents": "/**\n * Sync floating role labels for the active canvas: for each node whose color maps to a role,\n * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first.\n * Uses the live canvas node map to find each node's DOM element (.canvas-node).\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasRoleLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tsettings: ZettelPluginSettings,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tif (!settings.showNodeRoleLabels) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.nodes) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).\n\tclearCanvasRoleLabels(containerEl);\n\tsyncCanvasLegend(containerEl, settings);\n\tfor (const node of data.nodes) {\n\t\tconst role = getNodeRole(node, settings);\n\t\tif (!role) continue;\n\t\tconst labelText = getRoleLabel(role, settings);\n\t\tconst nodeEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||\n\t\t\tfindNodeElementByDataId(containerEl, node.id);\n\t\tif (!nodeEl) continue;\n\t\tconst label = createLabelEl(labelText);\n\t\t// Append after .canvas-node-container so it matches Obsidian file node label position\n\t\tnodeEl.append(label);\n\t}\n}\n\n/** Get center of an element in viewport coordinates. */\nfunction getElCenter(el: HTMLElement): { x: number; y: number } {\n\tconst r = el.getBoundingClientRect();\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/**",
            "lineNumber": 134
          },
          {
            "text": " * Sync floating role labels for the active canvas: for each node whose color maps to a role,",
            "lineNumber": 135
          },
          {
            "text": " * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first.",
            "lineNumber": 136
          },
          {
            "text": " * Uses the live canvas node map to find each node's DOM element (.canvas-node).",
            "lineNumber": 137
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 138
          },
          {
            "text": " */",
            "lineNumber": 139
          },
          {
            "text": "export async function syncCanvasRoleLabels(",
            "lineNumber": 140,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 141,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 142,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 143,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 144,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 145,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 146,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 147,
            "isSignature": true
          },
          {
            "text": "\tif (!settings.showNodeRoleLabels) {",
            "lineNumber": 148
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 149
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 150
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 151
          },
          {
            "text": "\t}",
            "lineNumber": 152
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 153
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 154
          },
          {
            "text": "\tif (!data?.nodes) {",
            "lineNumber": 155
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 156
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 157
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 158
          },
          {
            "text": "\t}",
            "lineNumber": 159
          },
          {
            "text": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).",
            "lineNumber": 160
          },
          {
            "text": "\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 161
          },
          {
            "text": "\tsyncCanvasLegend(containerEl, settings);",
            "lineNumber": 162
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 163
          },
          {
            "text": "\t\tconst role = getNodeRole(node, settings);",
            "lineNumber": 164
          },
          {
            "text": "\t\tif (!role) continue;",
            "lineNumber": 165
          },
          {
            "text": "\t\tconst labelText = getRoleLabel(role, settings);",
            "lineNumber": 166
          },
          {
            "text": "\t\tconst nodeEl =",
            "lineNumber": 167
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||",
            "lineNumber": 168
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, node.id);",
            "lineNumber": 169
          },
          {
            "text": "\t\tif (!nodeEl) continue;",
            "lineNumber": 170
          },
          {
            "text": "\t\tconst label = createLabelEl(labelText);",
            "lineNumber": 171
          },
          {
            "text": "\t\t// Append after .canvas-node-container so it matches Obsidian file node label position",
            "lineNumber": 172
          },
          {
            "text": "\t\tnodeEl.append(label);",
            "lineNumber": 173
          },
          {
            "text": "\t}",
            "lineNumber": 174
          },
          {
            "text": "}",
            "lineNumber": 175,
            "isSignature": true
          },
          {
            "lineNumber": 176
          },
          {
            "text": "/** Get center of an element in viewport coordinates. */",
            "lineNumber": 177
          },
          {
            "text": "function getElCenter(el: HTMLElement): { x: number; y: number } {",
            "lineNumber": 178,
            "isSignature": true
          },
          {
            "text": "\tconst r = el.getBoundingClientRect();",
            "lineNumber": 179
          },
          {
            "text": "}",
            "lineNumber": 181,
            "isSignature": true
          }
        ]
      },
      "score": 0.4330802857875824
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 46
          },
          "endPosition": {
            "line": 262,
            "column": 1
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\n\n\tconst nodes: CanvasData[\"nodes\"] = [\n\t\t// Groups first (render behind)\n\t\tgroupWelcome,\n\t\tgroupCol1,\n\t\tgroupCol2,\n\t\tgroupCol3,\n\t\tgroupCol4,\n\t\tgroupCol5,\n\t\tgroupCol6,\n\t\t// Welcome: plain text (no color = no role; not connected, does not add to prompt)\n\t\tn(welcome, \"Welcome to Zettel Thinking Board. Each column is a separate showcase. Nodes run top to bottom. Right-click a card → Run node or Run chain. Uncolored or unused-color cards are not connected to any node and do not add to the prompt.\", TUT_LEFT, welcomeY, \"\", TUT_WELCOME_W, 132),\n\n\t\t// Column 1: label = plain text; nodes in lane have roles\n\t\tn(lab1, \"Primary model: sends prompt to Ollama. Set the model in Zettel Controls.\", commentLeftX(col1), orangeY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(orangeNode, \"What is 2+2? Reply in one sentence.\", laneNodeX(col1, 0), orangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(orangeOut, \"\", laneNodeX(col1, LANE_OFFSET), orangeOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 2\n\t\tn(lab2a, \"Secondary model (same idea, different model).\", commentLeftX(col2), purpleY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(purpleNode, \"Summarize in 5 words: The quick brown fox jumps.\", laneNodeX(col2, 0), purpleY, cPurple, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(purpleOut, \"\", laneNodeX(col2, LANE_OFFSET), purpleOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(lab2b, \"Text: input text; passed to next node as-is (pass-through).\", commentRightX(col2), yellowY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(yellowNode, \"I'm input text. My text is passed to the next node (concatenated).\", laneNodeX(col2, 0), yellowY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(lab2c, \"Python: runs code. Use variable input for parent text.\", commentLeftX(col2), blueY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(blueNode, \"print('Python says:', (input or '')[:80] or '(no input)')\\n# input = text from parent\", laneNodeX(col2, LANE_OFFSET), blueY, cBlue, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 3\n\t\tn\n,\n\t];\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 47,
                "column": 1
              },
              "endPosition": {
                "line": 48,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 47,
            "isSignature": true
          },
          {
            "lineNumber": 206
          },
          {
            "lineNumber": 207
          },
          {
            "text": "\tconst nodes: CanvasData[\"nodes\"] = [",
            "lineNumber": 208
          },
          {
            "text": "\t\t// Groups first (render behind)",
            "lineNumber": 209
          },
          {
            "text": "\t\tgroupWelcome,",
            "lineNumber": 210
          },
          {
            "text": "\t\tgroupCol1,",
            "lineNumber": 211
          },
          {
            "text": "\t\tgroupCol2,",
            "lineNumber": 212
          },
          {
            "text": "\t\tgroupCol3,",
            "lineNumber": 213
          },
          {
            "text": "\t\tgroupCol4,",
            "lineNumber": 214
          },
          {
            "text": "\t\tgroupCol5,",
            "lineNumber": 215
          },
          {
            "text": "\t\tgroupCol6,",
            "lineNumber": 216
          },
          {
            "text": "\t\t// Welcome: plain text (no color = no role; not connected, does not add to prompt)",
            "lineNumber": 217
          },
          {
            "text": "\t\tn(welcome, \"Welcome to Zettel Thinking Board. Each column is a separate showcase. Nodes run top to bottom. Right-click a card → Run node or Run chain. Uncolored or unused-color cards are not connected to any node and do not add to the prompt.\", TUT_LEFT, welcomeY, \"\", TUT_WELCOME_W, 132),",
            "lineNumber": 218
          },
          {
            "lineNumber": 219
          },
          {
            "text": "\t\t// Column 1: label = plain text; nodes in lane have roles",
            "lineNumber": 220
          },
          {
            "text": "\t\tn(lab1, \"Primary model: sends prompt to Ollama. Set the model in Zettel Controls.\", commentLeftX(col1), orangeY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 221
          },
          {
            "text": "\t\tn(orangeNode, \"What is 2+2? Reply in one sentence.\", laneNodeX(col1, 0), orangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 222
          },
          {
            "text": "\t\tn(orangeOut, \"\", laneNodeX(col1, LANE_OFFSET), orangeOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 223
          },
          {
            "lineNumber": 224
          },
          {
            "text": "\t\t// Column 2",
            "lineNumber": 225
          },
          {
            "text": "\t\tn(lab2a, \"Secondary model (same idea, different model).\", commentLeftX(col2), purpleY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 226
          },
          {
            "text": "\t\tn(purpleNode, \"Summarize in 5 words: The quick brown fox jumps.\", laneNodeX(col2, 0), purpleY, cPurple, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 227
          },
          {
            "text": "\t\tn(purpleOut, \"\", laneNodeX(col2, LANE_OFFSET), purpleOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 228
          },
          {
            "text": "\t\tn(lab2b, \"Text: input text; passed to next node as-is (pass-through).\", commentRightX(col2), yellowY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 229
          },
          {
            "text": "\t\tn(yellowNode, \"I'm input text. My text is passed to the next node (concatenated).\", laneNodeX(col2, 0), yellowY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 230
          },
          {
            "text": "\t\tn(lab2c, \"Python: runs code. Use variable input for parent text.\", commentLeftX(col2), blueY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 231
          },
          {
            "text": "\t\tn(blueNode, \"print('Python says:', (input or '')[:80] or '(no input)')\\n# input = text from parent\", laneNodeX(col2, LANE_OFFSET), blueY, cBlue, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 232
          },
          {
            "text": "\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 233
          },
          {
            "lineNumber": 234
          },
          {
            "text": "\t\t// Column 3",
            "lineNumber": 235
          },
          {
            "text": "\t\tn",
            "lineNumber": 236
          },
          {
            "text": ",",
            "lineNumber": 249
          },
          {
            "text": "\t];",
            "lineNumber": 250
          },
          {
            "text": "}",
            "lineNumber": 263,
            "isSignature": true
          }
        ]
      },
      "score": 0.41127079725265503
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 103
          },
          "endPosition": {
            "line": 115,
            "column": 1
          }
        },
        "contents": "export function isFileNode(node: AllCanvasNodeData): node is CanvasFileData {\n\n}\n\n/** Get raw text content from a text node. */\nexport function getTextNodeContent(node: CanvasTextData): string {\n\treturn node.text ?? \"\";\n}\n\n/** Get file path from a file node (relative to vault). */\nexport function getFileNodePath(node: CanvasFileData): string {\n\treturn node.file ?? \"\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export function isFileNode(node: AllCanvasNodeData): node is CanvasFileData {",
            "lineNumber": 104,
            "isSignature": true
          },
          {
            "lineNumber": 105
          },
          {
            "text": "}",
            "lineNumber": 106,
            "isSignature": true
          },
          {
            "lineNumber": 107
          },
          {
            "text": "/** Get raw text content from a text node. */",
            "lineNumber": 108
          },
          {
            "text": "export function getTextNodeContent(node: CanvasTextData): string {",
            "lineNumber": 109,
            "isSignature": true
          },
          {
            "text": "\treturn node.text ?? \"\";",
            "lineNumber": 110
          },
          {
            "text": "}",
            "lineNumber": 111,
            "isSignature": true
          },
          {
            "lineNumber": 112
          },
          {
            "text": "/** Get file path from a file node (relative to vault). */",
            "lineNumber": 113
          },
          {
            "text": "export function getFileNodePath(node: CanvasFileData): string {",
            "lineNumber": 114,
            "isSignature": true
          },
          {
            "text": "\treturn node.file ?? \"\";",
            "lineNumber": 115
          },
          {
            "text": "}",
            "lineNumber": 116,
            "isSignature": true
          }
        ]
      },
      "score": 0.4037061035633087
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/nodes.ts",
        "range": {
          "startPosition": {
            "line": 34,
            "column": 1
          },
          "endPosition": {
            "line": 71,
            "column": 1
          }
        },
        "contents": "/** Get input content for a node: text node content or full file content. */\nexport async function getNodeContent(\n\tnode: AllCanvasNodeData,\n\tvault: Vault\n): Promise&lt;string&gt; {\n\tif (isTextNode(node)) return getTextNodeContent(node as CanvasTextData);\n\tif (isFileNode(node)) {\n\t\tconst path = getFileNodePath(node as CanvasFileData);\n\t\tif (!path) return \"\";\n\t\tconst file = vault.getFileByPath(path);\n\t\tif (file) {\n\t\t\ttry {\n\t\t\t\treturn await vault.cachedRead(file);\n\t\t\t} catch {\n\t\t\t\t//\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n\treturn \"\";\n}\n\n// Re-export for callers\nexport {\n\tEDGE_LABEL_OUTPUT,\n\tfindOutputNodeForSource\n;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get input content for a node: text node content or full file content. */",
            "lineNumber": 37
          },
          {
            "text": "export async function getNodeContent(",
            "lineNumber": 38,
            "isSignature": true
          },
          {
            "text": "\tnode: AllCanvasNodeData,",
            "lineNumber": 39,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault",
            "lineNumber": 40,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 41,
            "isSignature": true
          },
          {
            "text": "\tif (isTextNode(node)) return getTextNodeContent(node as CanvasTextData);",
            "lineNumber": 42
          },
          {
            "text": "\tif (isFileNode(node)) {",
            "lineNumber": 43
          },
          {
            "text": "\t\tconst path = getFileNodePath(node as CanvasFileData);",
            "lineNumber": 44
          },
          {
            "text": "\t\tif (!path) return \"\";",
            "lineNumber": 45
          },
          {
            "text": "\t\tconst file = vault.getFileByPath(path);",
            "lineNumber": 46
          },
          {
            "text": "\t\tif (file) {",
            "lineNumber": 47
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\treturn await vault.cachedRead(file);",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t} catch {",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t\t//",
            "lineNumber": 51
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 52
          },
          {
            "text": "\t\t}",
            "lineNumber": 53
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 54
          },
          {
            "text": "\t}",
            "lineNumber": 55
          },
          {
            "text": "\treturn \"\";",
            "lineNumber": 56
          },
          {
            "text": "}",
            "lineNumber": 57,
            "isSignature": true
          },
          {
            "lineNumber": 58
          },
          {
            "text": "// Re-export for callers",
            "lineNumber": 59
          },
          {
            "text": "export {",
            "lineNumber": 60
          },
          {
            "text": "\tEDGE_LABEL_OUTPUT,",
            "lineNumber": 61
          },
          {
            "text": "\tfindOutputNodeForSource",
            "lineNumber": 62
          },
          {
            "text": ";",
            "lineNumber": 72
          }
        ]
      },
      "score": 0.4019242525100708
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 122,
            "column": 1
          },
          "endPosition": {
            "line": 138,
            "column": 3
          }
        },
        "contents": "/** Create a label element using Obsidian's canvas-node-label class (same as file nodes). */\nfunction createLabelEl(text: string): HTMLElement {\n\tconst el = document.createElement(\"div\");\n\tel.setAttribute(\"class\", &#96;${LABEL_CLASS} canvas-node-label&#96;);\n\tel.setAttribute(LABEL_DATA_ATTR, \"1\");\n\tel.textContent = text;\n\treturn el;\n}\n\n/**\n * Sync floating role labels for the active canvas: for each node whose color maps to a role,\n * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first.\n * Uses the live canvas node map to find each node's DOM element (.canvas-node).\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Create a label element using Obsidian's canvas-node-label class (same as file nodes). */",
            "lineNumber": 125
          },
          {
            "text": "function createLabelEl(text: string): HTMLElement {",
            "lineNumber": 126,
            "isSignature": true
          },
          {
            "text": "\tconst el = document.createElement(\"div\");",
            "lineNumber": 127
          },
          {
            "text": "\tel.setAttribute(\"class\", &#96;${LABEL_CLASS} canvas-node-label&#96;);",
            "lineNumber": 128
          },
          {
            "text": "\tel.setAttribute(LABEL_DATA_ATTR, \"1\");",
            "lineNumber": 129
          },
          {
            "text": "\tel.textContent = text;",
            "lineNumber": 130
          },
          {
            "text": "\treturn el;",
            "lineNumber": 131
          },
          {
            "text": "}",
            "lineNumber": 132,
            "isSignature": true
          },
          {
            "lineNumber": 133
          },
          {
            "text": "/**",
            "lineNumber": 134
          },
          {
            "text": " * Sync floating role labels for the active canvas: for each node whose color maps to a role,",
            "lineNumber": 135
          },
          {
            "text": " * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first.",
            "lineNumber": 136
          },
          {
            "text": " * Uses the live canvas node map to find each node's DOM element (.canvas-node).",
            "lineNumber": 137
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 138
          },
          {
            "text": " */",
            "lineNumber": 139
          }
        ]
      },
      "score": 0.38718318939208984
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/views/ZettelControlsView.ts",
        "range": {
          "startPosition": {
            "line": 25
          },
          "endPosition": {
            "line": 214,
            "column": 1
          }
        },
        "contents": "export class ZettelControlsView extends ItemView {\nasync onOpen(): Promise&lt;void&gt; {\n\n\t\tconst guideDetails = el.createEl(\"details\", { cls: \"ztb-guide-details\" });\n\t\tguideDetails.createEl(\"summary\", { cls: \"ztb-guide-summary\", text: \"How to use the canvas\" });\n\t\tconst guideList = guideDetails.createEl(\"ul\", { cls: \"ztb-guide-list\" });\n\t\tconst tips = [\n\t\t\t\"Each color is a different way to work with text: one color might ask an AI a question, another might run a short Python snippet, and the green card is where the result shows up.\",\n\t\t\t\"Text (yellow) nodes are input pass-through: their content is sent to the next node. Uncolored or unused-color cards are not connected and do not add to any prompt.\",\n\t\t\t\"An arrow from one card to another sends its text as input. You can change how it's combined by clicking the arrow's label.\",\n\t\t\t\"Right-click a card and choose Run node to run just that card, or Run chain to run it and every card that feeds into it.\",\n\t\t\t\"The green card is where answers and results appear. It gets created or updated when you run an AI or Python card.\",\n\t\t\t\"You can plug text from one card into another by using {{var:name}} in the card text and giving the edge that variable name as its label.\",\n\t\t\t\"Use the command \\\"Create tutorial canvas\\\" for a full showcase: every node type, concat vs variable injection, Run buttons, and this sidebar.\",\n\t\t];\n\t\tfor (const tip of tips) {\n\t\t\tconst li = guideList.createEl(\"li\");\n\t\t\tli.setText(tip);\n\t\t}\n\t}\n\n\tasync onClose(): Promise&lt;void&gt; {\n\t\tthis.containerEl.removeClass(\"ztb-controls-view\");\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 26,
                "column": 1
              },
              "endPosition": {
                "line": 26,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 26,
                "column": 8
              },
              "endPosition": {
                "line": 27,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 43,
                "column": 2
              },
              "endPosition": {
                "line": 44,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export class ZettelControlsView extends ItemView {",
            "lineNumber": 26,
            "isSignature": true
          },
          {
            "text": "async onOpen(): Promise&lt;void&gt; {",
            "lineNumber": 43
          },
          {
            "lineNumber": 192
          },
          {
            "text": "\t\tconst guideDetails = el.createEl(\"details\", { cls: \"ztb-guide-details\" });",
            "lineNumber": 193
          },
          {
            "text": "\t\tguideDetails.createEl(\"summary\", { cls: \"ztb-guide-summary\", text: \"How to use the canvas\" });",
            "lineNumber": 194
          },
          {
            "text": "\t\tconst guideList = guideDetails.createEl(\"ul\", { cls: \"ztb-guide-list\" });",
            "lineNumber": 195
          },
          {
            "text": "\t\tconst tips = [",
            "lineNumber": 196
          },
          {
            "text": "\t\t\t\"Each color is a different way to work with text: one color might ask an AI a question, another might run a short Python snippet, and the green card is where the result shows up.\",",
            "lineNumber": 197
          },
          {
            "text": "\t\t\t\"Text (yellow) nodes are input pass-through: their content is sent to the next node. Uncolored or unused-color cards are not connected and do not add to any prompt.\",",
            "lineNumber": 198
          },
          {
            "text": "\t\t\t\"An arrow from one card to another sends its text as input. You can change how it's combined by clicking the arrow's label.\",",
            "lineNumber": 199
          },
          {
            "text": "\t\t\t\"Right-click a card and choose Run node to run just that card, or Run chain to run it and every card that feeds into it.\",",
            "lineNumber": 200
          },
          {
            "text": "\t\t\t\"The green card is where answers and results appear. It gets created or updated when you run an AI or Python card.\",",
            "lineNumber": 201
          },
          {
            "text": "\t\t\t\"You can plug text from one card into another by using {{var:name}} in the card text and giving the edge that variable name as its label.\",",
            "lineNumber": 202
          },
          {
            "text": "\t\t\t\"Use the command \\\"Create tutorial canvas\\\" for a full showcase: every node type, concat vs variable injection, Run buttons, and this sidebar.\",",
            "lineNumber": 203
          },
          {
            "text": "\t\t];",
            "lineNumber": 204
          },
          {
            "text": "\t\tfor (const tip of tips) {",
            "lineNumber": 205
          },
          {
            "text": "\t\t\tconst li = guideList.createEl(\"li\");",
            "lineNumber": 206
          },
          {
            "text": "\t\t\tli.setText(tip);",
            "lineNumber": 207
          },
          {
            "text": "\t\t}",
            "lineNumber": 208
          },
          {
            "text": "\t}",
            "lineNumber": 209
          },
          {
            "lineNumber": 210
          },
          {
            "text": "\tasync onClose(): Promise&lt;void&gt; {",
            "lineNumber": 211
          },
          {
            "text": "\t\tthis.containerEl.removeClass(\"ztb-controls-view\");",
            "lineNumber": 212
          },
          {
            "text": "\t}",
            "lineNumber": 214
          },
          {
            "text": "}",
            "lineNumber": 215,
            "isSignature": true
          }
        ]
      },
      "score": 0.3704359531402588
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 228
          },
          "endPosition": {
            "line": 329,
            "column": 1
          }
        },
        "contents": "export async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\n\tfor (const edge of data.edges) {\n\t\tif (isOutputEdge(edge)) continue;\n\t\tconst isRunning = runningNodeId != null &amp;&amp; edge.toNode === runningNodeId;\n\t\tconst mode = getEdgeMode(canvasKey, edge.id);\n\t\tconst state: EdgeDisplayState | null = isRunning\n\t\t\t? \"running\"\n\t\t\t: mode === \"inject\"\n\t\t\t\t? \"inject\"\n\t\t\t\t: mode === \"concatenate\"\n\t\t\t\t\t? \"concatenate\"\n\t\t\t\t\t: null;\n\t\tif (!state) continue;\n\t\tconst fromEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);\n\t\tconst toEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);\n\t\tif (!fromEl || !toEl) continue;\n\t\tconst fromCenter = getElCenter(fromEl);\n\t\tconst toCenter = getElCenter(toEl);\n\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;\n\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;\n\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);\n\t\tif (!pathEl) continue;\n\t\tconst group = pathEl.closest(\"g\");\n\t\tif (!group) continue;\n\t\tconst mid = getPathMidpointSvg(pathEl);\n\t\tconst labelGroup = document.createElementNS(SVG_NS, \"g\");\n\t\tlabelGroup.setAttribute(\"class\", EDGE_MODE_SVG_LABEL_CLASS);\n\t\tlabelGroup.setAttribute(EDGE_MODE_DATA_ATTR, edge.id);\n\t\tlabelGroup.setAttribute(EDGE_MODE_STATE_ATTR, state);\n\t\tlabelGroup.setAttribute(\"transform\", &#96;translate(${mid.x}, ${mid.y + Y_OFFSET_BELOW_PATH})&#96;);\n\t\tlabelGroup.setAttribute(\"style\", \"z-index: 100; isolation: isolate;\");\n\t\tconst textContent =\n\t\t\tstate === \"running\" ? \"…\" : state === \"inject\" ? \"(injected)\" : \"(concatenated)\";\n\t\tlet textX = 0;\n\t\tconst fontSize = state === \"running\" ? FONT_SIZE_RUNNING : FONT_SIZE;\n\t\tif (state === \"running\") {\n\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 229,
                "column": 1
              },
              "endPosition": {
                "line": 229,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 229,
                "column": 8
              },
              "endPosition": {
                "line": 236,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 235,
            "isSignature": true
          },
          {
            "lineNumber": 252
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 253
          },
          {
            "text": "\t\tif (isOutputEdge(edge)) continue;",
            "lineNumber": 254
          },
          {
            "text": "\t\tconst isRunning = runningNodeId != null &amp;&amp; edge.toNode === runningNodeId;",
            "lineNumber": 255
          },
          {
            "text": "\t\tconst mode = getEdgeMode(canvasKey, edge.id);",
            "lineNumber": 256
          },
          {
            "text": "\t\tconst state: EdgeDisplayState | null = isRunning",
            "lineNumber": 257
          },
          {
            "text": "\t\t\t? \"running\"",
            "lineNumber": 258
          },
          {
            "text": "\t\t\t: mode === \"inject\"",
            "lineNumber": 259
          },
          {
            "text": "\t\t\t\t? \"inject\"",
            "lineNumber": 260
          },
          {
            "text": "\t\t\t\t: mode === \"concatenate\"",
            "lineNumber": 261
          },
          {
            "text": "\t\t\t\t\t? \"concatenate\"",
            "lineNumber": 262
          },
          {
            "text": "\t\t\t\t\t: null;",
            "lineNumber": 263
          },
          {
            "text": "\t\tif (!state) continue;",
            "lineNumber": 264
          },
          {
            "text": "\t\tconst fromEl =",
            "lineNumber": 265
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||",
            "lineNumber": 266
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);",
            "lineNumber": 267
          },
          {
            "text": "\t\tconst toEl =",
            "lineNumber": 268
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||",
            "lineNumber": 269
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);",
            "lineNumber": 270
          },
          {
            "text": "\t\tif (!fromEl || !toEl) continue;",
            "lineNumber": 271
          },
          {
            "text": "\t\tconst fromCenter = getElCenter(fromEl);",
            "lineNumber": 272
          },
          {
            "text": "\t\tconst toCenter = getElCenter(toEl);",
            "lineNumber": 273
          },
          {
            "text": "\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;",
            "lineNumber": 274
          },
          {
            "text": "\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;",
            "lineNumber": 275
          },
          {
            "text": "\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);",
            "lineNumber": 276
          },
          {
            "text": "\t\tif (!pathEl) continue;",
            "lineNumber": 277
          },
          {
            "text": "\t\tconst group = pathEl.closest(\"g\");",
            "lineNumber": 278
          },
          {
            "text": "\t\tif (!group) continue;",
            "lineNumber": 279
          },
          {
            "text": "\t\tconst mid = getPathMidpointSvg(pathEl);",
            "lineNumber": 280
          },
          {
            "text": "\t\tconst labelGroup = document.createElementNS(SVG_NS, \"g\");",
            "lineNumber": 281
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"class\", EDGE_MODE_SVG_LABEL_CLASS);",
            "lineNumber": 282
          },
          {
            "text": "\t\tlabelGroup.setAttribute(EDGE_MODE_DATA_ATTR, edge.id);",
            "lineNumber": 283
          },
          {
            "text": "\t\tlabelGroup.setAttribute(EDGE_MODE_STATE_ATTR, state);",
            "lineNumber": 284
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"transform\", &#96;translate(${mid.x}, ${mid.y + Y_OFFSET_BELOW_PATH})&#96;);",
            "lineNumber": 285
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"style\", \"z-index: 100; isolation: isolate;\");",
            "lineNumber": 286
          },
          {
            "text": "\t\tconst textContent =",
            "lineNumber": 287
          },
          {
            "text": "\t\t\tstate === \"running\" ? \"…\" : state === \"inject\" ? \"(injected)\" : \"(concatenated)\";",
            "lineNumber": 288
          },
          {
            "text": "\t\tlet textX = 0;",
            "lineNumber": 289
          },
          {
            "text": "\t\tconst fontSize = state === \"running\" ? FONT_SIZE_RUNNING : FONT_SIZE;",
            "lineNumber": 290
          },
          {
            "text": "\t\tif (state === \"running\") {",
            "lineNumber": 291
          },
          {
            "text": "\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");",
            "lineNumber": 292
          },
          {
            "text": "}",
            "lineNumber": 330,
            "isSignature": true
          }
        ]
      },
      "score": 0.36070895195007324
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 278
          },
          "endPosition": {
            "line": 665,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\n\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js).\n\t\t\tconst addNodeMenuItems = (menu: Menu, node: unknown): void =&gt; {\n\t\t\t\tdebugNodeMenuFired = true;\n\t\t\t\tconst nodeId = resolveCanvasNodeId(node);\n\t\t\t\tif (!nodeId) return;\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Dismiss output\").setIcon(\"trash\").onClick(() =&gt; this.dismissOutput(nodeId))\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst registerCanvasNodeMenu = () =&gt; {\n\t\t\t\ttry {\n\t\t\t\t\tconst on = this.app.workspace.on.bind(this.app.workspace) as (\n\t\t\t\t\t\tname: string,\n\t\t\t\t\t\tcallback: (menu: Menu, node: unknown) =&gt; void\n\t\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;\n\t\t\t\t\t// Try documented-style event name first; some Obsidian builds use \"canvas:node-menu\".\n\t\t\t\t\tthis.registerEvent(on(\"canvas:node-menu\", addNodeMenuItems));\n\t\t\t\t\t// Fallback: try hyphenated name in case the app triggers a different event.\n\t\t\t\t\tthis.registerEvent(on(\"canvas-node-menu\", addNodeMenuItems));\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas node menu.\", e);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst timeoutId = window.setTimeout(registerCanvasNodeMenu, 0);\n\t\t\tthis.register(() =&gt; window.clearTimeout(timeoutId));\n\n\t\t\t// Canvas background context menu: use undocumented \"canvas:edge-menu\" (Obsidian broadcasts it;\n\t\t\t// when right-click is on empty area, edge is null). Same pattern as canvas:node-menu: addItem with setTitle, setIcon, onClick.\n\t\t\tconst addCanvasMenuItems = (menu: Menu): void =&gt; {\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())\n\t\t\t\t);\n\t\t\t\tmenu.addItem((item) =&gt;\n\t\t\t\t\titem.setTitle(\"Dismiss all output\").setIcon(\"trash\").onClick(() =&gt; this.dismissAllOutput())\n\t\t\t\t);\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace)\n;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 279,
                "column": 1
              },
              "endPosition": {
                "line": 279,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 279,
                "column": 16
              },
              "endPosition": {
                "line": 280,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 282,
                "column": 2
              },
              "endPosition": {
                "line": 283,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 279,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 282
          },
          {
            "lineNumber": 339
          },
          {
            "lineNumber": 340
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 341
          },
          {
            "text": "\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js).",
            "lineNumber": 342
          },
          {
            "text": "\t\t\tconst addNodeMenuItems = (menu: Menu, node: unknown): void =&gt; {",
            "lineNumber": 343
          },
          {
            "text": "\t\t\t\tdebugNodeMenuFired = true;",
            "lineNumber": 344
          },
          {
            "text": "\t\t\t\tconst nodeId = resolveCanvasNodeId(node);",
            "lineNumber": 345
          },
          {
            "text": "\t\t\t\tif (!nodeId) return;",
            "lineNumber": 346
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 347
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run node\").setIcon(\"play\").onClick(() =&gt; this.runNode(nodeId))",
            "lineNumber": 348
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 349
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 350
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))",
            "lineNumber": 351
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 352
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 353
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Dismiss output\").setIcon(\"trash\").onClick(() =&gt; this.dismissOutput(nodeId))",
            "lineNumber": 354
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 355
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 356
          },
          {
            "text": "\t\t\tconst registerCanvasNodeMenu = () =&gt; {",
            "lineNumber": 357
          },
          {
            "text": "\t\t\t\ttry {",
            "lineNumber": 358
          },
          {
            "text": "\t\t\t\t\tconst on = this.app.workspace.on.bind(this.app.workspace) as (",
            "lineNumber": 359
          },
          {
            "text": "\t\t\t\t\t\tname: string,",
            "lineNumber": 360
          },
          {
            "text": "\t\t\t\t\t\tcallback: (menu: Menu, node: unknown) =&gt; void",
            "lineNumber": 361
          },
          {
            "text": "\t\t\t\t\t) =&gt; ReturnType&lt;typeof this.app.workspace.on&gt;;",
            "lineNumber": 362
          },
          {
            "text": "\t\t\t\t\t// Try documented-style event name first; some Obsidian builds use \"canvas:node-menu\".",
            "lineNumber": 363
          },
          {
            "text": "\t\t\t\t\tthis.registerEvent(on(\"canvas:node-menu\", addNodeMenuItems));",
            "lineNumber": 364
          },
          {
            "text": "\t\t\t\t\t// Fallback: try hyphenated name in case the app triggers a different event.",
            "lineNumber": 365
          },
          {
            "text": "\t\t\t\t\tthis.registerEvent(on(\"canvas-node-menu\", addNodeMenuItems));",
            "lineNumber": 366
          },
          {
            "text": "\t\t\t\t} catch (e) {",
            "lineNumber": 367
          },
          {
            "text": "\t\t\t\t\tconsole.error(\"Zettel Thinking Board: could not register canvas node menu.\", e);",
            "lineNumber": 368
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 369
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 370
          },
          {
            "text": "\t\t\tconst timeoutId = window.setTimeout(registerCanvasNodeMenu, 0);",
            "lineNumber": 371
          },
          {
            "text": "\t\t\tthis.register(() =&gt; window.clearTimeout(timeoutId));",
            "lineNumber": 372
          },
          {
            "lineNumber": 373
          },
          {
            "text": "\t\t\t// Canvas background context menu: use undocumented \"canvas:edge-menu\" (Obsidian broadcasts it;",
            "lineNumber": 374
          },
          {
            "text": "\t\t\t// when right-click is on empty area, edge is null). Same pattern as canvas:node-menu: addItem with setTitle, setIcon, onClick.",
            "lineNumber": 375
          },
          {
            "text": "\t\t\tconst addCanvasMenuItems = (menu: Menu): void =&gt; {",
            "lineNumber": 376
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 377
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Run entire canvas\").setIcon(\"play\").onClick(() =&gt; this.runEntireCanvas())",
            "lineNumber": 378
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 379
          },
          {
            "text": "\t\t\t\tmenu.addItem((item) =&gt;",
            "lineNumber": 380
          },
          {
            "text": "\t\t\t\t\titem.setTitle(\"Dismiss all output\").setIcon(\"trash\").onClick(() =&gt; this.dismissAllOutput())",
            "lineNumber": 381
          },
          {
            "text": "\t\t\t\t);",
            "lineNumber": 382
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 383
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 384
          },
          {
            "text": "\t\t\t\tconst onWorkspace = this.app.workspace.on.bind(this.app.workspace)",
            "lineNumber": 385
          },
          {
            "text": ";",
            "lineNumber": 388
          },
          {
            "text": "\t}",
            "lineNumber": 498
          },
          {
            "text": "}",
            "lineNumber": 666,
            "isSignature": true
          }
        ]
      },
      "score": 0.3569808006286621
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 46
          },
          "endPosition": {
            "line": 262,
            "column": 1
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\nconst nodes: CanvasData[\"nodes\"] = [\n TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 3\n\t\tn(lab3, \"Concatenation: no edge label → parent output appended before your prompt (then \\\"---\\\", then this card).\", commentLeftX(col3), concatCommentY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),\n\t\tn(concatComment, \"I'm input text. My full text is added to the next node's prompt.\", laneNodeX(col3, 0), concatCommentY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(concatOrange, \"Reply in one word: what did the previous card say?\", laneNodeX(col3, LANE_OFFSET), concatOrangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(concatOut, \"\", laneNodeX(col3, 0), concatOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 4\n\t\tn(lab4, \"Variable injection: put a name on the edge and use {{var:name}} in the prompt; that parent is injected there.\", commentLeftX(col4), injectFirstY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),\n\t\tn(injectFirst, \"Say exactly: Hello world.\", laneNodeX(col4, 0), injectFirstY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(injectSecond, \"They said: {{var:reply}}. Confirm in 2 words.\", laneNodeX(col4, LANE_OFFSET), injectSecondY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(injectOut, \"\", laneNodeX(col4, 0), injectOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 5 &amp; 6: plain text labels only\n\t\tn(lab5, \"How to run: Right-click a node → Run node or Run chain. Right-click empty canvas → Run entire canvas or Dismiss all output. Title bar: ▶ Run entire canvas, 🗑 Dismiss all. Commands: Open Zettel Controls; Create tutorial canvas.\", commentLeftX(col5), y5, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 195),\n\t\tn(lab6, \"Sidebar: Open Zettel Controls. There: pick Ollama models and Temperature; restart Python kernel; env vars; Console (obsidian_log in Python cards).\", commentLeftX(col6), y6, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 145),\n\t];\n\n\tconst edges: CanvasData[\"edges\"] = [\n\t\te(\"e-orange-out\", orangeNode, orangeOut, EDGE_LABEL_OUTPUT)\n,\n\t];\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 47,
                "column": 1
              },
              "endPosition": {
                "line": 48,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 208,
                "column": 2
              },
              "endPosition": {
                "line": 208,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 208,
                "column": 8
              },
              "endPosition": {
                "line": 209,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 47,
            "isSignature": true
          },
          {
            "text": "const nodes: CanvasData[\"nodes\"] = [",
            "lineNumber": 208
          },
          {
            "text": " TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 232
          },
          {
            "text": "\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 233
          },
          {
            "lineNumber": 234
          },
          {
            "text": "\t\t// Column 3",
            "lineNumber": 235
          },
          {
            "text": "\t\tn(lab3, \"Concatenation: no edge label → parent output appended before your prompt (then \\\"---\\\", then this card).\", commentLeftX(col3), concatCommentY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),",
            "lineNumber": 236
          },
          {
            "text": "\t\tn(concatComment, \"I'm input text. My full text is added to the next node's prompt.\", laneNodeX(col3, 0), concatCommentY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 237
          },
          {
            "text": "\t\tn(concatOrange, \"Reply in one word: what did the previous card say?\", laneNodeX(col3, LANE_OFFSET), concatOrangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 238
          },
          {
            "text": "\t\tn(concatOut, \"\", laneNodeX(col3, 0), concatOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 239
          },
          {
            "lineNumber": 240
          },
          {
            "text": "\t\t// Column 4",
            "lineNumber": 241
          },
          {
            "text": "\t\tn(lab4, \"Variable injection: put a name on the edge and use {{var:name}} in the prompt; that parent is injected there.\", commentLeftX(col4), injectFirstY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),",
            "lineNumber": 242
          },
          {
            "text": "\t\tn(injectFirst, \"Say exactly: Hello world.\", laneNodeX(col4, 0), injectFirstY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 243
          },
          {
            "text": "\t\tn(injectSecond, \"They said: {{var:reply}}. Confirm in 2 words.\", laneNodeX(col4, LANE_OFFSET), injectSecondY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 244
          },
          {
            "text": "\t\tn(injectOut, \"\", laneNodeX(col4, 0), injectOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 245
          },
          {
            "lineNumber": 246
          },
          {
            "text": "\t\t// Column 5 &amp; 6: plain text labels only",
            "lineNumber": 247
          },
          {
            "text": "\t\tn(lab5, \"How to run: Right-click a node → Run node or Run chain. Right-click empty canvas → Run entire canvas or Dismiss all output. Title bar: ▶ Run entire canvas, 🗑 Dismiss all. Commands: Open Zettel Controls; Create tutorial canvas.\", commentLeftX(col5), y5, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 195),",
            "lineNumber": 248
          },
          {
            "text": "\t\tn(lab6, \"Sidebar: Open Zettel Controls. There: pick Ollama models and Temperature; restart Python kernel; env vars; Console (obsidian_log in Python cards).\", commentLeftX(col6), y6, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 145),",
            "lineNumber": 249
          },
          {
            "text": "\t];",
            "lineNumber": 250
          },
          {
            "lineNumber": 251
          },
          {
            "text": "\tconst edges: CanvasData[\"edges\"] = [",
            "lineNumber": 252
          },
          {
            "text": "\t\te(\"e-orange-out\", orangeNode, orangeOut, EDGE_LABEL_OUTPUT)",
            "lineNumber": 253
          },
          {
            "text": ",",
            "lineNumber": 259
          },
          {
            "text": "\t];",
            "lineNumber": 260
          },
          {
            "text": "}",
            "lineNumber": 263,
            "isSignature": true
          }
        ]
      },
      "score": 0.34919360280036926
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/canvasApi.ts",
        "range": {
          "startPosition": {
            "column": 86
          },
          "endPosition": {
            "line": 15,
            "column": 1
          }
        },
        "contents": "export interface LiveCanvas {\n\tcreateTextNode(options: {\n\t\ttext: string;\n\t\tpos: { x: number; y: number };\n\t\tsize: { width: number; height: number };\n\t\tsave?: boolean;\n\t\tfocus?: boolean;\n\t}): { id: string; x: number; y: number; width: number; height: number; moveTo: (pos: { x: number; y: number }) =&gt; void; resize: (size: { width: number; height: number }) =&gt; void };\n\taddNode(node: unknown): void;\n\trequestSave?: () =&gt; void;\n\tremoveNode?(node: unknown): void;\n\tnodes?: Map&lt;string, unknown&gt; | Iterable&lt;unknown&gt;;\n\t/** If present, used to refresh canvas after edge label updates (Obsidian canvas view). */\n\tsetData?(data: unknown): void;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export interface LiveCanvas {",
            "lineNumber": 2,
            "isSignature": true
          },
          {
            "text": "\tcreateTextNode(options: {",
            "lineNumber": 3
          },
          {
            "text": "\t\ttext: string;",
            "lineNumber": 4
          },
          {
            "text": "\t\tpos: { x: number; y: number };",
            "lineNumber": 5
          },
          {
            "text": "\t\tsize: { width: number; height: number };",
            "lineNumber": 6
          },
          {
            "text": "\t\tsave?: boolean;",
            "lineNumber": 7
          },
          {
            "text": "\t\tfocus?: boolean;",
            "lineNumber": 8
          },
          {
            "text": "\t}): { id: string; x: number; y: number; width: number; height: number; moveTo: (pos: { x: number; y: number }) =&gt; void; resize: (size: { width: number; height: number }) =&gt; void };",
            "lineNumber": 9
          },
          {
            "text": "\taddNode(node: unknown): void;",
            "lineNumber": 10
          },
          {
            "text": "\trequestSave?: () =&gt; void;",
            "lineNumber": 11
          },
          {
            "text": "\tremoveNode?(node: unknown): void;",
            "lineNumber": 12
          },
          {
            "text": "\tnodes?: Map&lt;string, unknown&gt; | Iterable&lt;unknown&gt;;",
            "lineNumber": 13
          },
          {
            "text": "\t/** If present, used to refresh canvas after edge label updates (Obsidian canvas view). */",
            "lineNumber": 14
          },
          {
            "text": "\tsetData?(data: unknown): void;",
            "lineNumber": 15,
            "isSignature": true
          },
          {
            "text": "}",
            "lineNumber": 16,
            "isSignature": true
          }
        ]
      },
      "score": 0.3455078601837158
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 222,
            "column": 1
          },
          "endPosition": {
            "line": 307,
            "column": 1
          }
        },
        "contents": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */\nasync function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return \"\";\n\tconst role = getNodeRole(node, settings);\n\tif (!role || role === \"yellow\" || role === \"green\") {\n\t\t// Yellow = text (input pass-through): use node content as result\n\t\tif (role === \"yellow\") {\n\t\t\tconst content = await getNodeContent(node, app.vault);\n\t\t\tsetNodeResult(canvasKey, nodeId, content);\n\t\t\treturn content;\n\t\t}\n\t\treturn \"\";\n\t}\n\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\tconst nodeInput = await getNodeContent(node, app.vault);\n\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(\n\t\tcanvasKey,\n\t\tnodeInput,\n\t\tincoming\n\t);\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n\t\tconst temperature = settings.ollamaOrangeTemperature ?? DEFAULT_SETTINGS.ollamaOrangeTemperature;\n\t\tconst result = await ollamaGenerate({\n\t\t\tmodel,\n\t\t\tprompt: fullPrompt,\n\t\t\tstream: false,\n\t\t\toptions: { temperature },\n\t\t});\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"purple\") {\n\t\tconst model = settings.ollamaPurpleModel || \"llama2\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 225
          },
          {
            "text": "async function runSingleNode(",
            "lineNumber": 226,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 227,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 228,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 235
          },
          {
            "text": "\tif (!node) return \"\";",
            "lineNumber": 236
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 237
          },
          {
            "text": "\tif (!role || role === \"yellow\" || role === \"green\") {",
            "lineNumber": 238
          },
          {
            "text": "\t\t// Yellow = text (input pass-through): use node content as result",
            "lineNumber": 239
          },
          {
            "text": "\t\tif (role === \"yellow\") {",
            "lineNumber": 240
          },
          {
            "text": "\t\t\tconst content = await getNodeContent(node, app.vault);",
            "lineNumber": 241
          },
          {
            "text": "\t\t\tsetNodeResult(canvasKey, nodeId, content);",
            "lineNumber": 242
          },
          {
            "text": "\t\t\treturn content;",
            "lineNumber": 243
          },
          {
            "text": "\t\t}",
            "lineNumber": 244
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 245
          },
          {
            "text": "\t}",
            "lineNumber": 246
          },
          {
            "text": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 247
          },
          {
            "text": "\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 248
          },
          {
            "text": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(",
            "lineNumber": 249
          },
          {
            "text": "\t\tcanvasKey,",
            "lineNumber": 250
          },
          {
            "text": "\t\tnodeInput,",
            "lineNumber": 251
          },
          {
            "text": "\t\tincoming",
            "lineNumber": 252
          },
          {
            "text": "\t);",
            "lineNumber": 253
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 254
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 255
          },
          {
            "lineNumber": 256
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 257
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 258
          },
          {
            "text": "\t\tconst temperature = settings.ollamaOrangeTemperature ?? DEFAULT_SETTINGS.ollamaOrangeTemperature;",
            "lineNumber": 259
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({",
            "lineNumber": 260
          },
          {
            "text": "\t\t\tmodel,",
            "lineNumber": 261
          },
          {
            "text": "\t\t\tprompt: fullPrompt,",
            "lineNumber": 262
          },
          {
            "text": "\t\t\tstream: false,",
            "lineNumber": 263
          },
          {
            "text": "\t\t\toptions: { temperature },",
            "lineNumber": 264
          },
          {
            "text": "\t\t});",
            "lineNumber": 265
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 266
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 267
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 268
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 269
          },
          {
            "text": "\t}",
            "lineNumber": 270
          },
          {
            "text": "\tif (role === \"purple\") {",
            "lineNumber": 271
          },
          {
            "text": "\t\tconst model = settings.ollamaPurpleModel || \"llama2\";",
            "lineNumber": 272
          },
          {
            "text": "}",
            "lineNumber": 308,
            "isSignature": true
          }
        ]
      },
      "score": 0.33262544870376587
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 220,
            "column": 1
          },
          "endPosition": {
            "line": 329,
            "column": 1
          }
        },
        "contents": "/**\n * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,\n * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG\n * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.edges) {\n\t\tclearCanvasEdgeModeLabels(containerEl);\n\t\treturn;\n\t}\n\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).\n\tclearCanvasEdgeModeLabels(containerEl);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tconst runningNodeId = getRunningNodeId(canvasKey);\n\tconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\tconst Y_OFFSET_BELOW_PATH = 12;\n\tconst FONT_SIZE = 11;\n\tconst FONT_SIZE_RUNNING = 20;\n\tconst DOT_R = 2.5;\n\tconst DOT_R_RUNNING = 5;\n\tconst DOT_TEXT_GAP = 6;\n\tfor (const edge of data.edges) {\n\t\tif (isOutputEdge(edge)) continue;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/**",
            "lineNumber": 223
          },
          {
            "text": " * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,",
            "lineNumber": 224
          },
          {
            "text": " * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG",
            "lineNumber": 225
          },
          {
            "text": " * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.",
            "lineNumber": 226
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 227
          },
          {
            "text": " */",
            "lineNumber": 228
          },
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 235,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 236
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 237
          },
          {
            "text": "\tif (!data?.edges) {",
            "lineNumber": 238
          },
          {
            "text": "\t\tclearCanvasEdgeModeLabels(containerEl);",
            "lineNumber": 239
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 240
          },
          {
            "text": "\t}",
            "lineNumber": 241
          },
          {
            "text": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).",
            "lineNumber": 242
          },
          {
            "text": "\tclearCanvasEdgeModeLabels(containerEl);",
            "lineNumber": 243
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 244
          },
          {
            "text": "\tconst runningNodeId = getRunningNodeId(canvasKey);",
            "lineNumber": 245
          },
          {
            "text": "\tconst SVG_NS = \"http://www.w3.org/2000/svg\";",
            "lineNumber": 246
          },
          {
            "text": "\tconst Y_OFFSET_BELOW_PATH = 12;",
            "lineNumber": 247
          },
          {
            "text": "\tconst FONT_SIZE = 11;",
            "lineNumber": 248
          },
          {
            "text": "\tconst FONT_SIZE_RUNNING = 20;",
            "lineNumber": 249
          },
          {
            "text": "\tconst DOT_R = 2.5;",
            "lineNumber": 250
          },
          {
            "text": "\tconst DOT_R_RUNNING = 5;",
            "lineNumber": 251
          },
          {
            "text": "\tconst DOT_TEXT_GAP = 6;",
            "lineNumber": 252
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 253
          },
          {
            "text": "\t\tif (isOutputEdge(edge)) continue;",
            "lineNumber": 254
          },
          {
            "text": "}",
            "lineNumber": 330,
            "isSignature": true
          }
        ]
      },
      "score": 0.3308788537979126
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 43,
            "column": 1
          },
          "endPosition": {
            "line": 262,
            "column": 1
          }
        },
        "contents": "/** Build tutorial canvas: columns with comment margins, node lane center, edges, groups. */\nfunction getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\tconst cOrange = tutorialColor(settings, \"colorOrange\");\n\tconst cPurple = tutorialColor(settings, \"colorPurple\");\n\tconst cBlue = tutorialColor(settings, \"colorBlue\");\n\tconst cYellow = tutorialColor(settings, \"colorYellow\");\n\tconst cGreen = tutorialColor(settings, \"colorGreen\");\n\n\t/** Plain text node (no role): use for labels/instructions so they are not treated as comment nodes. */\n\tconst n = (id: string, text: string, x: number, y: number, color: string, w: number, h: number) =&gt;\n\t\t({ id, type: \"text\" as const, text, x, y, width: w, height: h, color });\n\tconst e = (id: string, from: string, to: string, label?: string) =&gt; ({\n\t\tid,\n\t\tfromNode: from,\n\t\ttoNode: to,\n\t\tfromSide: \"bottom\" as const,\n\t\ttoSide: \"top\" as const,\n\t\tlabel: label ?? \"\",\n\t});\n\t/** Group node to visually separate a workflow block. */\n\tconst g = (id: string, x: number, y: number, w: number, h: number, label: string) =&gt;\n\t\t({ id, type: \"group\" as const, x, y, width: w, height: h, label });\n\n\t/** Column 1..6: x of left comment margin (column 1 starts right after welcome). */\n\tconst colLeft = (index: number) =&gt;\n\t\tTUT_LEFT + TUT_WELCOME_W + TUT_COL_GAP + (index - 1) * (TUT_COL_TOTAL_W + TUT_COL_GAP);\n\tconst commentLeftX = (colIndex: number) =&gt; colLeft(colIndex);\n\t/** Node lane: center x; offsetPx shifts right so alternating nodes make arrows more visible. */\n\tconst laneNodeX = (colIndex: number, offsetPx: number = 0) =&gt;\n\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + offsetPx;\n\tconst commentRightX = (colIndex: number) =&gt;\n\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP;\n\tconst LANE_OFFSET = 36;\n\n\t// —— Welcome: alone in first block, no overlap with column 1 ——\n\tconst welcome = \"welcome\";\n\tconst welcomeY = TUT_TOP;\n\n\t// —— Column 1: Primary (comment left, node → output in lane) ——\n\tconst col1 = 1;\n\tconst lab1 = \"lab-primary\";\n\tconst orangeNode = \"orange-example\";\n\tconst orangeOut = \"orange-out\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build tutorial canvas: columns with comment margins, node lane center, edges, groups. */",
            "lineNumber": 46
          },
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 47,
            "isSignature": true
          },
          {
            "text": "\tconst cOrange = tutorialColor(settings, \"colorOrange\");",
            "lineNumber": 48
          },
          {
            "text": "\tconst cPurple = tutorialColor(settings, \"colorPurple\");",
            "lineNumber": 49
          },
          {
            "text": "\tconst cBlue = tutorialColor(settings, \"colorBlue\");",
            "lineNumber": 50
          },
          {
            "text": "\tconst cYellow = tutorialColor(settings, \"colorYellow\");",
            "lineNumber": 51
          },
          {
            "text": "\tconst cGreen = tutorialColor(settings, \"colorGreen\");",
            "lineNumber": 52
          },
          {
            "lineNumber": 53
          },
          {
            "text": "\t/** Plain text node (no role): use for labels/instructions so they are not treated as comment nodes. */",
            "lineNumber": 54
          },
          {
            "text": "\tconst n = (id: string, text: string, x: number, y: number, color: string, w: number, h: number) =&gt;",
            "lineNumber": 55
          },
          {
            "text": "\t\t({ id, type: \"text\" as const, text, x, y, width: w, height: h, color });",
            "lineNumber": 56
          },
          {
            "text": "\tconst e = (id: string, from: string, to: string, label?: string) =&gt; ({",
            "lineNumber": 57
          },
          {
            "text": "\t\tid,",
            "lineNumber": 58
          },
          {
            "text": "\t\tfromNode: from,",
            "lineNumber": 59
          },
          {
            "text": "\t\ttoNode: to,",
            "lineNumber": 60
          },
          {
            "text": "\t\tfromSide: \"bottom\" as const,",
            "lineNumber": 61
          },
          {
            "text": "\t\ttoSide: \"top\" as const,",
            "lineNumber": 62
          },
          {
            "text": "\t\tlabel: label ?? \"\",",
            "lineNumber": 63
          },
          {
            "text": "\t});",
            "lineNumber": 64
          },
          {
            "text": "\t/** Group node to visually separate a workflow block. */",
            "lineNumber": 65
          },
          {
            "text": "\tconst g = (id: string, x: number, y: number, w: number, h: number, label: string) =&gt;",
            "lineNumber": 66
          },
          {
            "text": "\t\t({ id, type: \"group\" as const, x, y, width: w, height: h, label });",
            "lineNumber": 67
          },
          {
            "lineNumber": 68
          },
          {
            "text": "\t/** Column 1..6: x of left comment margin (column 1 starts right after welcome). */",
            "lineNumber": 69
          },
          {
            "text": "\tconst colLeft = (index: number) =&gt;",
            "lineNumber": 70
          },
          {
            "text": "\t\tTUT_LEFT + TUT_WELCOME_W + TUT_COL_GAP + (index - 1) * (TUT_COL_TOTAL_W + TUT_COL_GAP);",
            "lineNumber": 71
          },
          {
            "text": "\tconst commentLeftX = (colIndex: number) =&gt; colLeft(colIndex);",
            "lineNumber": 72
          },
          {
            "text": "\t/** Node lane: center x; offsetPx shifts right so alternating nodes make arrows more visible. */",
            "lineNumber": 73
          },
          {
            "text": "\tconst laneNodeX = (colIndex: number, offsetPx: number = 0) =&gt;",
            "lineNumber": 74
          },
          {
            "text": "\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + offsetPx;",
            "lineNumber": 75
          },
          {
            "text": "\tconst commentRightX = (colIndex: number) =&gt;",
            "lineNumber": 76
          },
          {
            "text": "\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP;",
            "lineNumber": 77
          },
          {
            "text": "\tconst LANE_OFFSET = 36;",
            "lineNumber": 78
          },
          {
            "lineNumber": 79
          },
          {
            "text": "\t// —— Welcome: alone in first block, no overlap with column 1 ——",
            "lineNumber": 80
          },
          {
            "text": "\tconst welcome = \"welcome\";",
            "lineNumber": 81
          },
          {
            "text": "\tconst welcomeY = TUT_TOP;",
            "lineNumber": 82
          },
          {
            "lineNumber": 83
          },
          {
            "text": "\t// —— Column 1: Primary (comment left, node → output in lane) ——",
            "lineNumber": 84
          },
          {
            "text": "\tconst col1 = 1;",
            "lineNumber": 85
          },
          {
            "text": "\tconst lab1 = \"lab-primary\";",
            "lineNumber": 86
          },
          {
            "text": "\tconst orangeNode = \"orange-example\";",
            "lineNumber": 87
          },
          {
            "text": "\tconst orangeOut = \"orange-out\";",
            "lineNumber": 88
          },
          {
            "text": "}",
            "lineNumber": 263,
            "isSignature": true
          }
        ]
      },
      "score": 0.32784026861190796
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/settings.ts",
        "range": {
          "startPosition": {
            "line": 362
          },
          "endPosition": {
            "line": 454,
            "column": 1
          }
        },
        "contents": "export class ZettelSettingTab extends PluginSettingTab {\ndisplay(): void {\nasync () =&gt; {\n this.plugin);\n\t\t})();\n\n\t\tnew Setting(executionSection)\n\t\t\t.setName(\"Python path\")\n\t\t\t.setDesc(\"Path to Python executable for Python nodes (e.g. python3 or /usr/bin/python3)\")\n\t\t\t.addText((text) =&gt; text\n\t\t\t\t.setPlaceholder(\"python3\")\n\t\t\t\t.setValue(s.pythonPath)\n\t\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t\ts.pythonPath = value || \"python3\";\n\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t}));\n\n\t\t// Display: colors for non-model nodes and label visibility (model colors live inside each model block)\n\t\tconst displaySection = containerEl.createDiv({ cls: \"ztb-settings-section\" });\n\t\tdisplaySection.createEl(\"h4\", { text: \"Display\", cls: \"ztb-section-title\" });\n\t\tconst displayHint = displaySection.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });\n\t\tdisplayHint.setText(\"Each node type should have a unique color. Uncolored or unused-color nodes are not part of the execution graph and do not add to any prompt.\");\n\t\taddColorSetting(\n\t\t\tdisplaySection,\n\t\t\tthis.plugin,\n\t\t\t\"blue\",\n\t\t\t\"Python node\",\n\t\t\t\"Color for the Python node on the canvas\"\n\t\t);\n\t\taddColorSetting(\n\t\t\tdisplaySection,\n\t\t\tthis.plugin,\n\t\t\t\"yellow\",\n\t\t\t\"Text node\",\n\t\t\t\"Color for the text (input) node: pass-through input text, no AI. Uncolored or unused-color nodes are not connected and do not add to any prompt.\"\n\t\t);\n\t\taddColorSetting(\n\t\t\tdisplaySection,\n\t\t\tthis.plugin,\n\t\t\t\"green\",\n\t\t\t\"Output node\",\n\t\t\t\"Color for auto-generated output nodes on the canvas\"\n\t\t);\n\n\t\tnew Setting(displaySection)\n\t\t\t.setName(\"Show role labels on canvas\")\n\t\t\t.setDesc(\"Show a floating label above each node (e.g. Text, Python) based on its color\")\n\t\t\t.addToggle((toggle) =&gt; toggle\n\t\t\t\t.setValue(s.showNodeRoleLabels)\n\t\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t\tthis.plugin.settings.showNodeRoleLabels = value;\n\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t}));\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 363,
                "column": 1
              },
              "endPosition": {
                "line": 363,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 363,
                "column": 8
              },
              "endPosition": {
                "line": 364,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 371,
                "column": 2
              },
              "endPosition": {
                "line": 372,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export class ZettelSettingTab extends PluginSettingTab {",
            "lineNumber": 363,
            "isSignature": true
          },
          {
            "text": "display(): void {",
            "lineNumber": 371
          },
          {
            "text": "async () =&gt; {",
            "lineNumber": 394
          },
          {
            "text": " this.plugin);",
            "lineNumber": 404
          },
          {
            "text": "\t\t})();",
            "lineNumber": 405
          },
          {
            "lineNumber": 406
          },
          {
            "text": "\t\tnew Setting(executionSection)",
            "lineNumber": 407
          },
          {
            "text": "\t\t\t.setName(\"Python path\")",
            "lineNumber": 408
          },
          {
            "text": "\t\t\t.setDesc(\"Path to Python executable for Python nodes (e.g. python3 or /usr/bin/python3)\")",
            "lineNumber": 409
          },
          {
            "text": "\t\t\t.addText((text) =&gt; text",
            "lineNumber": 410
          },
          {
            "text": "\t\t\t\t.setPlaceholder(\"python3\")",
            "lineNumber": 411
          },
          {
            "text": "\t\t\t\t.setValue(s.pythonPath)",
            "lineNumber": 412
          },
          {
            "text": "\t\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 413
          },
          {
            "text": "\t\t\t\t\ts.pythonPath = value || \"python3\";",
            "lineNumber": 414
          },
          {
            "text": "\t\t\t\t\tawait this.plugin.saveSettings();",
            "lineNumber": 415
          },
          {
            "text": "\t\t\t\t}));",
            "lineNumber": 416
          },
          {
            "lineNumber": 417
          },
          {
            "text": "\t\t// Display: colors for non-model nodes and label visibility (model colors live inside each model block)",
            "lineNumber": 418
          },
          {
            "text": "\t\tconst displaySection = containerEl.createDiv({ cls: \"ztb-settings-section\" });",
            "lineNumber": 419
          },
          {
            "text": "\t\tdisplaySection.createEl(\"h4\", { text: \"Display\", cls: \"ztb-section-title\" });",
            "lineNumber": 420
          },
          {
            "text": "\t\tconst displayHint = displaySection.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });",
            "lineNumber": 421
          },
          {
            "text": "\t\tdisplayHint.setText(\"Each node type should have a unique color. Uncolored or unused-color nodes are not part of the execution graph and do not add to any prompt.\");",
            "lineNumber": 422
          },
          {
            "text": "\t\taddColorSetting(",
            "lineNumber": 423
          },
          {
            "text": "\t\t\tdisplaySection,",
            "lineNumber": 424
          },
          {
            "text": "\t\t\tthis.plugin,",
            "lineNumber": 425
          },
          {
            "text": "\t\t\t\"blue\",",
            "lineNumber": 426
          },
          {
            "text": "\t\t\t\"Python node\",",
            "lineNumber": 427
          },
          {
            "text": "\t\t\t\"Color for the Python node on the canvas\"",
            "lineNumber": 428
          },
          {
            "text": "\t\t);",
            "lineNumber": 429
          },
          {
            "text": "\t\taddColorSetting(",
            "lineNumber": 430
          },
          {
            "text": "\t\t\tdisplaySection,",
            "lineNumber": 431
          },
          {
            "text": "\t\t\tthis.plugin,",
            "lineNumber": 432
          },
          {
            "text": "\t\t\t\"yellow\",",
            "lineNumber": 433
          },
          {
            "text": "\t\t\t\"Text node\",",
            "lineNumber": 434
          },
          {
            "text": "\t\t\t\"Color for the text (input) node: pass-through input text, no AI. Uncolored or unused-color nodes are not connected and do not add to any prompt.\"",
            "lineNumber": 435
          },
          {
            "text": "\t\t);",
            "lineNumber": 436
          },
          {
            "text": "\t\taddColorSetting(",
            "lineNumber": 437
          },
          {
            "text": "\t\t\tdisplaySection,",
            "lineNumber": 438
          },
          {
            "text": "\t\t\tthis.plugin,",
            "lineNumber": 439
          },
          {
            "text": "\t\t\t\"green\",",
            "lineNumber": 440
          },
          {
            "text": "\t\t\t\"Output node\",",
            "lineNumber": 441
          },
          {
            "text": "\t\t\t\"Color for auto-generated output nodes on the canvas\"",
            "lineNumber": 442
          },
          {
            "text": "\t\t);",
            "lineNumber": 443
          },
          {
            "lineNumber": 444
          },
          {
            "text": "\t\tnew Setting(displaySection)",
            "lineNumber": 445
          },
          {
            "text": "\t\t\t.setName(\"Show role labels on canvas\")",
            "lineNumber": 446
          },
          {
            "text": "\t\t\t.setDesc(\"Show a floating label above each node (e.g. Text, Python) based on its color\")",
            "lineNumber": 447
          },
          {
            "text": "\t\t\t.addToggle((toggle) =&gt; toggle",
            "lineNumber": 448
          },
          {
            "text": "\t\t\t\t.setValue(s.showNodeRoleLabels)",
            "lineNumber": 449
          },
          {
            "text": "\t\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 450
          },
          {
            "text": "\t\t\t\t\tthis.plugin.settings.showNodeRoleLabels = value;",
            "lineNumber": 451
          },
          {
            "text": "\t\t\t\t\tawait this.plugin.saveSettings();",
            "lineNumber": 452
          },
          {
            "text": "\t\t\t\t}));",
            "lineNumber": 453
          },
          {
            "text": "\t}",
            "lineNumber": 454
          },
          {
            "text": "}",
            "lineNumber": 455,
            "isSignature": true
          }
        ]
      },
      "score": 0.3268534541130066
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 15,
            "column": 61
          },
          "endPosition": {
            "line": 51,
            "column": 1
          }
        },
        "contents": "/** Try to get a canvas node's root DOM element from the live canvas (Obsidian uses .canvas-node, no data-id). */\nfunction getNodeElFromCanvas(canvas: LiveCanvas, nodeId: string): HTMLElement | null {\n\tconst nodes = canvas.nodes;\n\tif (!nodes) return null;\n\tlet view: {\n\t\tid?: string;\n\t\tnodeEl?: HTMLElement;\n\t\tel?: HTMLElement;\n\t\twrapperEl?: HTMLElement;\n\t\tcontainerEl?: HTMLElement;\n\t} | undefined;\n\tif (nodes instanceof Map) {\n\t\tview = nodes.get(nodeId) as typeof view;\n\t} else {\n\t\tfor (const n of nodes as Iterable&lt;typeof view&gt;) {\n\t\t\tif (n?.id === nodeId) {\n\t\t\t\tview = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!view) return null;\n\t// Obsidian canvas node view exposes the .canvas-node root via one of these\n\tif (view.nodeEl instanceof HTMLElement) return view.nodeEl;\n\tif (view.el instanceof HTMLElement) return view.el;\n\tif (view.wrapperEl instanceof HTMLElement) return view.wrapperEl;\n\tif (view.containerEl instanceof HTMLElement) return view.containerEl;\n\tif (view instanceof HTMLElement) return view;\n\treturn null;\n}\n\n/** Fallback: find node by data-id if present (some builds may use it). */\nfunction findNodeElementByDataId(containerEl: HTMLElement, nodeId: string): HTMLElement | null {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Try to get a canvas node's root DOM element from the live canvas (Obsidian uses .canvas-node, no data-id). */",
            "lineNumber": 17
          },
          {
            "text": "function getNodeElFromCanvas(canvas: LiveCanvas, nodeId: string): HTMLElement | null {",
            "lineNumber": 18,
            "isSignature": true
          },
          {
            "text": "\tconst nodes = canvas.nodes;",
            "lineNumber": 19
          },
          {
            "text": "\tif (!nodes) return null;",
            "lineNumber": 20
          },
          {
            "text": "\tlet view: {",
            "lineNumber": 21
          },
          {
            "text": "\t\tid?: string;",
            "lineNumber": 22
          },
          {
            "text": "\t\tnodeEl?: HTMLElement;",
            "lineNumber": 23
          },
          {
            "text": "\t\tel?: HTMLElement;",
            "lineNumber": 24
          },
          {
            "text": "\t\twrapperEl?: HTMLElement;",
            "lineNumber": 25
          },
          {
            "text": "\t\tcontainerEl?: HTMLElement;",
            "lineNumber": 26
          },
          {
            "text": "\t} | undefined;",
            "lineNumber": 27
          },
          {
            "text": "\tif (nodes instanceof Map) {",
            "lineNumber": 28
          },
          {
            "text": "\t\tview = nodes.get(nodeId) as typeof view;",
            "lineNumber": 29
          },
          {
            "text": "\t} else {",
            "lineNumber": 30
          },
          {
            "text": "\t\tfor (const n of nodes as Iterable&lt;typeof view&gt;) {",
            "lineNumber": 31
          },
          {
            "text": "\t\t\tif (n?.id === nodeId) {",
            "lineNumber": 32
          },
          {
            "text": "\t\t\t\tview = n;",
            "lineNumber": 33
          },
          {
            "text": "\t\t\t\tbreak;",
            "lineNumber": 34
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 35
          },
          {
            "text": "\t\t}",
            "lineNumber": 36
          },
          {
            "text": "\t}",
            "lineNumber": 37
          },
          {
            "text": "\tif (!view) return null;",
            "lineNumber": 38
          },
          {
            "text": "\t// Obsidian canvas node view exposes the .canvas-node root via one of these",
            "lineNumber": 39
          },
          {
            "text": "\tif (view.nodeEl instanceof HTMLElement) return view.nodeEl;",
            "lineNumber": 40
          },
          {
            "text": "\tif (view.el instanceof HTMLElement) return view.el;",
            "lineNumber": 41
          },
          {
            "text": "\tif (view.wrapperEl instanceof HTMLElement) return view.wrapperEl;",
            "lineNumber": 42
          },
          {
            "text": "\tif (view.containerEl instanceof HTMLElement) return view.containerEl;",
            "lineNumber": 43
          },
          {
            "text": "\tif (view instanceof HTMLElement) return view;",
            "lineNumber": 44
          },
          {
            "text": "\treturn null;",
            "lineNumber": 45
          },
          {
            "text": "}",
            "lineNumber": 46,
            "isSignature": true
          },
          {
            "lineNumber": 47
          },
          {
            "text": "/** Fallback: find node by data-id if present (some builds may use it). */",
            "lineNumber": 48
          },
          {
            "text": "function findNodeElementByDataId(containerEl: HTMLElement, nodeId: string): HTMLElement | null {",
            "lineNumber": 49,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 50
          },
          {
            "text": "}",
            "lineNumber": 52,
            "isSignature": true
          }
        ]
      },
      "score": 0.3247913122177124
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 95,
            "column": 1
          },
          "endPosition": {
            "line": 105,
            "column": 1
          }
        },
        "contents": "/** Check if node is text type. */\nexport function isTextNode(node: AllCanvasNodeData): node is CanvasTextData {\n\treturn (node as CanvasTextData).type === \"text\";\n}\n\n/** Check if node is file type. */\nexport function isFileNode(node: AllCanvasNodeData): node is CanvasFileData {\n\treturn (node as CanvasFileData).type === \"file\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Check if node is text type. */",
            "lineNumber": 98
          },
          {
            "text": "export function isTextNode(node: AllCanvasNodeData): node is CanvasTextData {",
            "lineNumber": 99,
            "isSignature": true
          },
          {
            "text": "\treturn (node as CanvasTextData).type === \"text\";",
            "lineNumber": 100
          },
          {
            "text": "}",
            "lineNumber": 101,
            "isSignature": true
          },
          {
            "lineNumber": 102
          },
          {
            "text": "/** Check if node is file type. */",
            "lineNumber": 103
          },
          {
            "text": "export function isFileNode(node: AllCanvasNodeData): node is CanvasFileData {",
            "lineNumber": 104,
            "isSignature": true
          },
          {
            "text": "\treturn (node as CanvasFileData).type === \"file\";",
            "lineNumber": 105
          },
          {
            "text": "}",
            "lineNumber": 106,
            "isSignature": true
          }
        ]
      },
      "score": 0.3215950131416321
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 86,
            "column": 1
          },
          "endPosition": {
            "line": 124,
            "column": 92
          }
        },
        "contents": "/** Build and append the legend to the canvas container (vanilla DOM, no innerHTML). Order: primary → tertiary, then Python, Text, Output. */\nfunction syncCanvasLegend(containerEl: HTMLElement, settings: ZettelPluginSettings): void {\n\tclearCanvasLegend(containerEl);\n\tif (!settings.showNodeRoleLabels) return;\n\tconst legend = document.createElement(\"div\");\n\tlegend.setAttribute(\"class\", LEGEND_CLASS);\n\tconst title = document.createElement(\"div\");\n\ttitle.setAttribute(\"class\", \"ztb-legend-title\");\n\ttitle.textContent = \"Legend\";\n\tlegend.appendChild(title);\n\tfor (const role of COLOR_ROLES) {\n\t\tconst key = &#96;color${role.charAt(0).toUpperCase() + role.slice(1)}&#96; as keyof ZettelPluginSettings;\n\t\tconst color = (settings[key] as CanvasColor) ?? \"\";\n\t\tconst row = document.createElement(\"div\");\n\t\trow.setAttribute(\"class\", \"ztb-legend-row\");\n\t\trow.appendChild(createLegendSwatch(color));\n\t\tconst text = document.createElement(\"span\");\n\t\ttext.setAttribute(\"class\", \"ztb-legend-text\");\n\t\ttext.textContent = getRoleLabel(role, settings);\n\t\trow.appendChild(text);\n\t\tlegend.appendChild(row);\n\t}\n\tconst otherRow = document.createElement(\"div\");\n\totherRow.setAttribute(\"class\", \"ztb-legend-row\");\n\tconst otherSwatch = document.createElement(\"span\");\n\totherSwatch.setAttribute(\"class\", \"ztb-legend-swatch ztb-legend-swatch--other\");\n\totherSwatch.style.backgroundColor = \"var(--text-muted)\";\n\totherRow.appendChild(otherSwatch);\n\tconst otherText = document.createElement(\"span\");\n\totherText.setAttribute(\"class\", \"ztb-legend-text\");\n\totherText.textContent = \"Uncolored / unused color = not connected; does not add to prompt.\";\n\totherRow.appendChild(otherText);\n\tlegend.appendChild(otherRow);\n\tcontainerEl.appendChild(legend);\n}\n\n/** Create a label element using Obsidian's canvas-node-label class (same as file nodes). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build and append the legend to the canvas container (vanilla DOM, no innerHTML). Order: primary → tertiary, then Python, Text, Output. */",
            "lineNumber": 89
          },
          {
            "text": "function syncCanvasLegend(containerEl: HTMLElement, settings: ZettelPluginSettings): void {",
            "lineNumber": 90,
            "isSignature": true
          },
          {
            "text": "\tclearCanvasLegend(containerEl);",
            "lineNumber": 91
          },
          {
            "text": "\tif (!settings.showNodeRoleLabels) return;",
            "lineNumber": 92
          },
          {
            "text": "\tconst legend = document.createElement(\"div\");",
            "lineNumber": 93
          },
          {
            "text": "\tlegend.setAttribute(\"class\", LEGEND_CLASS);",
            "lineNumber": 94
          },
          {
            "text": "\tconst title = document.createElement(\"div\");",
            "lineNumber": 95
          },
          {
            "text": "\ttitle.setAttribute(\"class\", \"ztb-legend-title\");",
            "lineNumber": 96
          },
          {
            "text": "\ttitle.textContent = \"Legend\";",
            "lineNumber": 97
          },
          {
            "text": "\tlegend.appendChild(title);",
            "lineNumber": 98
          },
          {
            "text": "\tfor (const role of COLOR_ROLES) {",
            "lineNumber": 99
          },
          {
            "text": "\t\tconst key = &#96;color${role.charAt(0).toUpperCase() + role.slice(1)}&#96; as keyof ZettelPluginSettings;",
            "lineNumber": 100
          },
          {
            "text": "\t\tconst color = (settings[key] as CanvasColor) ?? \"\";",
            "lineNumber": 101
          },
          {
            "text": "\t\tconst row = document.createElement(\"div\");",
            "lineNumber": 102
          },
          {
            "text": "\t\trow.setAttribute(\"class\", \"ztb-legend-row\");",
            "lineNumber": 103
          },
          {
            "text": "\t\trow.appendChild(createLegendSwatch(color));",
            "lineNumber": 104
          },
          {
            "text": "\t\tconst text = document.createElement(\"span\");",
            "lineNumber": 105
          },
          {
            "text": "\t\ttext.setAttribute(\"class\", \"ztb-legend-text\");",
            "lineNumber": 106
          },
          {
            "text": "\t\ttext.textContent = getRoleLabel(role, settings);",
            "lineNumber": 107
          },
          {
            "text": "\t\trow.appendChild(text);",
            "lineNumber": 108
          },
          {
            "text": "\t\tlegend.appendChild(row);",
            "lineNumber": 109
          },
          {
            "text": "\t}",
            "lineNumber": 110
          },
          {
            "text": "\tconst otherRow = document.createElement(\"div\");",
            "lineNumber": 111
          },
          {
            "text": "\totherRow.setAttribute(\"class\", \"ztb-legend-row\");",
            "lineNumber": 112
          },
          {
            "text": "\tconst otherSwatch = document.createElement(\"span\");",
            "lineNumber": 113
          },
          {
            "text": "\totherSwatch.setAttribute(\"class\", \"ztb-legend-swatch ztb-legend-swatch--other\");",
            "lineNumber": 114
          },
          {
            "text": "\totherSwatch.style.backgroundColor = \"var(--text-muted)\";",
            "lineNumber": 115
          },
          {
            "text": "\totherRow.appendChild(otherSwatch);",
            "lineNumber": 116
          },
          {
            "text": "\tconst otherText = document.createElement(\"span\");",
            "lineNumber": 117
          },
          {
            "text": "\totherText.setAttribute(\"class\", \"ztb-legend-text\");",
            "lineNumber": 118
          },
          {
            "text": "\totherText.textContent = \"Uncolored / unused color = not connected; does not add to prompt.\";",
            "lineNumber": 119
          },
          {
            "text": "\totherRow.appendChild(otherText);",
            "lineNumber": 120
          },
          {
            "text": "\tlegend.appendChild(otherRow);",
            "lineNumber": 121
          },
          {
            "text": "\tcontainerEl.appendChild(legend);",
            "lineNumber": 122
          },
          {
            "text": "}",
            "lineNumber": 123,
            "isSignature": true
          },
          {
            "lineNumber": 124
          },
          {
            "text": "/** Create a label element using Obsidian's canvas-node-label class (same as file nodes). */",
            "lineNumber": 125
          }
        ]
      },
      "score": 0.31994131207466125
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/state.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 25,
            "column": 1
          }
        },
        "contents": "/** Per-canvas state: NodeID -&gt; last output result string. */\nconst canvasState = new Map&lt;string, Map&lt;string, string&gt;&gt;();\n\n/** Per-canvas edge mode: EdgeID -&gt; \"inject\" | \"concatenate\" (shown in floating label under edge). */\nconst edgeModeState = new Map&lt;string, Map&lt;string, \"inject\" | \"concatenate\"&gt;&gt;();\n\n/** Node currently running (waiting for AI/kernel) per canvas; used to show \"running\" on incoming edges. */\nconst runningNodeState = new Map&lt;string, string | null&gt;();\n\nfunction getCanvasState(canvasKey: string): Map&lt;string, string&gt; {\n\tlet map = canvasState.get(canvasKey);\n\tif (!map) {\n\t\tmap = new Map();\n\t\tcanvasState.set(canvasKey, map);\n\t}\n\treturn map;\n}\n\nfunction getEdgeModeState(canvasKey: string): Map&lt;string, \"inject\" | \"concatenate\"&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Per-canvas state: NodeID -&gt; last output result string. */",
            "lineNumber": 1
          },
          {
            "text": "const canvasState = new Map&lt;string, Map&lt;string, string&gt;&gt;();",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "/** Per-canvas edge mode: EdgeID -&gt; \"inject\" | \"concatenate\" (shown in floating label under edge). */",
            "lineNumber": 4
          },
          {
            "text": "const edgeModeState = new Map&lt;string, Map&lt;string, \"inject\" | \"concatenate\"&gt;&gt;();",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "/** Node currently running (waiting for AI/kernel) per canvas; used to show \"running\" on incoming edges. */",
            "lineNumber": 7
          },
          {
            "text": "const runningNodeState = new Map&lt;string, string | null&gt;();",
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "function getCanvasState(canvasKey: string): Map&lt;string, string&gt; {",
            "lineNumber": 10,
            "isSignature": true
          },
          {
            "text": "\tlet map = canvasState.get(canvasKey);",
            "lineNumber": 11
          },
          {
            "text": "\tif (!map) {",
            "lineNumber": 12
          },
          {
            "text": "\t\tmap = new Map();",
            "lineNumber": 13
          },
          {
            "text": "\t\tcanvasState.set(canvasKey, map);",
            "lineNumber": 14
          },
          {
            "text": "\t}",
            "lineNumber": 15
          },
          {
            "text": "\treturn map;",
            "lineNumber": 16
          },
          {
            "text": "}",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "lineNumber": 18
          },
          {
            "text": "function getEdgeModeState(canvasKey: string): Map&lt;string, \"inject\" | \"concatenate\"&gt; {",
            "lineNumber": 19,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 20
          },
          {
            "text": "}",
            "lineNumber": 26,
            "isSignature": true
          }
        ]
      },
      "score": 0.31610405445098877
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 45,
            "column": 1
          }
        },
        "contents": "import type {Vault} from \"obsidian\";\nimport {loadCanvasData} from \"./nodes\";\nimport {getNodeRole, isOutputEdge} from \"./types\";\nimport type {CanvasColor, NodeRole, ZettelPluginSettings} from \"../settings\";\nimport {COLOR_ROLES, getPresetColor, getRoleLabel} from \"../settings\";\nimport type {LiveCanvas} from \"../engine/canvasApi\";\nimport {getCanvasKey, getEdgeMode, getRunningNodeId} from \"../engine/state\";\n\nconst LABEL_CLASS = \"ztb-node-role-label\";\nconst LABEL_DATA_ATTR = \"data-ztb-role-label\";\nconst LEGEND_CLASS = \"ztb-canvas-legend\";\nconst EDGE_MODE_LABEL_CLASS = \"ztb-edge-mode-label\";\nconst EDGE_MODE_DATA_ATTR = \"data-ztb-edge-id\";\nconst EDGE_MODE_STATE_ATTR = \"data-ztb-edge-state\";\nconst EDGE_MODE_ICON_CLASS = \"ztb-edge-mode-icon\";\ntype EdgeDisplayState = \"running\" | \"inject\" | \"concatenate\";\n/** Try to get a canvas node's root DOM element from the live canvas (Obsidian uses .canvas-node, no data-id). */\nfunction getNodeElFromCanvas(canvas: LiveCanvas, nodeId: string): HTMLElement | null {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {Vault} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {loadCanvasData} from \"./nodes\";",
            "lineNumber": 2
          },
          {
            "text": "import {getNodeRole, isOutputEdge} from \"./types\";",
            "lineNumber": 3
          },
          {
            "text": "import type {CanvasColor, NodeRole, ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 4
          },
          {
            "text": "import {COLOR_ROLES, getPresetColor, getRoleLabel} from \"../settings\";",
            "lineNumber": 5
          },
          {
            "text": "import type {LiveCanvas} from \"../engine/canvasApi\";",
            "lineNumber": 6
          },
          {
            "text": "import {getCanvasKey, getEdgeMode, getRunningNodeId} from \"../engine/state\";",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "const LABEL_CLASS = \"ztb-node-role-label\";",
            "lineNumber": 9
          },
          {
            "text": "const LABEL_DATA_ATTR = \"data-ztb-role-label\";",
            "lineNumber": 10
          },
          {
            "text": "const LEGEND_CLASS = \"ztb-canvas-legend\";",
            "lineNumber": 11
          },
          {
            "text": "const EDGE_MODE_LABEL_CLASS = \"ztb-edge-mode-label\";",
            "lineNumber": 12
          },
          {
            "text": "const EDGE_MODE_DATA_ATTR = \"data-ztb-edge-id\";",
            "lineNumber": 13
          },
          {
            "text": "const EDGE_MODE_STATE_ATTR = \"data-ztb-edge-state\";",
            "lineNumber": 14
          },
          {
            "text": "const EDGE_MODE_ICON_CLASS = \"ztb-edge-mode-icon\";",
            "lineNumber": 15
          },
          {
            "text": "type EdgeDisplayState = \"running\" | \"inject\" | \"concatenate\";",
            "lineNumber": 16,
            "isSignature": true
          },
          {
            "text": "/** Try to get a canvas node's root DOM element from the live canvas (Obsidian uses .canvas-node, no data-id). */",
            "lineNumber": 17
          },
          {
            "text": "function getNodeElFromCanvas(canvas: LiveCanvas, nodeId: string): HTMLElement | null {",
            "lineNumber": 18,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 19
          },
          {
            "text": "}",
            "lineNumber": 46,
            "isSignature": true
          }
        ]
      },
      "score": 0.3120642900466919
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 458,
            "column": 1
          },
          "endPosition": {
            "line": 493,
            "column": 93
          }
        },
        "contents": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */\nexport async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return { ok: false, message: \"Node not found.\" };\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };\n\tconst parentIds = getParentIdsSortedByY(nodeId, data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tfor (const pid of parentIds) {\n\t\tif (getNodeResult(canvasKey, pid) == null) {\n\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);\n\t\t}\n\t}\n\ttry {\n\t\tsetRunningNodeId(canvasKey, nodeId);\n\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t} finally {\n\t\tsetRunningNodeId(canvasKey, null);\n\t}\n}\n\nconst CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 461
          },
          {
            "text": "export async function runNode(",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 463,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 464,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 465,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 466,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 467,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 468,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 469
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 470
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 471
          },
          {
            "text": "\tif (!node) return { ok: false, message: \"Node not found.\" };",
            "lineNumber": 472
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 473
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 474
          },
          {
            "text": "\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };",
            "lineNumber": 475
          },
          {
            "text": "\tconst parentIds = getParentIdsSortedByY(nodeId, data);",
            "lineNumber": 476
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 477
          },
          {
            "text": "\tfor (const pid of parentIds) {",
            "lineNumber": 478
          },
          {
            "text": "\t\tif (getNodeResult(canvasKey, pid) == null) {",
            "lineNumber": 479
          },
          {
            "text": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);",
            "lineNumber": 480
          },
          {
            "text": "\t\t}",
            "lineNumber": 481
          },
          {
            "text": "\t}",
            "lineNumber": 482
          },
          {
            "text": "\ttry {",
            "lineNumber": 483
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, nodeId);",
            "lineNumber": 484
          },
          {
            "text": "\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);",
            "lineNumber": 485
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 486
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 487
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 488
          },
          {
            "text": "\t} finally {",
            "lineNumber": 489
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 490
          },
          {
            "text": "\t}",
            "lineNumber": 491
          },
          {
            "text": "}",
            "lineNumber": 492,
            "isSignature": true
          },
          {
            "lineNumber": 493
          },
          {
            "text": "const CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";",
            "lineNumber": 494
          }
        ]
      },
      "score": 0.3104695677757263
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 273,
            "column": 1
          },
          "endPosition": {
            "line": 665,
            "column": 1
          }
        },
        "contents": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */\nlet debugNodeMenuFired = false;\n\nexport default class ZettelThinkingBoardPlugin extends Plugin {\n\tsettings: ZettelPluginSettings;\n\n\tasync onload() {\n\t\ttry {\n\t\t\tawait this.loadSettings();\n\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));\n\n\t\t\tthis.registerView(\n\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,\n\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)\n\t\t\t);\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"open-zettel-controls\",\n\t\t\t\tname: \"Open Zettel Controls\",\n\t\t\t\tcallback: () =&gt; this.activateZettelControls(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"create-tutorial-canvas\",\n\t\t\t\tname: \"Create tutorial canvas\",\n\t\t\t\tcallback: () =&gt; this.createTutorialCanvas(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-node\",\n\t\t\t\tname: \"Run node\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-chain\",\n\t\t\t\tname: \"Run chain\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"dismiss-output\",\n\t\t\t\tname: \"Dismiss output\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 276
          },
          {
            "text": "let debugNodeMenuFired = false;",
            "lineNumber": 277
          },
          {
            "lineNumber": 278
          },
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 279,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings;",
            "lineNumber": 280
          },
          {
            "lineNumber": 281
          },
          {
            "text": "\tasync onload() {",
            "lineNumber": 282
          },
          {
            "text": "\t\ttry {",
            "lineNumber": 283
          },
          {
            "text": "\t\t\tawait this.loadSettings();",
            "lineNumber": 284
          },
          {
            "text": "\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));",
            "lineNumber": 285
          },
          {
            "lineNumber": 286
          },
          {
            "text": "\t\t\tthis.registerView(",
            "lineNumber": 287
          },
          {
            "text": "\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,",
            "lineNumber": 288
          },
          {
            "text": "\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)",
            "lineNumber": 289
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 290
          },
          {
            "lineNumber": 291
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 292
          },
          {
            "text": "\t\t\t\tid: \"open-zettel-controls\",",
            "lineNumber": 293
          },
          {
            "text": "\t\t\t\tname: \"Open Zettel Controls\",",
            "lineNumber": 294
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.activateZettelControls(),",
            "lineNumber": 295
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 296
          },
          {
            "lineNumber": 297
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 298
          },
          {
            "text": "\t\t\t\tid: \"create-tutorial-canvas\",",
            "lineNumber": 299
          },
          {
            "text": "\t\t\t\tname: \"Create tutorial canvas\",",
            "lineNumber": 300
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.createTutorialCanvas(),",
            "lineNumber": 301
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 302
          },
          {
            "lineNumber": 303
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 304
          },
          {
            "text": "\t\t\t\tid: \"run-node\",",
            "lineNumber": 305
          },
          {
            "text": "\t\t\t\tname: \"Run node\",",
            "lineNumber": 306
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 307
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 308
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 309
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 310
          },
          {
            "text": "\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu",
            "lineNumber": 311
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");",
            "lineNumber": 312
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 313
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 314
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 315
          },
          {
            "lineNumber": 316
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 317
          },
          {
            "text": "\t\t\t\tid: \"run-chain\",",
            "lineNumber": 318
          },
          {
            "text": "\t\t\t\tname: \"Run chain\",",
            "lineNumber": 319
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 320
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 321
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 322
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 323
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");",
            "lineNumber": 324
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 325
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 326
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 327
          },
          {
            "lineNumber": 328
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 329
          },
          {
            "text": "\t\t\t\tid: \"dismiss-output\",",
            "lineNumber": 330
          },
          {
            "text": "\t\t\t\tname: \"Dismiss output\",",
            "lineNumber": 331
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 332
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 333
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 334
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 335
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");",
            "lineNumber": 336
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 337
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 338
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 339
          },
          {
            "lineNumber": 340
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 341
          },
          {
            "text": "\t}",
            "lineNumber": 498
          },
          {
            "text": "}",
            "lineNumber": 666,
            "isSignature": true
          }
        ]
      },
      "score": 0.30500805377960205
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 384,
            "column": 1
          },
          "endPosition": {
            "line": 460,
            "column": 107
          }
        },
        "contents": "/** Create or replace the Green output node and ensure an edge labeled \"output\" from source. Mutates data only. */\nfunction ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings\n): void {\n\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);\n\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;\n\tconst width = Math.max(320, sourceNode.width);\n\tconst height = 180;\n\tconst defaultX = sourceNode.x;\n\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(\n\t\tdata,\n\t\tsourceNode.id,\n\t\toutId,\n\t\tdefaultX,\n\t\tdefaultY,\n\t\twidth,\n\t\theight\n\t);\n\tconst greenColor = settings.colorGreen;\n\n\tif (outId) {\n\t\tconst outNode = getNodeById(data, outId);\n\t\tif (outNode &amp;&amp; isTextNode(outNode)) {\n\t\t\tconst updated = {\n\t\t\t\t...(outNode as CanvasTextData),\n\t\t\t\ttext,\n\t\t\t\tx: chosenX,\n\t\t\t\ty: chosenY,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t};\n\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);\n\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t} else if (outNode) {\n\t\t\t(outNode as { x: number; y: number }).x = chosenX;\n\t\t\t(outNode as { x: number; y: number }).y = chosenY;\n\t\t}\n\t\tconst hasOutputEdge = data.edges.some(\n\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t\t);\n\t\tif (!hasOutputEdge) {\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: outId,\n\t\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tconst newNodeId = randomId();\n\tconst newTextNode: CanvasTextData = {\n\t\tid: newNodeId,\n\t\ttype: \"text\",\n\t\ttext,\n\t\tx: chosenX,\n\t\ty: chosenY,\n\t\twidth,\n\t\theight,\n\t\tcolor: greenColor,\n\t};\n\tdata.nodes.push(newTextNode);\n\tdata.edges.push({\n\t\tid: randomId(),\n\t\tfromNode: sourceNode.id,\n\t\ttoNode: newNodeId,\n\t\tlabel: EDGE_LABEL_OUTPUT,\n\t});\n}\n\n/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Create or replace the Green output node and ensure an edge labeled \"output\" from source. Mutates data only. */",
            "lineNumber": 387
          },
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 388,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 389,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 390,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 391,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 392,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 393,
            "isSignature": true
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);",
            "lineNumber": 394
          },
          {
            "text": "\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;",
            "lineNumber": 395
          },
          {
            "text": "\tconst width = Math.max(320, sourceNode.width);",
            "lineNumber": 396
          },
          {
            "text": "\tconst height = 180;",
            "lineNumber": 397
          },
          {
            "text": "\tconst defaultX = sourceNode.x;",
            "lineNumber": 398
          },
          {
            "text": "\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(",
            "lineNumber": 399
          },
          {
            "text": "\t\tdata,",
            "lineNumber": 400
          },
          {
            "text": "\t\tsourceNode.id,",
            "lineNumber": 401
          },
          {
            "text": "\t\toutId,",
            "lineNumber": 402
          },
          {
            "text": "\t\tdefaultX,",
            "lineNumber": 403
          },
          {
            "text": "\t\tdefaultY,",
            "lineNumber": 404
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 405
          },
          {
            "text": "\t\theight",
            "lineNumber": 406
          },
          {
            "text": "\t);",
            "lineNumber": 407
          },
          {
            "text": "\tconst greenColor = settings.colorGreen;",
            "lineNumber": 408
          },
          {
            "lineNumber": 409
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 410
          },
          {
            "text": "\t\tconst outNode = getNodeById(data, outId);",
            "lineNumber": 411
          },
          {
            "text": "\t\tif (outNode &amp;&amp; isTextNode(outNode)) {",
            "lineNumber": 412
          },
          {
            "text": "\t\t\tconst updated = {",
            "lineNumber": 413
          },
          {
            "text": "\t\t\t\t...(outNode as CanvasTextData),",
            "lineNumber": 414
          },
          {
            "text": "\t\t\t\ttext,",
            "lineNumber": 415
          },
          {
            "text": "\t\t\t\tx: chosenX,",
            "lineNumber": 416
          },
          {
            "text": "\t\t\t\ty: chosenY,",
            "lineNumber": 417
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 418
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 419
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 420
          },
          {
            "text": "\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);",
            "lineNumber": 421
          },
          {
            "text": "\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 422
          },
          {
            "text": "\t\t} else if (outNode) {",
            "lineNumber": 423
          },
          {
            "text": "\t\t\t(outNode as { x: number; y: number }).x = chosenX;",
            "lineNumber": 424
          },
          {
            "text": "\t\t\t(outNode as { x: number; y: number }).y = chosenY;",
            "lineNumber": 425
          },
          {
            "text": "\t\t}",
            "lineNumber": 426
          },
          {
            "text": "\t\tconst hasOutputEdge = data.edges.some(",
            "lineNumber": 427
          },
          {
            "text": "\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 428
          },
          {
            "text": "\t\t);",
            "lineNumber": 429
          },
          {
            "text": "\t\tif (!hasOutputEdge) {",
            "lineNumber": 430
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 431
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 432
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 433
          },
          {
            "text": "\t\t\t\ttoNode: outId,",
            "lineNumber": 434
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 435
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 436
          },
          {
            "text": "\t\t}",
            "lineNumber": 437
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 438
          },
          {
            "text": "\t}",
            "lineNumber": 439
          },
          {
            "lineNumber": 440
          },
          {
            "text": "\tconst newNodeId = randomId();",
            "lineNumber": 441
          },
          {
            "text": "\tconst newTextNode: CanvasTextData = {",
            "lineNumber": 442
          },
          {
            "text": "\t\tid: newNodeId,",
            "lineNumber": 443
          },
          {
            "text": "\t\ttype: \"text\",",
            "lineNumber": 444
          },
          {
            "text": "\t\ttext,",
            "lineNumber": 445
          },
          {
            "text": "\t\tx: chosenX,",
            "lineNumber": 446
          },
          {
            "text": "\t\ty: chosenY,",
            "lineNumber": 447
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 448
          },
          {
            "text": "\t\theight,",
            "lineNumber": 449
          },
          {
            "text": "\t\tcolor: greenColor,",
            "lineNumber": 450
          },
          {
            "text": "\t};",
            "lineNumber": 451
          },
          {
            "text": "\tdata.nodes.push(newTextNode);",
            "lineNumber": 452
          },
          {
            "text": "\tdata.edges.push({",
            "lineNumber": 453
          },
          {
            "text": "\t\tid: randomId(),",
            "lineNumber": 454
          },
          {
            "text": "\t\tfromNode: sourceNode.id,",
            "lineNumber": 455
          },
          {
            "text": "\t\ttoNode: newNodeId,",
            "lineNumber": 456
          },
          {
            "text": "\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 457
          },
          {
            "text": "\t});",
            "lineNumber": 458
          },
          {
            "text": "}",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "lineNumber": 460
          },
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 461
          }
        ]
      },
      "score": 0.29895588755607605
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 278
          },
          "endPosition": {
            "line": 665,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\nconst runSyncLabels = \n\n\t\t\t\tif (leaf?.view) {\n\t\t\t\t\tconst itemView = leaf.view as ViewWithFlag;\n\t\t\t\t\tif (itemView._ztbTitleBarActionsAdded) {\n\t\t\t\t\t\taddedToTitleBar = true;\n\t\t\t\t\t} else if (typeof itemView.addAction === \"function\") {\n\t\t\t\t\t\titemView.addAction(\"play\", \"Run entire canvas\", () =&gt; this.runEntireCanvas());\n\t\t\t\t\t\titemView.addAction(\"trash\", \"Dismiss all output\", () =&gt; this.dismissAllOutput());\n\t\t\t\t\t\titemView._ztbTitleBarActionsAdded = true;\n\t\t\t\t\t\taddedToTitleBar = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addedToTitleBar) this.addCanvasToolbarToContainer(view.containerEl);\n\t\t\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;\n\t\t\t\tconst isStillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;\n\t\t\t\tsyncCanvasRoleLabels(this.app.vault, view.file.path, view.containerEl, this.settings, liveCanvas, isStillActive);\n\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, view.file.path, view.containerEl, liveCanvas, isStillActive);\n\t\t\t\tif (roleLabelsIntervalId == null) {\n\t\t\t\t\troleLabelsIntervalId = window.setInterval(() =&gt; {\n\t\t\t\t\t\tconst v = this.getActiveCanvasView();\n\t\t\t\t\t\tif (v != null &amp;&amp; v.containerEl === roleLabelsContainerEl) {\n\t\t\t\t\t\t\tconst stillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;\n\t\t\t\t\t\t\tsyncCanvasRoleLabels(this.app.vault, v.file.path, v.containerEl, this.settings, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);\n\t\t\t\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, v.file.path, v.containerEl, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 2000);\n\t\t\t\t\t(this as unknown as { _roleLabelsIntervalId: number })._roleLabelsIntervalId = roleLabelsIntervalId;\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.registerEvent(this.app.workspace.on(\"active-leaf-change\", runSyncLabels));\n\t\t\trunSyncLabels();\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Zettel Thinking Board onload error:\", e);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tonunload() {\n\t\tterminateAllKernels();\n\t\tconst id = (;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 279,
                "column": 1
              },
              "endPosition": {
                "line": 279,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 279,
                "column": 16
              },
              "endPosition": {
                "line": 280,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 282,
                "column": 2
              },
              "endPosition": {
                "line": 283,
                "column": 3
              }
            },
            {
              "startPosition": {
                "line": 435,
                "column": 4
              },
              "endPosition": {
                "line": 435,
                "column": 10
              }
            },
            {
              "startPosition": {
                "line": 435,
                "column": 10
              },
              "endPosition": {
                "line": 435,
                "column": 26
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 279,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 282
          },
          {
            "text": "const runSyncLabels = ",
            "lineNumber": 435
          },
          {
            "lineNumber": 463
          },
          {
            "text": "\t\t\t\tif (leaf?.view) {",
            "lineNumber": 464
          },
          {
            "text": "\t\t\t\t\tconst itemView = leaf.view as ViewWithFlag;",
            "lineNumber": 465
          },
          {
            "text": "\t\t\t\t\tif (itemView._ztbTitleBarActionsAdded) {",
            "lineNumber": 466
          },
          {
            "text": "\t\t\t\t\t\taddedToTitleBar = true;",
            "lineNumber": 467
          },
          {
            "text": "\t\t\t\t\t} else if (typeof itemView.addAction === \"function\") {",
            "lineNumber": 468
          },
          {
            "text": "\t\t\t\t\t\titemView.addAction(\"play\", \"Run entire canvas\", () =&gt; this.runEntireCanvas());",
            "lineNumber": 469
          },
          {
            "text": "\t\t\t\t\t\titemView.addAction(\"trash\", \"Dismiss all output\", () =&gt; this.dismissAllOutput());",
            "lineNumber": 470
          },
          {
            "text": "\t\t\t\t\t\titemView._ztbTitleBarActionsAdded = true;",
            "lineNumber": 471
          },
          {
            "text": "\t\t\t\t\t\taddedToTitleBar = true;",
            "lineNumber": 472
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 473
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 474
          },
          {
            "text": "\t\t\t\tif (!addedToTitleBar) this.addCanvasToolbarToContainer(view.containerEl);",
            "lineNumber": 475
          },
          {
            "text": "\t\t\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;",
            "lineNumber": 476
          },
          {
            "text": "\t\t\t\tconst isStillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;",
            "lineNumber": 477
          },
          {
            "text": "\t\t\t\tsyncCanvasRoleLabels(this.app.vault, view.file.path, view.containerEl, this.settings, liveCanvas, isStillActive);",
            "lineNumber": 478
          },
          {
            "text": "\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, view.file.path, view.containerEl, liveCanvas, isStillActive);",
            "lineNumber": 479
          },
          {
            "text": "\t\t\t\tif (roleLabelsIntervalId == null) {",
            "lineNumber": 480
          },
          {
            "text": "\t\t\t\t\troleLabelsIntervalId = window.setInterval(() =&gt; {",
            "lineNumber": 481
          },
          {
            "text": "\t\t\t\t\t\tconst v = this.getActiveCanvasView();",
            "lineNumber": 482
          },
          {
            "text": "\t\t\t\t\t\tif (v != null &amp;&amp; v.containerEl === roleLabelsContainerEl) {",
            "lineNumber": 483
          },
          {
            "text": "\t\t\t\t\t\t\tconst stillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;",
            "lineNumber": 484
          },
          {
            "text": "\t\t\t\t\t\t\tsyncCanvasRoleLabels(this.app.vault, v.file.path, v.containerEl, this.settings, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);",
            "lineNumber": 485
          },
          {
            "text": "\t\t\t\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, v.file.path, v.containerEl, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);",
            "lineNumber": 486
          },
          {
            "text": "\t\t\t\t\t\t}",
            "lineNumber": 487
          },
          {
            "text": "\t\t\t\t\t}, 2000);",
            "lineNumber": 488
          },
          {
            "text": "\t\t\t\t\t(this as unknown as { _roleLabelsIntervalId: number })._roleLabelsIntervalId = roleLabelsIntervalId;",
            "lineNumber": 489
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 490
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 491
          },
          {
            "text": "\t\t\tthis.registerEvent(this.app.workspace.on(\"active-leaf-change\", runSyncLabels));",
            "lineNumber": 492
          },
          {
            "text": "\t\t\trunSyncLabels();",
            "lineNumber": 493
          },
          {
            "text": "\t\t} catch (e) {",
            "lineNumber": 494
          },
          {
            "text": "\t\t\tconsole.error(\"Zettel Thinking Board onload error:\", e);",
            "lineNumber": 495
          },
          {
            "text": "\t\t\tthrow e;",
            "lineNumber": 496
          },
          {
            "text": "\t\t}",
            "lineNumber": 497
          },
          {
            "text": "\t}",
            "lineNumber": 498
          },
          {
            "lineNumber": 499
          },
          {
            "text": "\tonunload() {",
            "lineNumber": 500
          },
          {
            "text": "\t\tterminateAllKernels();",
            "lineNumber": 501
          },
          {
            "text": "\t\tconst id = (;",
            "lineNumber": 502
          },
          {
            "text": "\t}",
            "lineNumber": 504
          },
          {
            "text": "}",
            "lineNumber": 666,
            "isSignature": true
          }
        ]
      },
      "score": 0.29611313343048096
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/nodes.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 34,
            "column": 1
          }
        },
        "contents": "import type {Vault} from \"obsidian\";\nimport type {AllCanvasNodeData, CanvasData, CanvasFileData, CanvasTextData} from \"obsidian/canvas\";\nimport {\n\tgetFileNodePath,\n\tgetNodeById,\n\tgetNodeRole,\n\tgetParentIdsSortedByY,\n\tgetTextNodeContent,\n\tisFileNode,\n\tisTextNode,\n} from \"./types\";\nimport type {ZettelPluginSettings} from \"../settings\";\n\n/** Load canvas data from vault by reading the canvas file (JSON). */\nexport async function loadCanvasData(vault: Vault, filePath: string): Promise&lt;CanvasData | null&gt; {\n\ttry {\n\t\tconst raw = await vault.adapter.read(filePath);\n\t\tconst data = JSON.parse(raw) as CanvasData;\n\t\tif (data &amp;&amp; Array.isArray(data.nodes) &amp;&amp; Array.isArray(data.edges)) return data;\n\t} catch {\n\t\t// ignore\n\t}\n\treturn null;\n}\n\n/** Save canvas data to vault (writes the canvas file). */\nexport async function saveCanvasData(vault: Vault, filePath: string, data: CanvasData): Promise&lt;boolean&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {Vault} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import type {AllCanvasNodeData, CanvasData, CanvasFileData, CanvasTextData} from \"obsidian/canvas\";",
            "lineNumber": 2
          },
          {
            "text": "import {",
            "lineNumber": 3
          },
          {
            "text": "\tgetFileNodePath,",
            "lineNumber": 4
          },
          {
            "text": "\tgetNodeById,",
            "lineNumber": 5
          },
          {
            "text": "\tgetNodeRole,",
            "lineNumber": 6
          },
          {
            "text": "\tgetParentIdsSortedByY,",
            "lineNumber": 7
          },
          {
            "text": "\tgetTextNodeContent,",
            "lineNumber": 8
          },
          {
            "text": "\tisFileNode,",
            "lineNumber": 9
          },
          {
            "text": "\tisTextNode,",
            "lineNumber": 10
          },
          {
            "text": "} from \"./types\";",
            "lineNumber": 11
          },
          {
            "text": "import type {ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 12
          },
          {
            "lineNumber": 13
          },
          {
            "text": "/** Load canvas data from vault by reading the canvas file (JSON). */",
            "lineNumber": 14
          },
          {
            "text": "export async function loadCanvasData(vault: Vault, filePath: string): Promise&lt;CanvasData | null&gt; {",
            "lineNumber": 15,
            "isSignature": true
          },
          {
            "text": "\ttry {",
            "lineNumber": 16
          },
          {
            "text": "\t\tconst raw = await vault.adapter.read(filePath);",
            "lineNumber": 17
          },
          {
            "text": "\t\tconst data = JSON.parse(raw) as CanvasData;",
            "lineNumber": 18
          },
          {
            "text": "\t\tif (data &amp;&amp; Array.isArray(data.nodes) &amp;&amp; Array.isArray(data.edges)) return data;",
            "lineNumber": 19
          },
          {
            "text": "\t} catch {",
            "lineNumber": 20
          },
          {
            "text": "\t\t// ignore",
            "lineNumber": 21
          },
          {
            "text": "\t}",
            "lineNumber": 22
          },
          {
            "text": "\treturn null;",
            "lineNumber": 23
          },
          {
            "text": "}",
            "lineNumber": 24,
            "isSignature": true
          },
          {
            "lineNumber": 25
          },
          {
            "text": "/** Save canvas data to vault (writes the canvas file). */",
            "lineNumber": 26
          },
          {
            "text": "export async function saveCanvasData(vault: Vault, filePath: string, data: CanvasData): Promise&lt;boolean&gt; {",
            "lineNumber": 27,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 28
          },
          {
            "text": "}",
            "lineNumber": 35,
            "isSignature": true
          }
        ]
      },
      "score": 0.2943159341812134
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 228
          },
          "endPosition": {
            "line": 329,
            "column": 1
          }
        },
        "contents": "export async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\n\t\tif (state === \"running\") {\n\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");\n\t\t\tcircle.setAttribute(\"class\", EDGE_MODE_ICON_CLASS);\n\t\t\tcircle.setAttribute(\"cx\", String(DOT_R_RUNNING + 2));\n\t\t\tcircle.setAttribute(\"cy\", String(fontSize * 0.4));\n\t\t\tcircle.setAttribute(\"r\", String(DOT_R_RUNNING));\n\t\t\tlabelGroup.appendChild(circle);\n\t\t\ttextX = DOT_R_RUNNING * 2 + DOT_TEXT_GAP;\n\t\t}\n\t\tconst textEl = document.createElementNS(SVG_NS, \"text\");\n\t\ttextEl.setAttribute(\"class\", EDGE_MODE_LABEL_CLASS);\n\t\ttextEl.setAttribute(\"x\", String(textX));\n\t\ttextEl.setAttribute(\"y\", String(fontSize * 0.35));\n\t\ttextEl.setAttribute(\"font-size\", String(fontSize));\n\t\ttextEl.setAttribute(\"text-anchor\", \"start\");\n\t\ttextEl.setAttribute(\"dominant-baseline\", \"central\");\n\t\ttextEl.textContent = textContent;\n\t\tlabelGroup.appendChild(textEl);\n\t\tgroup.appendChild(labelGroup);\n\t}\n\t// Mark output edges so their label can be styled smaller/grayed\n\tfor (const edge of data.edges) {\n\t\tif (!isOutputEdge(edge)) continue;\n\t\tconst fromEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);\n\t\tconst toEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);\n\t\tif (!fromEl || !toEl) continue;\n\t\tconst fromCenter = getElCenter(fromEl);\n\t\tconst toCenter = getElCenter(toEl);\n\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;\n\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;\n\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);\n\t\tif (!pathEl) continue;\n\t\tconst group = pathEl.closest(\"g\");\n\t\tif (group) group.classList.add(OUTPUT_EDGE_GROUP_CLASS);\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 229,
                "column": 1
              },
              "endPosition": {
                "line": 229,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 229,
                "column": 8
              },
              "endPosition": {
                "line": 236,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 235,
            "isSignature": true
          },
          {
            "lineNumber": 290
          },
          {
            "text": "\t\tif (state === \"running\") {",
            "lineNumber": 291
          },
          {
            "text": "\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");",
            "lineNumber": 292
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"class\", EDGE_MODE_ICON_CLASS);",
            "lineNumber": 293
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"cx\", String(DOT_R_RUNNING + 2));",
            "lineNumber": 294
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"cy\", String(fontSize * 0.4));",
            "lineNumber": 295
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"r\", String(DOT_R_RUNNING));",
            "lineNumber": 296
          },
          {
            "text": "\t\t\tlabelGroup.appendChild(circle);",
            "lineNumber": 297
          },
          {
            "text": "\t\t\ttextX = DOT_R_RUNNING * 2 + DOT_TEXT_GAP;",
            "lineNumber": 298
          },
          {
            "text": "\t\t}",
            "lineNumber": 299
          },
          {
            "text": "\t\tconst textEl = document.createElementNS(SVG_NS, \"text\");",
            "lineNumber": 300
          },
          {
            "text": "\t\ttextEl.setAttribute(\"class\", EDGE_MODE_LABEL_CLASS);",
            "lineNumber": 301
          },
          {
            "text": "\t\ttextEl.setAttribute(\"x\", String(textX));",
            "lineNumber": 302
          },
          {
            "text": "\t\ttextEl.setAttribute(\"y\", String(fontSize * 0.35));",
            "lineNumber": 303
          },
          {
            "text": "\t\ttextEl.setAttribute(\"font-size\", String(fontSize));",
            "lineNumber": 304
          },
          {
            "text": "\t\ttextEl.setAttribute(\"text-anchor\", \"start\");",
            "lineNumber": 305
          },
          {
            "text": "\t\ttextEl.setAttribute(\"dominant-baseline\", \"central\");",
            "lineNumber": 306
          },
          {
            "text": "\t\ttextEl.textContent = textContent;",
            "lineNumber": 307
          },
          {
            "text": "\t\tlabelGroup.appendChild(textEl);",
            "lineNumber": 308
          },
          {
            "text": "\t\tgroup.appendChild(labelGroup);",
            "lineNumber": 309
          },
          {
            "text": "\t}",
            "lineNumber": 310
          },
          {
            "text": "\t// Mark output edges so their label can be styled smaller/grayed",
            "lineNumber": 311
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 312
          },
          {
            "text": "\t\tif (!isOutputEdge(edge)) continue;",
            "lineNumber": 313
          },
          {
            "text": "\t\tconst fromEl =",
            "lineNumber": 314
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||",
            "lineNumber": 315
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);",
            "lineNumber": 316
          },
          {
            "text": "\t\tconst toEl =",
            "lineNumber": 317
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||",
            "lineNumber": 318
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);",
            "lineNumber": 319
          },
          {
            "text": "\t\tif (!fromEl || !toEl) continue;",
            "lineNumber": 320
          },
          {
            "text": "\t\tconst fromCenter = getElCenter(fromEl);",
            "lineNumber": 321
          },
          {
            "text": "\t\tconst toCenter = getElCenter(toEl);",
            "lineNumber": 322
          },
          {
            "text": "\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;",
            "lineNumber": 323
          },
          {
            "text": "\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;",
            "lineNumber": 324
          },
          {
            "text": "\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);",
            "lineNumber": 325
          },
          {
            "text": "\t\tif (!pathEl) continue;",
            "lineNumber": 326
          },
          {
            "text": "\t\tconst group = pathEl.closest(\"g\");",
            "lineNumber": 327
          },
          {
            "text": "\t\tif (group) group.classList.add(OUTPUT_EDGE_GROUP_CLASS);",
            "lineNumber": 328
          },
          {
            "text": "\t}",
            "lineNumber": 329
          },
          {
            "text": "}",
            "lineNumber": 330,
            "isSignature": true
          }
        ]
      },
      "score": 0.28814923763275146
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "markdown|MarkdownView|setMarkdown|renderMarkdown",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "markdown|MarkdownView|setMarkdown|renderMarkdown",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "./src/__mocks__/obsidian.ts",
              "matches": [
                {
                  "lineNumber": 35,
                  "content": "export const MarkdownView = class {};"
                }
              ]
            }
          ],
          "totalLines": 1,
          "totalMatchedLines": 1
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---


Checking how the runner passes node text to the Python kernel and whether we can support fenced code blocks:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "buildInputWithVariables",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "contextAfter": 2,
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "buildInputWithVariables",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 157,
                  "content": "function buildInputWithVariables("
                },
                {
                  "lineNumber": 158,
                  "content": "\tcanvasKey: string,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 159,
                  "content": "\tnodeInput: string,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 249,
                  "content": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables("
                },
                {
                  "lineNumber": 250,
                  "content": "\t\tcanvasKey,",
                  "isContextLine": true
                },
                {
                  "lineNumber": 251,
                  "content": "\t\tnodeInput,",
                  "isContextLine": true
                }
              ]
            }
          ],
          "totalLines": 6,
          "totalMatchedLines": 2
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---


Obsidian renders canvas text nodes as Markdown, so `# comment` becomes a heading. Wrapping the Python in a fenced code block (```python ... ```) makes Obsidian render it as a code block so `#` stays a comment. Adding a small helper to strip optional ```python/``` fences before sending the template to the Python kernel so execution still works.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/pythonKernel.ts</summary>

</details>
</tool-use>

---


Adding a helper to strip fenced code blocks from Python before execution, and documenting that users can wrap Python in ```python ... ``` for proper display.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---


Adding a brief tip to the in-app guide so users know they can use fenced code blocks:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/views/ZettelControlsView.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---





---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/views/ZettelControlsView.ts</summary>

</details>

</tool-use>

---


Making fence stripping more robust: strip only when the first line is exactly the opening fence and the last line is exactly the closing fence, so code containing ``` isn't corrupted.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---


Summary of what’s in place:

**1. Use a fenced code block in the Python card**

In the **canvas text node** (the Python card), wrap the code in a markdown code block:

```python
print('Python says:', (input or '')[:80] or '(no input)')
# input = text from parent
```

Obsidian will render that as a code block, so `#` is shown as part of the code (and can get syntax highlighting), not as a heading.

**2. Plugin strips the fence before running**

Execution still uses only the code: the plugin now strips an optional **first line** that is exactly ` ```python ` or ` ``` ` and an optional **last line** that is exactly ` ``` ` before sending the content to the Python kernel. So:

- You can safely use ` ```python ... ``` ` in the card for display.
- Running the node executes only the inner code; the fences are removed automatically.

**3. In-app tip**

In **Zettel Controls → How to use the canvas**, there’s a new tip:  
“In Python cards, wrap code in \`\`\`python ... \`\`\` so # comments render as comments instead of headings; the plugin still runs the code inside.”

**Code changes**

- **`src/engine/runner.ts`**: Added `stripPythonCodeFence()` and use it for blue (Python) nodes so only the first/last fence lines are removed; code that contains ` ``` ` in the middle is unchanged.
- **`src/views/ZettelControlsView.ts`**: Added the guide tip about wrapping Python in ` ```python ... ``` `.

No new settings or dependencies. After rebuilding, use ` ```python ` at the start and ` ``` ` at the end of your Python card content to get comment-style rendering and correct execution.

---

_**User**_

Make the fencing more automatic, if I use the color for a python code block, automatically include that.

---

_**Agent (model default, mode Agent)**_


Implementing automatic wrapping of Python (blue) node content in ```python ... ``` when we're about to run it, then saving the canvas so the fence persists for display.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "isTextNode|CanvasTextData|\\.text",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "isTextNode|CanvasTextData|\\.text",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/canvas/canvasNodeLabels.ts",
              "matches": [
                {
                  "lineNumber": 97,
                  "content": "\ttitle.textContent = \"Legend\";"
                },
                {
                  "lineNumber": 107,
                  "content": "\t\ttext.textContent = getRoleLabel(role, settings);"
                },
                {
                  "lineNumber": 119,
                  "content": "\totherText.textContent = \"Uncolored / unused color = not connected; does not add to prompt.\";"
                },
                {
                  "lineNumber": 130,
                  "content": "\tel.textContent = text;"
                },
                {
                  "lineNumber": 307,
                  "content": "\t\ttextEl.textContent = textContent;"
                }
              ]
            },
            {
              "file": "src/canvas/types.ts",
              "matches": [
                {
                  "lineNumber": 7,
                  "content": "\tCanvasTextData,"
                },
                {
                  "lineNumber": 12,
                  "content": "export type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasFileData, CanvasNodeData, CanvasTextData};"
                },
                {
                  "lineNumber": 99,
                  "content": "export function isTextNode(node: AllCanvasNodeData): node is CanvasTextData {"
                },
                {
                  "lineNumber": 100,
                  "content": "\treturn (node as CanvasTextData).type === \"text\";"
                },
                {
                  "lineNumber": 109,
                  "content": "export function getTextNodeContent(node: CanvasTextData): string {"
                },
                {
                  "lineNumber": 110,
                  "content": "\treturn node.text ?? \"\";"
                }
              ]
            },
            {
              "file": "src/canvas/nodes.ts",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "import type {AllCanvasNodeData, CanvasData, CanvasFileData, CanvasTextData} from \"obsidian/canvas\";"
                },
                {
                  "lineNumber": 10,
                  "content": "\tisTextNode,"
                },
                {
                  "lineNumber": 42,
                  "content": "\tif (isTextNode(node)) return getTextNodeContent(node as CanvasTextData);"
                },
                {
                  "lineNumber": 70,
                  "content": "\tisTextNode,"
                }
              ]
            }
          ],
          "totalLines": 15,
          "totalMatchedLines": 15
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/nodes.ts</summary>

</details>
</tool-use>

---


Adding a fenced check and ensure-helper, then auto-wrapping Python (blue) text nodes before run and saving the canvas.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---


Applying fencing even when the node is empty so new Python cards get the fence on first run.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---


Updating the in-app tip to state fencing is automatic:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/views/ZettelControlsView.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts",
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/views/ZettelControlsView.ts"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts",
      "errors": [
        {
          "message": "Object is possibly 'undefined'.",
          "range": {
            "startPosition": {
              "line": 160,
              "column": 16
            },
            "endPosition": {
              "line": 160,
              "column": 24
            }
          },
          "source": "ts",
          "severity": "DIAGNOSTIC_SEVERITY_ERROR"
        },
        {
          "message": "Object is possibly 'undefined'.",
          "range": {
            "startPosition": {
              "line": 161,
              "column": 15
            },
            "endPosition": {
              "line": 161,
              "column": 38
            }
          },
          "source": "ts",
          "severity": "DIAGNOSTIC_SEVERITY_ERROR"
        },
        {
          "message": "Object is possibly 'undefined'.",
          "range": {
            "startPosition": {
              "line": 175,
              "column": 16
            },
            "endPosition": {
              "line": 175,
              "column": 24
            }
          },
          "source": "ts",
          "severity": "DIAGNOSTIC_SEVERITY_ERROR"
        },
        {
          "message": "Object is possibly 'undefined'.",
          "range": {
            "startPosition": {
              "line": 176,
              "column": 15
            },
            "endPosition": {
              "line": 176,
              "column": 38
            }
          },
          "source": "ts",
          "severity": "DIAGNOSTIC_SEVERITY_ERROR"
        }
      ]
    },
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/views/ZettelControlsView.ts"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Fixing linter errors in the fence helpers:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---





---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Summary of changes:

**Automatic fencing for Python (blue) nodes**

1. **On run**  
   When you run a node (Run node / Run chain) and that node is a **Python (blue)** text card, the plugin now:
   - Checks whether the card text is already wrapped in \`\`\`python ... \`\`\` (or \`\`\` ... \`\`\`).
   - If not, wraps it in \`\`\`python ... \`\`\`, updates the canvas data, and saves the file.
   - Then runs the node as before (fences are still stripped before sending code to the kernel).

2. **No manual step**  
   You only need to set the card color to the Python color and type your code. The first time you run that node, the plugin adds the fence and saves, so \`#\` comments render as comments and the card stays fenced for future runs.

3. **Helpers**  
   - `isPythonCodeFenced(text)` – detects existing \`\`\`python / \`\`\` … \`\`\` wrapping.  
   - `ensurePythonCodeFence(text)` – returns the same string if already fenced, otherwise \`\`\`python\n\` + trimmed text + \`\n\`\`\`\`.  
   - Execution still uses `stripPythonCodeFence(template)` so only the inner code is sent to the kernel.

4. **Guide tip**  
   The Zettel Controls tip now says that Python cards are auto-wrapped when you run the node if needed.

**Files touched**

- `src/engine/runner.ts`: fence detection/ensure/strip helpers, and before reading content for a blue text node we ensure it’s fenced and save.
- `src/views/ZettelControlsView.ts`: updated tip text.

---

