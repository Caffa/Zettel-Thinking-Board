<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 35a4072b-9139-4f81-ae97-a0dd24f53638 (2026-02-03 09:47Z) -->

# Output note collision avoidance code (2026-02-03 09:47Z)

_**User**_

Where is the code for collision avoidance? because I want to move the output note to be even lower than the current position when it is produced 

---

_**Agent (model default, mode Agent)**_





---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "collision|avoid",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "collision|avoid",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "./src/canvas/canvasNodeLabels.ts",
              "matches": [
                {
                  "lineNumber": 138,
                  "content": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas"
                },
                {
                  "lineNumber": 160,
                  "content": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker)."
                },
                {
                  "lineNumber": 226,
                  "content": " * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping."
                },
                {
                  "lineNumber": 227,
                  "content": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas"
                },
                {
                  "lineNumber": 242,
                  "content": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker)."
                }
              ]
            },
            {
              "file": "./src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 284,
                  "content": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */"
                },
                {
                  "lineNumber": 286,
                  "content": "/** Step (px) between candidate x positions when avoiding collisions. */"
                },
                {
                  "lineNumber": 301,
                  "content": "/** Choose an x for the output box to avoid overlapping other nodes; tries defaultX then right then left within maxRadius. */"
                }
              ]
            },
            {
              "file": "./src/main.ts",
              "matches": [
                {
                  "lineNumber": 91,
                  "content": "\t\t\t// Defer registration so Obsidian canvas is ready (avoids \"reading '_'\" in app.js)."
                }
              ]
            },
            {
              "file": "./src/types.ts",
              "matches": [
                {
                  "lineNumber": 4,
                  "content": "/** Plugin interface used by views to avoid circular dependency on main. */"
                }
              ]
            },
            {
              "file": "./PRD.md",
              "matches": [
                {
                  "lineNumber": 77,
                  "content": "*   **Auto-Layout:** When a Green node is spawned, ensure it doesn't perfectly overlap existing nodes (simple collision check or just strictly placing it below)."
                }
              ]
            },
            {
              "file": "./.cursorrules",
              "matches": [
                {
                  "lineNumber": 37,
                  "content": "- Strictly typed: avoid &#96;any&#96; wherever possible."
                }
              ]
            },
            {
              "file": "./AGENTS.md",
              "matches": [
                {
                  "lineNumber": 99,
                  "content": "- Use stable command IDs; avoid renaming once released."
                },
                {
                  "lineNumber": 133,
                  "content": "- Batch disk access and avoid excessive vault scans."
                }
              ]
            },
            {
              "file": "./LICENSE",
              "matches": [
                {
                  "lineNumber": 64,
                  "content": "avoid the special danger that patents applied to a free program could"
                }
              ]
            }
          ],
          "totalLines": 15,
          "totalMatchedLines": 15
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Where is output note position or placement when produced?",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 339,
            "column": 1
          },
          "endPosition": {
            "line": 417,
            "column": 107
          }
        },
        "contents": "/** Create or replace the Green output node and ensure an edge labeled \"output\" from source. Mutates data only. */\nfunction ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings\n): void {\n\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);\n\tconst y = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;\n\tconst width = Math.max(320, sourceNode.width);\n\tconst height = 180;\n\tconst defaultX = sourceNode.x;\n\tconst chosenX = chooseOutputPosition(\n\t\tdata,\n\t\tsourceNode.id,\n\t\toutId,\n\t\tdefaultX,\n\t\ty,\n\t\twidth,\n\t\theight,\n\t\tOUTPUT_COLLISION_MAX_RADIUS,\n\t\tOUTPUT_COLLISION_STEP\n\t);\n\tconst greenColor = settings.colorGreen;\n\n\tif (outId) {\n\t\tconst outNode = getNodeById(data, outId);\n\t\tif (outNode &amp;&amp; isTextNode(outNode)) {\n\t\t\tconst updated = {\n\t\t\t\t...(outNode as CanvasTextData),\n\t\t\t\ttext,\n\t\t\t\tx: chosenX,\n\t\t\t\ty,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t};\n\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);\n\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t} else if (outNode) {\n\t\t\t(outNode as { x: number; y: number }).x = chosenX;\n\t\t\t(outNode as { x: number; y: number }).y = y;\n\t\t}\n\t\tconst hasOutputEdge = data.edges.some(\n\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t\t);\n\t\tif (!hasOutputEdge) {\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: outId,\n\t\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t\t});\n\t\t}\n\t\treturn;\n\t}\n\n\tconst newNodeId = randomId();\n\tconst newTextNode: CanvasTextData = {\n\t\tid: newNodeId,\n\t\ttype: \"text\",\n\t\ttext,\n\t\tx: chosenX,\n\t\ty,\n\t\twidth,\n\t\theight,\n\t\tcolor: greenColor,\n\t};\n\tdata.nodes.push(newTextNode);\n\tdata.edges.push({\n\t\tid: randomId(),\n\t\tfromNode: sourceNode.id,\n\t\ttoNode: newNodeId,\n\t\tlabel: EDGE_LABEL_OUTPUT,\n\t});\n}\n\n/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Create or replace the Green output node and ensure an edge labeled \"output\" from source. Mutates data only. */",
            "lineNumber": 342
          },
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 343,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 344,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 345,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 346,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 347,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 348,
            "isSignature": true
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);",
            "lineNumber": 349
          },
          {
            "text": "\tconst y = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;",
            "lineNumber": 350
          },
          {
            "text": "\tconst width = Math.max(320, sourceNode.width);",
            "lineNumber": 351
          },
          {
            "text": "\tconst height = 180;",
            "lineNumber": 352
          },
          {
            "text": "\tconst defaultX = sourceNode.x;",
            "lineNumber": 353
          },
          {
            "text": "\tconst chosenX = chooseOutputPosition(",
            "lineNumber": 354
          },
          {
            "text": "\t\tdata,",
            "lineNumber": 355
          },
          {
            "text": "\t\tsourceNode.id,",
            "lineNumber": 356
          },
          {
            "text": "\t\toutId,",
            "lineNumber": 357
          },
          {
            "text": "\t\tdefaultX,",
            "lineNumber": 358
          },
          {
            "text": "\t\ty,",
            "lineNumber": 359
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 360
          },
          {
            "text": "\t\theight,",
            "lineNumber": 361
          },
          {
            "text": "\t\tOUTPUT_COLLISION_MAX_RADIUS,",
            "lineNumber": 362
          },
          {
            "text": "\t\tOUTPUT_COLLISION_STEP",
            "lineNumber": 363
          },
          {
            "text": "\t);",
            "lineNumber": 364
          },
          {
            "text": "\tconst greenColor = settings.colorGreen;",
            "lineNumber": 365
          },
          {
            "lineNumber": 366
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 367
          },
          {
            "text": "\t\tconst outNode = getNodeById(data, outId);",
            "lineNumber": 368
          },
          {
            "text": "\t\tif (outNode &amp;&amp; isTextNode(outNode)) {",
            "lineNumber": 369
          },
          {
            "text": "\t\t\tconst updated = {",
            "lineNumber": 370
          },
          {
            "text": "\t\t\t\t...(outNode as CanvasTextData),",
            "lineNumber": 371
          },
          {
            "text": "\t\t\t\ttext,",
            "lineNumber": 372
          },
          {
            "text": "\t\t\t\tx: chosenX,",
            "lineNumber": 373
          },
          {
            "text": "\t\t\t\ty,",
            "lineNumber": 374
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 375
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 376
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 377
          },
          {
            "text": "\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);",
            "lineNumber": 378
          },
          {
            "text": "\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 379
          },
          {
            "text": "\t\t} else if (outNode) {",
            "lineNumber": 380
          },
          {
            "text": "\t\t\t(outNode as { x: number; y: number }).x = chosenX;",
            "lineNumber": 381
          },
          {
            "text": "\t\t\t(outNode as { x: number; y: number }).y = y;",
            "lineNumber": 382
          },
          {
            "text": "\t\t}",
            "lineNumber": 383
          },
          {
            "text": "\t\tconst hasOutputEdge = data.edges.some(",
            "lineNumber": 384
          },
          {
            "text": "\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 385
          },
          {
            "text": "\t\t);",
            "lineNumber": 386
          },
          {
            "text": "\t\tif (!hasOutputEdge) {",
            "lineNumber": 387
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 388
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 389
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 390
          },
          {
            "text": "\t\t\t\ttoNode: outId,",
            "lineNumber": 391
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 392
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 393
          },
          {
            "text": "\t\t}",
            "lineNumber": 394
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 395
          },
          {
            "text": "\t}",
            "lineNumber": 396
          },
          {
            "lineNumber": 397
          },
          {
            "text": "\tconst newNodeId = randomId();",
            "lineNumber": 398
          },
          {
            "text": "\tconst newTextNode: CanvasTextData = {",
            "lineNumber": 399
          },
          {
            "text": "\t\tid: newNodeId,",
            "lineNumber": 400
          },
          {
            "text": "\t\ttype: \"text\",",
            "lineNumber": 401
          },
          {
            "text": "\t\ttext,",
            "lineNumber": 402
          },
          {
            "text": "\t\tx: chosenX,",
            "lineNumber": 403
          },
          {
            "text": "\t\ty,",
            "lineNumber": 404
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 405
          },
          {
            "text": "\t\theight,",
            "lineNumber": 406
          },
          {
            "text": "\t\tcolor: greenColor,",
            "lineNumber": 407
          },
          {
            "text": "\t};",
            "lineNumber": 408
          },
          {
            "text": "\tdata.nodes.push(newTextNode);",
            "lineNumber": 409
          },
          {
            "text": "\tdata.edges.push({",
            "lineNumber": 410
          },
          {
            "text": "\t\tid: randomId(),",
            "lineNumber": 411
          },
          {
            "text": "\t\tfromNode: sourceNode.id,",
            "lineNumber": 412
          },
          {
            "text": "\t\ttoNode: newNodeId,",
            "lineNumber": 413
          },
          {
            "text": "\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 414
          },
          {
            "text": "\t});",
            "lineNumber": 415
          },
          {
            "text": "}",
            "lineNumber": 416,
            "isSignature": true
          },
          {
            "lineNumber": 417
          },
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 418
          }
        ]
      },
      "score": 0.3730762004852295
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 298,
            "column": 1
          },
          "endPosition": {
            "line": 339,
            "column": 1
          }
        },
        "contents": "/** Choose an x for the output box to avoid overlapping other nodes; tries defaultX then right then left within maxRadius. */\nfunction chooseOutputPosition(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\toutNodeId: string | null,\n\tdefaultX: number,\n\ty: number,\n\twidth: number,\n\theight: number,\n\tmaxRadius: number,\n\tstep: number\n): number {\n\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);\n\tif (outNodeId) excludeIds.add(outNodeId);\n\tconst box = { x: 0, y, width, height };\n\tfunction tryX(x: number): boolean {\n\t\tbox.x = x;\n\t\tfor (const node of data.nodes) {\n\t\t\tif (excludeIds.has(node.id)) continue;\n\t\t\tif (rectanglesOverlap(box, { x: node.x, y: node.y, width: node.width, height: node.height })) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tif (tryX(defaultX)) return defaultX;\n\tfor (let offset = step; offset &lt;= maxRadius; offset += step) {\n\t\tif (tryX(defaultX + offset)) return defaultX + offset;\n\t\tif (tryX(defaultX - offset)) return defaultX - offset;\n\t}\n\treturn defaultX;\n}\n\n/** Generate a unique id for new canvas nodes/edges. */\nfunction randomId(): string {\n\tif\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Choose an x for the output box to avoid overlapping other nodes; tries defaultX then right then left within maxRadius. */",
            "lineNumber": 301
          },
          {
            "text": "function chooseOutputPosition(",
            "lineNumber": 302,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 303,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 304,
            "isSignature": true
          },
          {
            "text": "\toutNodeId: string | null,",
            "lineNumber": 305,
            "isSignature": true
          },
          {
            "text": "\tdefaultX: number,",
            "lineNumber": 306,
            "isSignature": true
          },
          {
            "text": "\ty: number,",
            "lineNumber": 307,
            "isSignature": true
          },
          {
            "text": "\twidth: number,",
            "lineNumber": 308,
            "isSignature": true
          },
          {
            "text": "\theight: number,",
            "lineNumber": 309,
            "isSignature": true
          },
          {
            "text": "\tmaxRadius: number,",
            "lineNumber": 310,
            "isSignature": true
          },
          {
            "text": "\tstep: number",
            "lineNumber": 311,
            "isSignature": true
          },
          {
            "text": "): number {",
            "lineNumber": 312,
            "isSignature": true
          },
          {
            "text": "\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);",
            "lineNumber": 313
          },
          {
            "text": "\tif (outNodeId) excludeIds.add(outNodeId);",
            "lineNumber": 314
          },
          {
            "text": "\tconst box = { x: 0, y, width, height };",
            "lineNumber": 315
          },
          {
            "text": "\tfunction tryX(x: number): boolean {",
            "lineNumber": 316,
            "isSignature": true
          },
          {
            "text": "\t\tbox.x = x;",
            "lineNumber": 317
          },
          {
            "text": "\t\tfor (const node of data.nodes) {",
            "lineNumber": 318
          },
          {
            "text": "\t\t\tif (excludeIds.has(node.id)) continue;",
            "lineNumber": 319
          },
          {
            "text": "\t\t\tif (rectanglesOverlap(box, { x: node.x, y: node.y, width: node.width, height: node.height })) {",
            "lineNumber": 320
          },
          {
            "text": "\t\t\t\treturn false;",
            "lineNumber": 321
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 322
          },
          {
            "text": "\t\t}",
            "lineNumber": 323
          },
          {
            "text": "\t\treturn true;",
            "lineNumber": 324
          },
          {
            "text": "\t}",
            "lineNumber": 325,
            "isSignature": true
          },
          {
            "text": "\tif (tryX(defaultX)) return defaultX;",
            "lineNumber": 326
          },
          {
            "text": "\tfor (let offset = step; offset &lt;= maxRadius; offset += step) {",
            "lineNumber": 327
          },
          {
            "text": "\t\tif (tryX(defaultX + offset)) return defaultX + offset;",
            "lineNumber": 328
          },
          {
            "text": "\t\tif (tryX(defaultX - offset)) return defaultX - offset;",
            "lineNumber": 329
          },
          {
            "text": "\t}",
            "lineNumber": 330
          },
          {
            "text": "\treturn defaultX;",
            "lineNumber": 331
          },
          {
            "text": "}",
            "lineNumber": 332,
            "isSignature": true
          },
          {
            "lineNumber": 333
          },
          {
            "text": "/** Generate a unique id for new canvas nodes/edges. */",
            "lineNumber": 334
          },
          {
            "text": "function randomId(): string {",
            "lineNumber": 335,
            "isSignature": true
          },
          {
            "text": "\tif",
            "lineNumber": 336
          },
          {
            "text": "}",
            "lineNumber": 340,
            "isSignature": true
          }
        ]
      },
      "score": 0.3351750075817108
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 118,
            "column": 37
          },
          "endPosition": {
            "line": 145,
            "column": 1
          }
        },
        "contents": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */\nexport function findOutputNodeForSource(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\tsettings: ZettelPluginSettings\n): string | null {\n\tconst outputEdge = data.edges.find(\n\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t);\n\tif (outputEdge) return outputEdge.toNode;\n\tconst source = getNodeById(data, sourceNodeId);\n\tif (!source) return null;\n\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);\n\tif (!greenColor) return null;\n\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;\n\tconst tolerance = 30; // allow small layout drift\n\tfor (const node of data.nodes) {\n\t\tif (node.id === sourceNodeId) continue;\n\t\tif (normalizeColor(node.color) !== greenColor) continue;\n\t\t// Same x (or close), and y at or near expected\n\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;\n\t\tif (node.y &lt; expectedY - tolerance || node.y &gt; expectedY + tolerance) continue;\n\t\treturn node.id;\n\t}\n\treturn null;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
            "lineNumber": 121
          },
          {
            "text": "export function findOutputNodeForSource(",
            "lineNumber": 122,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 123,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 124,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 125,
            "isSignature": true
          },
          {
            "text": "): string | null {",
            "lineNumber": 126,
            "isSignature": true
          },
          {
            "text": "\tconst outputEdge = data.edges.find(",
            "lineNumber": 127
          },
          {
            "text": "\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 128
          },
          {
            "text": "\t);",
            "lineNumber": 129
          },
          {
            "text": "\tif (outputEdge) return outputEdge.toNode;",
            "lineNumber": 130
          },
          {
            "text": "\tconst source = getNodeById(data, sourceNodeId);",
            "lineNumber": 131
          },
          {
            "text": "\tif (!source) return null;",
            "lineNumber": 132
          },
          {
            "text": "\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);",
            "lineNumber": 133
          },
          {
            "text": "\tif (!greenColor) return null;",
            "lineNumber": 134
          },
          {
            "text": "\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;",
            "lineNumber": 135
          },
          {
            "text": "\tconst tolerance = 30; // allow small layout drift",
            "lineNumber": 136
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 137
          },
          {
            "text": "\t\tif (node.id === sourceNodeId) continue;",
            "lineNumber": 138
          },
          {
            "text": "\t\tif (normalizeColor(node.color) !== greenColor) continue;",
            "lineNumber": 139
          },
          {
            "text": "\t\t// Same x (or close), and y at or near expected",
            "lineNumber": 140
          },
          {
            "text": "\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;",
            "lineNumber": 141
          },
          {
            "text": "\t\tif (node.y &lt; expectedY - tolerance || node.y &gt; expectedY + tolerance) continue;",
            "lineNumber": 142
          },
          {
            "text": "\t\treturn node.id;",
            "lineNumber": 143
          },
          {
            "text": "\t}",
            "lineNumber": 144
          },
          {
            "text": "\treturn null;",
            "lineNumber": 145
          },
          {
            "text": "}",
            "lineNumber": 146,
            "isSignature": true
          }
        ]
      },
      "score": 0.2849167585372925
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 187
          },
          "endPosition": {
            "line": 281,
            "column": 1
          }
        },
        "contents": "async function updateEdgeLabelsAndSave(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tedgeModes: Map&lt;string, EdgeInputMode&gt;,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\n}\n\n/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */\nasync function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return \"\";\n\tconst role = getNodeRole(node, settings);\n\tif (!role || role === \"yellow\" || role === \"green\") {\n\t\t// Yellow: pass-through (use node content as result)\n\t\tif (role === \"yellow\") {\n\t\t\tconst content = await getNodeContent(node, app.vault);\n\t\t\tsetNodeResult(canvasKey, nodeId, content);\n\t\t\treturn content;\n\t\t}\n\t\treturn \"\";\n\t}\n\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\tconst nodeInput = await getNodeContent(node, app.vault);\n\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(\n\t\tcanvasKey,\n\t\tnodeInput,\n\t\tincoming\n\t);\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"purple\") {\n\t\tconst model = settings.ollamaPurpleModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"red\") {\n\t\tconst model = settings.ollamaRedModel || \"llama2\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "async function updateEdgeLabelsAndSave(",
            "lineNumber": 188,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 189,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 190,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 191,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 192,
            "isSignature": true
          },
          {
            "text": "\tedgeModes: Map&lt;string, EdgeInputMode&gt;,",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 195,
            "isSignature": true
          },
          {
            "lineNumber": 214
          },
          {
            "text": "}",
            "lineNumber": 215,
            "isSignature": true
          },
          {
            "lineNumber": 216
          },
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 217
          },
          {
            "text": "async function runSingleNode(",
            "lineNumber": 218,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 219,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 220,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 221,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 222,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 223,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 224,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 225,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 226,
            "isSignature": true
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 227
          },
          {
            "text": "\tif (!node) return \"\";",
            "lineNumber": 228
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 229
          },
          {
            "text": "\tif (!role || role === \"yellow\" || role === \"green\") {",
            "lineNumber": 230
          },
          {
            "text": "\t\t// Yellow: pass-through (use node content as result)",
            "lineNumber": 231
          },
          {
            "text": "\t\tif (role === \"yellow\") {",
            "lineNumber": 232
          },
          {
            "text": "\t\t\tconst content = await getNodeContent(node, app.vault);",
            "lineNumber": 233
          },
          {
            "text": "\t\t\tsetNodeResult(canvasKey, nodeId, content);",
            "lineNumber": 234
          },
          {
            "text": "\t\t\treturn content;",
            "lineNumber": 235
          },
          {
            "text": "\t\t}",
            "lineNumber": 236
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 237
          },
          {
            "text": "\t}",
            "lineNumber": 238
          },
          {
            "text": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 239
          },
          {
            "text": "\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 240
          },
          {
            "text": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(",
            "lineNumber": 241
          },
          {
            "text": "\t\tcanvasKey,",
            "lineNumber": 242
          },
          {
            "text": "\t\tnodeInput,",
            "lineNumber": 243
          },
          {
            "text": "\t\tincoming",
            "lineNumber": 244
          },
          {
            "text": "\t);",
            "lineNumber": 245
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 246
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 247
          },
          {
            "lineNumber": 248
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 249
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 250
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 251
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 252
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 253
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 254
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 255
          },
          {
            "text": "\t}",
            "lineNumber": 256
          },
          {
            "text": "\tif (role === \"purple\") {",
            "lineNumber": 257
          },
          {
            "text": "\t\tconst model = settings.ollamaPurpleModel || \"llama2\";",
            "lineNumber": 258
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 259
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 260
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 261
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 262
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 263
          },
          {
            "text": "\t}",
            "lineNumber": 264
          },
          {
            "text": "\tif (role === \"red\") {",
            "lineNumber": 265
          },
          {
            "text": "\t\tconst model = settings.ollamaRedModel || \"llama2\";",
            "lineNumber": 266
          },
          {
            "text": "}",
            "lineNumber": 282,
            "isSignature": true
          }
        ]
      },
      "score": 0.21551764011383057
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 228
          },
          "endPosition": {
            "line": 329,
            "column": 1
          }
        },
        "contents": "export async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\n\tfor (const edge of data.edges) {\n\t\tif (isOutputEdge(edge)) continue;\n\t\tconst isRunning = runningNodeId != null &amp;&amp; edge.toNode === runningNodeId;\n\t\tconst mode = getEdgeMode(canvasKey, edge.id);\n\t\tconst state: EdgeDisplayState | null = isRunning\n\t\t\t? \"running\"\n\t\t\t: mode === \"inject\"\n\t\t\t\t? \"inject\"\n\t\t\t\t: mode === \"concatenate\"\n\t\t\t\t\t? \"concatenate\"\n\t\t\t\t\t: null;\n\t\tif (!state) continue;\n\t\tconst fromEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);\n\t\tconst toEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);\n\t\tif (!fromEl || !toEl) continue;\n\t\tconst fromCenter = getElCenter(fromEl);\n\t\tconst toCenter = getElCenter(toEl);\n\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;\n\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;\n\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);\n\t\tif (!pathEl) continue;\n\t\tconst group = pathEl.closest(\"g\");\n\t\tif (!group) continue;\n\t\tconst mid = getPathMidpointSvg(pathEl);\n\t\tconst labelGroup = document.createElementNS(SVG_NS, \"g\");\n\t\tlabelGroup.setAttribute(\"class\", EDGE_MODE_SVG_LABEL_CLASS);\n\t\tlabelGroup.setAttribute(EDGE_MODE_DATA_ATTR, edge.id);\n\t\tlabelGroup.setAttribute(EDGE_MODE_STATE_ATTR, state);\n\t\tlabelGroup.setAttribute(\"transform\", &#96;translate(${mid.x}, ${mid.y + Y_OFFSET_BELOW_PATH})&#96;);\n\t\tlabelGroup.setAttribute(\"style\", \"z-index: 100; isolation: isolate;\");\n\t\tconst textContent =\n\t\t\tstate === \"running\" ? \"…\" : state === \"inject\" ? \"(injected)\" : \"(concatenated)\";\n\t\tlet textX = 0;\n\t\tconst fontSize = state === \"running\" ? FONT_SIZE_RUNNING : FONT_SIZE;\n\t\tif (state === \"running\") {\n\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 229,
                "column": 1
              },
              "endPosition": {
                "line": 229,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 229,
                "column": 8
              },
              "endPosition": {
                "line": 236,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 235,
            "isSignature": true
          },
          {
            "lineNumber": 252
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 253
          },
          {
            "text": "\t\tif (isOutputEdge(edge)) continue;",
            "lineNumber": 254
          },
          {
            "text": "\t\tconst isRunning = runningNodeId != null &amp;&amp; edge.toNode === runningNodeId;",
            "lineNumber": 255
          },
          {
            "text": "\t\tconst mode = getEdgeMode(canvasKey, edge.id);",
            "lineNumber": 256
          },
          {
            "text": "\t\tconst state: EdgeDisplayState | null = isRunning",
            "lineNumber": 257
          },
          {
            "text": "\t\t\t? \"running\"",
            "lineNumber": 258
          },
          {
            "text": "\t\t\t: mode === \"inject\"",
            "lineNumber": 259
          },
          {
            "text": "\t\t\t\t? \"inject\"",
            "lineNumber": 260
          },
          {
            "text": "\t\t\t\t: mode === \"concatenate\"",
            "lineNumber": 261
          },
          {
            "text": "\t\t\t\t\t? \"concatenate\"",
            "lineNumber": 262
          },
          {
            "text": "\t\t\t\t\t: null;",
            "lineNumber": 263
          },
          {
            "text": "\t\tif (!state) continue;",
            "lineNumber": 264
          },
          {
            "text": "\t\tconst fromEl =",
            "lineNumber": 265
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||",
            "lineNumber": 266
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);",
            "lineNumber": 267
          },
          {
            "text": "\t\tconst toEl =",
            "lineNumber": 268
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||",
            "lineNumber": 269
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);",
            "lineNumber": 270
          },
          {
            "text": "\t\tif (!fromEl || !toEl) continue;",
            "lineNumber": 271
          },
          {
            "text": "\t\tconst fromCenter = getElCenter(fromEl);",
            "lineNumber": 272
          },
          {
            "text": "\t\tconst toCenter = getElCenter(toEl);",
            "lineNumber": 273
          },
          {
            "text": "\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;",
            "lineNumber": 274
          },
          {
            "text": "\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;",
            "lineNumber": 275
          },
          {
            "text": "\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);",
            "lineNumber": 276
          },
          {
            "text": "\t\tif (!pathEl) continue;",
            "lineNumber": 277
          },
          {
            "text": "\t\tconst group = pathEl.closest(\"g\");",
            "lineNumber": 278
          },
          {
            "text": "\t\tif (!group) continue;",
            "lineNumber": 279
          },
          {
            "text": "\t\tconst mid = getPathMidpointSvg(pathEl);",
            "lineNumber": 280
          },
          {
            "text": "\t\tconst labelGroup = document.createElementNS(SVG_NS, \"g\");",
            "lineNumber": 281
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"class\", EDGE_MODE_SVG_LABEL_CLASS);",
            "lineNumber": 282
          },
          {
            "text": "\t\tlabelGroup.setAttribute(EDGE_MODE_DATA_ATTR, edge.id);",
            "lineNumber": 283
          },
          {
            "text": "\t\tlabelGroup.setAttribute(EDGE_MODE_STATE_ATTR, state);",
            "lineNumber": 284
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"transform\", &#96;translate(${mid.x}, ${mid.y + Y_OFFSET_BELOW_PATH})&#96;);",
            "lineNumber": 285
          },
          {
            "text": "\t\tlabelGroup.setAttribute(\"style\", \"z-index: 100; isolation: isolate;\");",
            "lineNumber": 286
          },
          {
            "text": "\t\tconst textContent =",
            "lineNumber": 287
          },
          {
            "text": "\t\t\tstate === \"running\" ? \"…\" : state === \"inject\" ? \"(injected)\" : \"(concatenated)\";",
            "lineNumber": 288
          },
          {
            "text": "\t\tlet textX = 0;",
            "lineNumber": 289
          },
          {
            "text": "\t\tconst fontSize = state === \"running\" ? FONT_SIZE_RUNNING : FONT_SIZE;",
            "lineNumber": 290
          },
          {
            "text": "\t\tif (state === \"running\") {",
            "lineNumber": 291
          },
          {
            "text": "\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");",
            "lineNumber": 292
          },
          {
            "text": "}",
            "lineNumber": 330,
            "isSignature": true
          }
        ]
      },
      "score": 0.21444599330425262
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 228
          },
          "endPosition": {
            "line": 329,
            "column": 1
          }
        },
        "contents": "export async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\n\t\tif (state === \"running\") {\n\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");\n\t\t\tcircle.setAttribute(\"class\", EDGE_MODE_ICON_CLASS);\n\t\t\tcircle.setAttribute(\"cx\", String(DOT_R_RUNNING + 2));\n\t\t\tcircle.setAttribute(\"cy\", String(fontSize * 0.4));\n\t\t\tcircle.setAttribute(\"r\", String(DOT_R_RUNNING));\n\t\t\tlabelGroup.appendChild(circle);\n\t\t\ttextX = DOT_R_RUNNING * 2 + DOT_TEXT_GAP;\n\t\t}\n\t\tconst textEl = document.createElementNS(SVG_NS, \"text\");\n\t\ttextEl.setAttribute(\"class\", EDGE_MODE_LABEL_CLASS);\n\t\ttextEl.setAttribute(\"x\", String(textX));\n\t\ttextEl.setAttribute(\"y\", String(fontSize * 0.35));\n\t\ttextEl.setAttribute(\"font-size\", String(fontSize));\n\t\ttextEl.setAttribute(\"text-anchor\", \"start\");\n\t\ttextEl.setAttribute(\"dominant-baseline\", \"central\");\n\t\ttextEl.textContent = textContent;\n\t\tlabelGroup.appendChild(textEl);\n\t\tgroup.appendChild(labelGroup);\n\t}\n\t// Mark output edges so their label can be styled smaller/grayed\n\tfor (const edge of data.edges) {\n\t\tif (!isOutputEdge(edge)) continue;\n\t\tconst fromEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);\n\t\tconst toEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||\n\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);\n\t\tif (!fromEl || !toEl) continue;\n\t\tconst fromCenter = getElCenter(fromEl);\n\t\tconst toCenter = getElCenter(toEl);\n\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;\n\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;\n\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);\n\t\tif (!pathEl) continue;\n\t\tconst group = pathEl.closest(\"g\");\n\t\tif (group) group.classList.add(OUTPUT_EDGE_GROUP_CLASS);\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 229,
                "column": 1
              },
              "endPosition": {
                "line": 229,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 229,
                "column": 8
              },
              "endPosition": {
                "line": 236,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 235,
            "isSignature": true
          },
          {
            "lineNumber": 290
          },
          {
            "text": "\t\tif (state === \"running\") {",
            "lineNumber": 291
          },
          {
            "text": "\t\t\tconst circle = document.createElementNS(SVG_NS, \"circle\");",
            "lineNumber": 292
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"class\", EDGE_MODE_ICON_CLASS);",
            "lineNumber": 293
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"cx\", String(DOT_R_RUNNING + 2));",
            "lineNumber": 294
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"cy\", String(fontSize * 0.4));",
            "lineNumber": 295
          },
          {
            "text": "\t\t\tcircle.setAttribute(\"r\", String(DOT_R_RUNNING));",
            "lineNumber": 296
          },
          {
            "text": "\t\t\tlabelGroup.appendChild(circle);",
            "lineNumber": 297
          },
          {
            "text": "\t\t\ttextX = DOT_R_RUNNING * 2 + DOT_TEXT_GAP;",
            "lineNumber": 298
          },
          {
            "text": "\t\t}",
            "lineNumber": 299
          },
          {
            "text": "\t\tconst textEl = document.createElementNS(SVG_NS, \"text\");",
            "lineNumber": 300
          },
          {
            "text": "\t\ttextEl.setAttribute(\"class\", EDGE_MODE_LABEL_CLASS);",
            "lineNumber": 301
          },
          {
            "text": "\t\ttextEl.setAttribute(\"x\", String(textX));",
            "lineNumber": 302
          },
          {
            "text": "\t\ttextEl.setAttribute(\"y\", String(fontSize * 0.35));",
            "lineNumber": 303
          },
          {
            "text": "\t\ttextEl.setAttribute(\"font-size\", String(fontSize));",
            "lineNumber": 304
          },
          {
            "text": "\t\ttextEl.setAttribute(\"text-anchor\", \"start\");",
            "lineNumber": 305
          },
          {
            "text": "\t\ttextEl.setAttribute(\"dominant-baseline\", \"central\");",
            "lineNumber": 306
          },
          {
            "text": "\t\ttextEl.textContent = textContent;",
            "lineNumber": 307
          },
          {
            "text": "\t\tlabelGroup.appendChild(textEl);",
            "lineNumber": 308
          },
          {
            "text": "\t\tgroup.appendChild(labelGroup);",
            "lineNumber": 309
          },
          {
            "text": "\t}",
            "lineNumber": 310
          },
          {
            "text": "\t// Mark output edges so their label can be styled smaller/grayed",
            "lineNumber": 311
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 312
          },
          {
            "text": "\t\tif (!isOutputEdge(edge)) continue;",
            "lineNumber": 313
          },
          {
            "text": "\t\tconst fromEl =",
            "lineNumber": 314
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.fromNode)) ||",
            "lineNumber": 315
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.fromNode);",
            "lineNumber": 316
          },
          {
            "text": "\t\tconst toEl =",
            "lineNumber": 317
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, edge.toNode)) ||",
            "lineNumber": 318
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, edge.toNode);",
            "lineNumber": 319
          },
          {
            "text": "\t\tif (!fromEl || !toEl) continue;",
            "lineNumber": 320
          },
          {
            "text": "\t\tconst fromCenter = getElCenter(fromEl);",
            "lineNumber": 321
          },
          {
            "text": "\t\tconst toCenter = getElCenter(toEl);",
            "lineNumber": 322
          },
          {
            "text": "\t\tconst targetViewportX = (fromCenter.x + toCenter.x) / 2;",
            "lineNumber": 323
          },
          {
            "text": "\t\tconst targetViewportY = (fromCenter.y + toCenter.y) / 2;",
            "lineNumber": 324
          },
          {
            "text": "\t\tconst pathEl = findPathForEdge(containerEl, targetViewportX, targetViewportY);",
            "lineNumber": 325
          },
          {
            "text": "\t\tif (!pathEl) continue;",
            "lineNumber": 326
          },
          {
            "text": "\t\tconst group = pathEl.closest(\"g\");",
            "lineNumber": 327
          },
          {
            "text": "\t\tif (group) group.classList.add(OUTPUT_EDGE_GROUP_CLASS);",
            "lineNumber": 328
          },
          {
            "text": "\t}",
            "lineNumber": 329
          },
          {
            "text": "}",
            "lineNumber": 330,
            "isSignature": true
          }
        ]
      },
      "score": 0.19869863986968994
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 281,
            "column": 1
          },
          "endPosition": {
            "line": 300,
            "column": 125
          }
        },
        "contents": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */\nconst OUTPUT_COLLISION_MAX_RADIUS = 500;\n/** Step (px) between candidate x positions when avoiding collisions. */\nconst OUTPUT_COLLISION_STEP = 80;\n\nfunction rectanglesOverlap(\n\ta: { x: number; y: number; width: number; height: number },\n\tb: { x: number; y: number; width: number; height: number }\n): boolean {\n\treturn !(\n\t\ta.x + a.width &lt;= b.x ||\n\t\tb.x + b.width &lt;= a.x ||\n\t\ta.y + a.height &lt;= b.y ||\n\t\tb.y + b.height &lt;= a.y\n\t);\n}\n\n/** Choose an x for the output box to avoid overlapping other nodes; tries defaultX then right then left within maxRadius. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
            "lineNumber": 284
          },
          {
            "text": "const OUTPUT_COLLISION_MAX_RADIUS = 500;",
            "lineNumber": 285
          },
          {
            "text": "/** Step (px) between candidate x positions when avoiding collisions. */",
            "lineNumber": 286
          },
          {
            "text": "const OUTPUT_COLLISION_STEP = 80;",
            "lineNumber": 287
          },
          {
            "lineNumber": 288
          },
          {
            "text": "function rectanglesOverlap(",
            "lineNumber": 289,
            "isSignature": true
          },
          {
            "text": "\ta: { x: number; y: number; width: number; height: number },",
            "lineNumber": 290,
            "isSignature": true
          },
          {
            "text": "\tb: { x: number; y: number; width: number; height: number }",
            "lineNumber": 291,
            "isSignature": true
          },
          {
            "text": "): boolean {",
            "lineNumber": 292,
            "isSignature": true
          },
          {
            "text": "\treturn !(",
            "lineNumber": 293
          },
          {
            "text": "\t\ta.x + a.width &lt;= b.x ||",
            "lineNumber": 294
          },
          {
            "text": "\t\tb.x + b.width &lt;= a.x ||",
            "lineNumber": 295
          },
          {
            "text": "\t\ta.y + a.height &lt;= b.y ||",
            "lineNumber": 296
          },
          {
            "text": "\t\tb.y + b.height &lt;= a.y",
            "lineNumber": 297
          },
          {
            "text": "\t);",
            "lineNumber": 298
          },
          {
            "text": "}",
            "lineNumber": 299,
            "isSignature": true
          },
          {
            "lineNumber": 300
          },
          {
            "text": "/** Choose an x for the output box to avoid overlapping other nodes; tries defaultX then right then left within maxRadius. */",
            "lineNumber": 301
          }
        ]
      },
      "score": 0.19565176963806152
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 35,
            "column": 57
          },
          "endPosition": {
            "line": 40,
            "column": 83
          }
        },
        "contents": "/** Reserved edge label from run node to its green output note; not a variable name. */\nexport const EDGE_LABEL_OUTPUT = \"output\";\n\n/** Parse variable name from edge label; ignore anything in brackets at the end. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Reserved edge label from run node to its green output note; not a variable name. */",
            "lineNumber": 38
          },
          {
            "text": "export const EDGE_LABEL_OUTPUT = \"output\";",
            "lineNumber": 39
          },
          {
            "lineNumber": 40
          },
          {
            "text": "/** Parse variable name from edge label; ignore anything in brackets at the end. */",
            "lineNumber": 41
          }
        ]
      },
      "score": 0.18769919872283936
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 217
          },
          "endPosition": {
            "line": 283,
            "column": 99
          }
        },
        "contents": "async function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\n\tif (role === \"red\") {\n\t\tconst model = settings.ollamaRedModel || \"llama2\";\n\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\tif (role === \"blue\") {\n\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);\n\t\tconst result = await kernel.run(template, concatenatedPart);\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\treturn \"\";\n}\n\n/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 218,
                "column": 1
              },
              "endPosition": {
                "line": 227,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "async function runSingleNode(",
            "lineNumber": 218,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 219,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 220,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 221,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 222,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 223,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 224,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 225,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 226,
            "isSignature": true
          },
          {
            "lineNumber": 264
          },
          {
            "text": "\tif (role === \"red\") {",
            "lineNumber": 265
          },
          {
            "text": "\t\tconst model = settings.ollamaRedModel || \"llama2\";",
            "lineNumber": 266
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({ model, prompt: fullPrompt, stream: false });",
            "lineNumber": 267
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 268
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 269
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 270
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 271
          },
          {
            "text": "\t}",
            "lineNumber": 272
          },
          {
            "text": "\tif (role === \"blue\") {",
            "lineNumber": 273
          },
          {
            "text": "\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);",
            "lineNumber": 274
          },
          {
            "text": "\t\tconst result = await kernel.run(template, concatenatedPart);",
            "lineNumber": 275
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 276
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 277
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 278
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 279
          },
          {
            "text": "\t}",
            "lineNumber": 280
          },
          {
            "text": "\treturn \"\";",
            "lineNumber": 281
          },
          {
            "text": "}",
            "lineNumber": 282,
            "isSignature": true
          },
          {
            "lineNumber": 283
          },
          {
            "text": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
            "lineNumber": 284
          }
        ]
      },
      "score": 0.17288005352020264
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.test.ts",
        "range": {
          "startPosition": {
            "line": 188,
            "column": 3
          },
          "endPosition": {
            "line": 234,
            "column": 1
          }
        },
        "contents": "describe(\"findOutputNodeForSource\", () =&gt; {\n\tconst settings = { ...DEFAULT_SETTINGS, colorGreen: \"5\" };\n\n\tit(\"returns null when source node not found\", () =&gt; {\n\t\tconst data: CanvasData = { nodes: [], edges: [] };\n\t\texpect(findOutputNodeForSource(data, \"missing\", settings)).toBeNull();\n\t});\n\tit(\"returns green node id when it sits below source within tolerance\", () =&gt; {\n\t\tconst sourceY = 100;\n\t\tconst greenY = sourceY + 50 + GREEN_NODE_PADDING; // 170\n\t\tconst data: CanvasData = {\n\t\t\tnodes: [\n\t\t\t\t{ id: \"src\", x: 10, y: sourceY, width: 200, height: 50, type: \"text\", text: \"\", color: \"1\" },\n\t\t\t\t{ id: \"out\", x: 10, y: greenY, width: 200, height: 100, type: \"text\", text: \"\", color: \"5\" },\n\t\t\t],\n\t\t\tedges: [],\n\t\t};\n\t\texpect(findOutputNodeForSource(data, \"src\", settings)).toBe(\"out\");\n\t});\n\tit(\"returns null when no green node in expected position\", () =&gt; {\n\t\tconst data: CanvasData = {\n\t\t\tnodes: [{ id: \"src\", x: 0, y: 0, width: 100, height: 50, type: \"text\", text: \"\", color: \"1\" }],\n\t\t\tedges: [],\n\t\t};\n\t\texpect(findOutputNodeForSource(data, \"src\", settings)).toBeNull();\n\t});\n\tit(\"returns toNode when edge from source has label output\", () =&gt; {\n\t\tconst data: CanvasData = {\n\t\t\tnodes: [\n\t\t\t\t{ id: \"src\", x: 0, y: 0, width: 100, height: 50, type: \"text\", text: \"\", color: \"1\" },\n\t\t\t\t{ id: \"out\", x: 0, y: 200, width: 100, height: 50, type: \"text\", text: \"\", color: \"5\" },\n\t\t\t],\n\t\t\tedges: [\n\t\t\t\t{ id: \"e1\", fromNode: \"src\", toNode: \"out\", label: EDGE_LABEL_OUTPUT },\n\t\t\t],\n\t\t};\n\t\texpect(findOutputNodeForSource(data, \"src\", settings)).toBe(\"out\");\n\t});\n});\n\ndescribe(\"GREEN_NODE_PADDING\", () =&gt; {\n\tit\n\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "describe(\"findOutputNodeForSource\", () =&gt; {",
            "lineNumber": 191
          },
          {
            "text": "\tconst settings = { ...DEFAULT_SETTINGS, colorGreen: \"5\" };",
            "lineNumber": 192
          },
          {
            "lineNumber": 193
          },
          {
            "text": "\tit(\"returns null when source node not found\", () =&gt; {",
            "lineNumber": 194
          },
          {
            "text": "\t\tconst data: CanvasData = { nodes: [], edges: [] };",
            "lineNumber": 195
          },
          {
            "text": "\t\texpect(findOutputNodeForSource(data, \"missing\", settings)).toBeNull();",
            "lineNumber": 196
          },
          {
            "text": "\t});",
            "lineNumber": 197
          },
          {
            "text": "\tit(\"returns green node id when it sits below source within tolerance\", () =&gt; {",
            "lineNumber": 198
          },
          {
            "text": "\t\tconst sourceY = 100;",
            "lineNumber": 199
          },
          {
            "text": "\t\tconst greenY = sourceY + 50 + GREEN_NODE_PADDING; // 170",
            "lineNumber": 200
          },
          {
            "text": "\t\tconst data: CanvasData = {",
            "lineNumber": 201
          },
          {
            "text": "\t\t\tnodes: [",
            "lineNumber": 202
          },
          {
            "text": "\t\t\t\t{ id: \"src\", x: 10, y: sourceY, width: 200, height: 50, type: \"text\", text: \"\", color: \"1\" },",
            "lineNumber": 203
          },
          {
            "text": "\t\t\t\t{ id: \"out\", x: 10, y: greenY, width: 200, height: 100, type: \"text\", text: \"\", color: \"5\" },",
            "lineNumber": 204
          },
          {
            "text": "\t\t\t],",
            "lineNumber": 205
          },
          {
            "text": "\t\t\tedges: [],",
            "lineNumber": 206
          },
          {
            "text": "\t\t};",
            "lineNumber": 207
          },
          {
            "text": "\t\texpect(findOutputNodeForSource(data, \"src\", settings)).toBe(\"out\");",
            "lineNumber": 208
          },
          {
            "text": "\t});",
            "lineNumber": 209
          },
          {
            "text": "\tit(\"returns null when no green node in expected position\", () =&gt; {",
            "lineNumber": 210
          },
          {
            "text": "\t\tconst data: CanvasData = {",
            "lineNumber": 211
          },
          {
            "text": "\t\t\tnodes: [{ id: \"src\", x: 0, y: 0, width: 100, height: 50, type: \"text\", text: \"\", color: \"1\" }],",
            "lineNumber": 212
          },
          {
            "text": "\t\t\tedges: [],",
            "lineNumber": 213
          },
          {
            "text": "\t\t};",
            "lineNumber": 214
          },
          {
            "text": "\t\texpect(findOutputNodeForSource(data, \"src\", settings)).toBeNull();",
            "lineNumber": 215
          },
          {
            "text": "\t});",
            "lineNumber": 216
          },
          {
            "text": "\tit(\"returns toNode when edge from source has label output\", () =&gt; {",
            "lineNumber": 217
          },
          {
            "text": "\t\tconst data: CanvasData = {",
            "lineNumber": 218
          },
          {
            "text": "\t\t\tnodes: [",
            "lineNumber": 219
          },
          {
            "text": "\t\t\t\t{ id: \"src\", x: 0, y: 0, width: 100, height: 50, type: \"text\", text: \"\", color: \"1\" },",
            "lineNumber": 220
          },
          {
            "text": "\t\t\t\t{ id: \"out\", x: 0, y: 200, width: 100, height: 50, type: \"text\", text: \"\", color: \"5\" },",
            "lineNumber": 221
          },
          {
            "text": "\t\t\t],",
            "lineNumber": 222
          },
          {
            "text": "\t\t\tedges: [",
            "lineNumber": 223
          },
          {
            "text": "\t\t\t\t{ id: \"e1\", fromNode: \"src\", toNode: \"out\", label: EDGE_LABEL_OUTPUT },",
            "lineNumber": 224
          },
          {
            "text": "\t\t\t],",
            "lineNumber": 225
          },
          {
            "text": "\t\t};",
            "lineNumber": 226
          },
          {
            "text": "\t\texpect(findOutputNodeForSource(data, \"src\", settings)).toBe(\"out\");",
            "lineNumber": 227
          },
          {
            "text": "\t});",
            "lineNumber": 228
          },
          {
            "text": "});",
            "lineNumber": 229
          },
          {
            "lineNumber": 230
          },
          {
            "text": "describe(\"GREEN_NODE_PADDING\", () =&gt; {",
            "lineNumber": 231
          },
          {
            "text": "\tit",
            "lineNumber": 232
          },
          {
            "lineNumber": 234
          },
          {
            "text": "}",
            "lineNumber": 235
          }
        ]
      },
      "score": 0.1724664568901062
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 128,
            "column": 1
          },
          "endPosition": {
            "line": 148,
            "column": 93
          }
        },
        "contents": "/** Sort ready queue: non-AI (Python, yellow) first for early output, then by y. */\nfunction sortQueueByNonAIFirst(\n\tqueue: string[],\n\tdata: CanvasData,\n\tsettings: ZettelPluginSettings\n): void {\n\tqueue.sort((a, b) =&gt; {\n\t\tconst na = getNodeById(data, a);\n\t\tconst nb = getNodeById(data, b);\n\t\tconst roleA = getNodeRole(na ?? { color: undefined }, settings);\n\t\tconst roleB = getNodeRole(nb ?? { color: undefined }, settings);\n\t\tconst nonA = isNonAIRole(roleA) ? 0 : 1;\n\t\tconst nonB = isNonAIRole(roleB) ? 0 : 1;\n\t\tif (nonA !== nonB) return nonA - nonB;\n\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);\n\t});\n}\n\n/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Sort ready queue: non-AI (Python, yellow) first for early output, then by y. */",
            "lineNumber": 131
          },
          {
            "text": "function sortQueueByNonAIFirst(",
            "lineNumber": 132,
            "isSignature": true
          },
          {
            "text": "\tqueue: string[],",
            "lineNumber": 133,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 134,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 135,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 136,
            "isSignature": true
          },
          {
            "text": "\tqueue.sort((a, b) =&gt; {",
            "lineNumber": 137
          },
          {
            "text": "\t\tconst na = getNodeById(data, a);",
            "lineNumber": 138
          },
          {
            "text": "\t\tconst nb = getNodeById(data, b);",
            "lineNumber": 139
          },
          {
            "text": "\t\tconst roleA = getNodeRole(na ?? { color: undefined }, settings);",
            "lineNumber": 140
          },
          {
            "text": "\t\tconst roleB = getNodeRole(nb ?? { color: undefined }, settings);",
            "lineNumber": 141
          },
          {
            "text": "\t\tconst nonA = isNonAIRole(roleA) ? 0 : 1;",
            "lineNumber": 142
          },
          {
            "text": "\t\tconst nonB = isNonAIRole(roleB) ? 0 : 1;",
            "lineNumber": 143
          },
          {
            "text": "\t\tif (nonA !== nonB) return nonA - nonB;",
            "lineNumber": 144
          },
          {
            "text": "\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);",
            "lineNumber": 145
          },
          {
            "text": "\t});",
            "lineNumber": 146
          },
          {
            "text": "}",
            "lineNumber": 147,
            "isSignature": true
          },
          {
            "lineNumber": 148
          },
          {
            "text": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
            "lineNumber": 149
          }
        ]
      },
      "score": 0.17100979387760162
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 45,
            "column": 1
          },
          "endPosition": {
            "line": 57,
            "column": 1
          }
        },
        "contents": "/** True if edge is the reserved output edge (run node → green output note); ignored by execution. */\nexport function isOutputEdge(edge: CanvasEdgeData): boolean {\n\treturn parseEdgeVariableName(edge.label) === EDGE_LABEL_OUTPUT;\n}\n\n/** Incoming edge with parent id and optional variable name (from label). */\nexport interface IncomingEdgeInfo {\n\tparentId: string\n;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** True if edge is the reserved output edge (run node → green output note); ignored by execution. */",
            "lineNumber": 48
          },
          {
            "text": "export function isOutputEdge(edge: CanvasEdgeData): boolean {",
            "lineNumber": 49,
            "isSignature": true
          },
          {
            "text": "\treturn parseEdgeVariableName(edge.label) === EDGE_LABEL_OUTPUT;",
            "lineNumber": 50
          },
          {
            "text": "}",
            "lineNumber": 51,
            "isSignature": true
          },
          {
            "lineNumber": 52
          },
          {
            "text": "/** Incoming edge with parent id and optional variable name (from label). */",
            "lineNumber": 53
          },
          {
            "text": "export interface IncomingEdgeInfo {",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "text": "\tparentId: string",
            "lineNumber": 55
          },
          {
            "text": ";",
            "lineNumber": 57,
            "isSignature": true
          },
          {
            "text": "}",
            "lineNumber": 58,
            "isSignature": true
          }
        ]
      },
      "score": 0.17036163806915283
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 131,
            "column": 1
          },
          "endPosition": {
            "line": 180,
            "column": 1
          }
        },
        "contents": "/**\n * Sync floating role labels for the active canvas: for each node whose color maps to a role,\n * add a small label above the node (e.g. \"Comment\", \"Python\"). Removes existing labels first.\n * Uses the live canvas node map to find each node's DOM element (.canvas-node).\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasRoleLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tsettings: ZettelPluginSettings,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tif (!settings.showNodeRoleLabels) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.nodes) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).\n\tclearCanvasRoleLabels(containerEl);\n\tsyncCanvasLegend(containerEl, settings);\n\tfor (const node of data.nodes) {\n\t\tconst role = getNodeRole(node, settings);\n\t\tif (!role) continue;\n\t\tconst labelText = getRoleLabel(role, settings);\n\t\tconst nodeEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||\n\t\t\tfindNodeElementByDataId(containerEl, node.id);\n\t\tif (!nodeEl) continue;\n\t\tconst label = createLabelEl(labelText);\n\t\t// Append after .canvas-node-container so it matches Obsidian file node label position\n\t\tnodeEl.append(label);\n\t}\n}\n\n/** Get center of an element in viewport coordinates. */\nfunction getElCenter(el: HTMLElement): { x: number; y: number } {\n\tconst r = el.getBoundingClientRect();\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/**",
            "lineNumber": 134
          },
          {
            "text": " * Sync floating role labels for the active canvas: for each node whose color maps to a role,",
            "lineNumber": 135
          },
          {
            "text": " * add a small label above the node (e.g. \"Comment\", \"Python\"). Removes existing labels first.",
            "lineNumber": 136
          },
          {
            "text": " * Uses the live canvas node map to find each node's DOM element (.canvas-node).",
            "lineNumber": 137
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 138
          },
          {
            "text": " */",
            "lineNumber": 139
          },
          {
            "text": "export async function syncCanvasRoleLabels(",
            "lineNumber": 140,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 141,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 142,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 143,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 144,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 145,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 146,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 147,
            "isSignature": true
          },
          {
            "text": "\tif (!settings.showNodeRoleLabels) {",
            "lineNumber": 148
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 149
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 150
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 151
          },
          {
            "text": "\t}",
            "lineNumber": 152
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 153
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 154
          },
          {
            "text": "\tif (!data?.nodes) {",
            "lineNumber": 155
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 156
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 157
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 158
          },
          {
            "text": "\t}",
            "lineNumber": 159
          },
          {
            "text": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).",
            "lineNumber": 160
          },
          {
            "text": "\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 161
          },
          {
            "text": "\tsyncCanvasLegend(containerEl, settings);",
            "lineNumber": 162
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 163
          },
          {
            "text": "\t\tconst role = getNodeRole(node, settings);",
            "lineNumber": 164
          },
          {
            "text": "\t\tif (!role) continue;",
            "lineNumber": 165
          },
          {
            "text": "\t\tconst labelText = getRoleLabel(role, settings);",
            "lineNumber": 166
          },
          {
            "text": "\t\tconst nodeEl =",
            "lineNumber": 167
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||",
            "lineNumber": 168
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, node.id);",
            "lineNumber": 169
          },
          {
            "text": "\t\tif (!nodeEl) continue;",
            "lineNumber": 170
          },
          {
            "text": "\t\tconst label = createLabelEl(labelText);",
            "lineNumber": 171
          },
          {
            "text": "\t\t// Append after .canvas-node-container so it matches Obsidian file node label position",
            "lineNumber": 172
          },
          {
            "text": "\t\tnodeEl.append(label);",
            "lineNumber": 173
          },
          {
            "text": "\t}",
            "lineNumber": 174
          },
          {
            "text": "}",
            "lineNumber": 175,
            "isSignature": true
          },
          {
            "lineNumber": 176
          },
          {
            "text": "/** Get center of an element in viewport coordinates. */",
            "lineNumber": 177
          },
          {
            "text": "function getElCenter(el: HTMLElement): { x: number; y: number } {",
            "lineNumber": 178,
            "isSignature": true
          },
          {
            "text": "\tconst r = el.getBoundingClientRect();",
            "lineNumber": 179
          },
          {
            "text": "}",
            "lineNumber": 181,
            "isSignature": true
          }
        ]
      },
      "score": 0.16136515140533447
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 31,
            "column": 104
          }
        },
        "contents": "import type {App} from \"obsidian\";\nimport {\n\tEDGE_LABEL_OUTPUT,\n\tfindOutputNodeForSource,\n\tgetNodeById,\n\tgetNodeContent,\n\tgetNodeRole,\n\tgetIncomingEdgesWithLabels,\n\tgetParentIdsSortedByY,\n\tGREEN_NODE_PADDING,\n\tisOutputEdge,\n\tloadCanvasData,\n\tsaveCanvasData,\n} from \"../canvas/nodes\";\nimport type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";\nimport { parseEdgeVariableName } from \"../canvas/types\";\nimport {isTextNode} from \"../canvas/types\";\nimport type {LiveCanvas} from \"./canvasApi\";\nimport {getKernelForCanvas} from \"./kernelManager\";\nimport {ollamaGenerate} from \"./ollama\";\nimport {\n\tgetCanvasKey,\n\tgetNodeResult,\n\tsetNodeResult,\n\tsetEdgeModes,\n\tsetRunningNodeId,\n} from \"./state\";\nimport type {NodeRole, ZettelPluginSettings} from \"../settings\";\n\ntype EdgeInputMode = \"inject\" | \"concatenate\";\n\n/** True if the role is non-AI (Python or pass-through); prefer running these first for early output. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {App} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {",
            "lineNumber": 2
          },
          {
            "text": "\tEDGE_LABEL_OUTPUT,",
            "lineNumber": 3
          },
          {
            "text": "\tfindOutputNodeForSource,",
            "lineNumber": 4
          },
          {
            "text": "\tgetNodeById,",
            "lineNumber": 5
          },
          {
            "text": "\tgetNodeContent,",
            "lineNumber": 6
          },
          {
            "text": "\tgetNodeRole,",
            "lineNumber": 7
          },
          {
            "text": "\tgetIncomingEdgesWithLabels,",
            "lineNumber": 8
          },
          {
            "text": "\tgetParentIdsSortedByY,",
            "lineNumber": 9
          },
          {
            "text": "\tGREEN_NODE_PADDING,",
            "lineNumber": 10
          },
          {
            "text": "\tisOutputEdge,",
            "lineNumber": 11
          },
          {
            "text": "\tloadCanvasData,",
            "lineNumber": 12
          },
          {
            "text": "\tsaveCanvasData,",
            "lineNumber": 13
          },
          {
            "text": "} from \"../canvas/nodes\";",
            "lineNumber": 14
          },
          {
            "text": "import type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";",
            "lineNumber": 15
          },
          {
            "text": "import { parseEdgeVariableName } from \"../canvas/types\";",
            "lineNumber": 16
          },
          {
            "text": "import {isTextNode} from \"../canvas/types\";",
            "lineNumber": 17
          },
          {
            "text": "import type {LiveCanvas} from \"./canvasApi\";",
            "lineNumber": 18
          },
          {
            "text": "import {getKernelForCanvas} from \"./kernelManager\";",
            "lineNumber": 19
          },
          {
            "text": "import {ollamaGenerate} from \"./ollama\";",
            "lineNumber": 20
          },
          {
            "text": "import {",
            "lineNumber": 21
          },
          {
            "text": "\tgetCanvasKey,",
            "lineNumber": 22
          },
          {
            "text": "\tgetNodeResult,",
            "lineNumber": 23
          },
          {
            "text": "\tsetNodeResult,",
            "lineNumber": 24
          },
          {
            "text": "\tsetEdgeModes,",
            "lineNumber": 25
          },
          {
            "text": "\tsetRunningNodeId,",
            "lineNumber": 26
          },
          {
            "text": "} from \"./state\";",
            "lineNumber": 27
          },
          {
            "text": "import type {NodeRole, ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 28
          },
          {
            "lineNumber": 29
          },
          {
            "text": "type EdgeInputMode = \"inject\" | \"concatenate\";",
            "lineNumber": 30,
            "isSignature": true
          },
          {
            "lineNumber": 31
          },
          {
            "text": "/** True if the role is non-AI (Python or pass-through); prefer running these first for early output. */",
            "lineNumber": 32
          }
        ]
      },
      "score": 0.15629500150680542
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 75,
            "column": 1
          },
          "endPosition": {
            "line": 95,
            "column": 1
          }
        },
        "contents": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */\nexport function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));\n\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withY = fromIds\n\t\t.map((id) =&gt; {\n\t\t\tconst node = nodeMap.get(id);\n\t\t\treturn node ? { id, y: node.y } : null;\n\t\t})\n\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);\n\twithY.sort((a, b) =&gt; a.y - b.y);\n\treturn withY.map((x) =&gt; x.id);\n}\n\n/** Get node by id from canvas data. */\nexport function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output edges. */",
            "lineNumber": 78
          },
          {
            "text": "export function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {",
            "lineNumber": 79,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isOutputEdge(e));",
            "lineNumber": 80
          },
          {
            "text": "\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];",
            "lineNumber": 81
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 82
          },
          {
            "text": "\tconst withY = fromIds",
            "lineNumber": 83
          },
          {
            "text": "\t\t.map((id) =&gt; {",
            "lineNumber": 84
          },
          {
            "text": "\t\t\tconst node = nodeMap.get(id);",
            "lineNumber": 85
          },
          {
            "text": "\t\t\treturn node ? { id, y: node.y } : null;",
            "lineNumber": 86
          },
          {
            "text": "\t\t})",
            "lineNumber": 87
          },
          {
            "text": "\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);",
            "lineNumber": 88
          },
          {
            "text": "\twithY.sort((a, b) =&gt; a.y - b.y);",
            "lineNumber": 89
          },
          {
            "text": "\treturn withY.map((x) =&gt; x.id);",
            "lineNumber": 90
          },
          {
            "text": "}",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "lineNumber": 92
          },
          {
            "text": "/** Get node by id from canvas data. */",
            "lineNumber": 93
          },
          {
            "text": "export function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {",
            "lineNumber": 94,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 95
          },
          {
            "text": "}",
            "lineNumber": 96,
            "isSignature": true
          }
        ]
      },
      "score": 0.15419289469718933
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 504,
            "column": 1
          },
          "endPosition": {
            "line": 527,
            "column": 98
          }
        },
        "contents": "/** Remove the Green output node and its output edge for a given source node; mutates data and saves. */\nexport async function dismissOutput(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tsourceNodeId: string,\n\tsettings: ZettelPluginSettings,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (!data) return;\n\tconst outId = findOutputNodeForSource(data, sourceNodeId, settings);\n\tif (!outId) return;\n\tdata.nodes = data.nodes.filter((n) =&gt; n.id !== outId);\n\tdata.edges = data.edges.filter(\n\t\t(e) =&gt; !(e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT)\n\t);\n\tliveCanvas?.setData?.(data);\n\tif (liveCanvas?.requestSave) liveCanvas.requestSave();\n\tawait saveCanvasData(vault, canvasFilePath, data);\n}\n\n/** Remove all Green output nodes and their output edges on the canvas; mutates data and saves. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Remove the Green output node and its output edge for a given source node; mutates data and saves. */",
            "lineNumber": 507
          },
          {
            "text": "export async function dismissOutput(",
            "lineNumber": 508,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 509,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 510,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 511,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 512,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 513,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 514,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 515
          },
          {
            "text": "\tif (!data) return;",
            "lineNumber": 516
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNodeId, settings);",
            "lineNumber": 517
          },
          {
            "text": "\tif (!outId) return;",
            "lineNumber": 518
          },
          {
            "text": "\tdata.nodes = data.nodes.filter((n) =&gt; n.id !== outId);",
            "lineNumber": 519
          },
          {
            "text": "\tdata.edges = data.edges.filter(",
            "lineNumber": 520
          },
          {
            "text": "\t\t(e) =&gt; !(e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT)",
            "lineNumber": 521
          },
          {
            "text": "\t);",
            "lineNumber": 522
          },
          {
            "text": "\tliveCanvas?.setData?.(data);",
            "lineNumber": 523
          },
          {
            "text": "\tif (liveCanvas?.requestSave) liveCanvas.requestSave();",
            "lineNumber": 524
          },
          {
            "text": "\tawait saveCanvasData(vault, canvasFilePath, data);",
            "lineNumber": 525
          },
          {
            "text": "}",
            "lineNumber": 526,
            "isSignature": true
          },
          {
            "lineNumber": 527
          },
          {
            "text": "/** Remove all Green output nodes and their output edges on the canvas; mutates data and saves. */",
            "lineNumber": 528
          }
        ]
      },
      "score": 0.14926789700984955
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 415,
            "column": 1
          },
          "endPosition": {
            "line": 474,
            "column": 1
          }
        },
        "contents": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */\nexport async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return { ok: false, message: \"Node not found.\" };\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };\n\tconst parentIds = getParentIdsSortedByY(nodeId, data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tfor (const pid of parentIds) {\n\t\tif (getNodeResult(canvasKey, pid) == null) {\n\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);\n\t\t}\n\t}\n\ttry {\n\t\tsetRunningNodeId(canvasKey, nodeId);\n\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t} finally {\n\t\tsetRunningNodeId(canvasKey, null);\n\t}\n}\n\n/** Run all nodes reachable from any root, in topological order. */\nexport async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 418
          },
          {
            "text": "export async function runNode(",
            "lineNumber": 419,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 420,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 421,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 422,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 423,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 424,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 425,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 426
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 427
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 428
          },
          {
            "text": "\tif (!node) return { ok: false, message: \"Node not found.\" };",
            "lineNumber": 429
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 430
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 431
          },
          {
            "text": "\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };",
            "lineNumber": 432
          },
          {
            "text": "\tconst parentIds = getParentIdsSortedByY(nodeId, data);",
            "lineNumber": 433
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 434
          },
          {
            "text": "\tfor (const pid of parentIds) {",
            "lineNumber": 435
          },
          {
            "text": "\t\tif (getNodeResult(canvasKey, pid) == null) {",
            "lineNumber": 436
          },
          {
            "text": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);",
            "lineNumber": 437
          },
          {
            "text": "\t\t}",
            "lineNumber": 438
          },
          {
            "text": "\t}",
            "lineNumber": 439
          },
          {
            "text": "\ttry {",
            "lineNumber": 440
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, nodeId);",
            "lineNumber": 441
          },
          {
            "text": "\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);",
            "lineNumber": 442
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 443
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 444
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 445
          },
          {
            "text": "\t} finally {",
            "lineNumber": 446
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 447
          },
          {
            "text": "\t}",
            "lineNumber": 448
          },
          {
            "text": "}",
            "lineNumber": 449,
            "isSignature": true
          },
          {
            "lineNumber": 450
          },
          {
            "text": "/** Run all nodes reachable from any root, in topological order. */",
            "lineNumber": 451
          },
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 452,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 453,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 454,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 455,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 456,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 457,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 458
          },
          {
            "text": "}",
            "lineNumber": 475,
            "isSignature": true
          }
        ]
      },
      "score": 0.14801055192947388
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 28,
            "column": 1
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */\nlet debugNodeMenuFired = false;\n\nexport default class ZettelThinkingBoardPlugin extends Plugin {\n\tsettings: ZettelPluginSettings;\n\n\tasync onload() {\n\t\ttry {\n\t\t\tawait this.loadSettings();\n\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));\n\n\t\t\tthis.registerView(\n\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,\n\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)\n\t\t\t);\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"open-zettel-controls\",\n\t\t\t\tname: \"Open Zettel Controls\",\n\t\t\t\tcallback: () =&gt; this.activateZettelControls(),\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-node\",\n\t\t\t\tname: \"Run node\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"run-chain\",\n\t\t\t\tname: \"Run chain\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tthis.addCommand({\n\t\t\t\tid: \"dismiss-output\",\n\t\t\t\tname: \"Dismiss output\",\n\t\t\t\tcheckCallback: (checking: boolean) =&gt; {\n\t\t\t\t\tconst view = this.getActiveCanvasView();\n\t\t\t\t\tif (!view) return false;\n\t\t\t\t\tif (checking) return true;\n\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");\n\t\t\t\t\treturn true;\n\t\t\t\t},\n\t\t\t});\n\n\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 31
          },
          {
            "text": "let debugNodeMenuFired = false;",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings;",
            "lineNumber": 35
          },
          {
            "lineNumber": 36
          },
          {
            "text": "\tasync onload() {",
            "lineNumber": 37
          },
          {
            "text": "\t\ttry {",
            "lineNumber": 38
          },
          {
            "text": "\t\t\tawait this.loadSettings();",
            "lineNumber": 39
          },
          {
            "text": "\t\t\tthis.addSettingTab(new ZettelSettingTab(this.app, this));",
            "lineNumber": 40
          },
          {
            "lineNumber": 41
          },
          {
            "text": "\t\t\tthis.registerView(",
            "lineNumber": 42
          },
          {
            "text": "\t\t\t\tZETTEL_CONTROLS_VIEW_TYPE,",
            "lineNumber": 43
          },
          {
            "text": "\t\t\t\t(leaf: WorkspaceLeaf) =&gt; new ZettelControlsView(leaf, this)",
            "lineNumber": 44
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 45
          },
          {
            "lineNumber": 46
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 47
          },
          {
            "text": "\t\t\t\tid: \"open-zettel-controls\",",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\tname: \"Open Zettel Controls\",",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t\tcallback: () =&gt; this.activateZettelControls(),",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 51
          },
          {
            "lineNumber": 52
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 53
          },
          {
            "text": "\t\t\t\tid: \"run-node\",",
            "lineNumber": 54
          },
          {
            "text": "\t\t\t\tname: \"Run node\",",
            "lineNumber": 55
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 56
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 57
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 58
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 59
          },
          {
            "text": "\t\t\t\t\t// Command palette: no node selected; prompt user to use context menu",
            "lineNumber": 60
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run node\\\" to run it.\");",
            "lineNumber": 61
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 62
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 63
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 64
          },
          {
            "lineNumber": 65
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 66
          },
          {
            "text": "\t\t\t\tid: \"run-chain\",",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t\tname: \"Run chain\",",
            "lineNumber": 68
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 69
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 70
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 71
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 72
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Run chain\\\" to run from roots.\");",
            "lineNumber": 73
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 74
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 75
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 76
          },
          {
            "lineNumber": 77
          },
          {
            "text": "\t\t\tthis.addCommand({",
            "lineNumber": 78
          },
          {
            "text": "\t\t\t\tid: \"dismiss-output\",",
            "lineNumber": 79
          },
          {
            "text": "\t\t\t\tname: \"Dismiss output\",",
            "lineNumber": 80
          },
          {
            "text": "\t\t\t\tcheckCallback: (checking: boolean) =&gt; {",
            "lineNumber": 81
          },
          {
            "text": "\t\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 82
          },
          {
            "text": "\t\t\t\t\tif (!view) return false;",
            "lineNumber": 83
          },
          {
            "text": "\t\t\t\t\tif (checking) return true;",
            "lineNumber": 84
          },
          {
            "text": "\t\t\t\t\tnew Notice(\"Right-click a node and choose \\\"Dismiss output\\\" to remove its output.\");",
            "lineNumber": 85
          },
          {
            "text": "\t\t\t\t\treturn true;",
            "lineNumber": 86
          },
          {
            "text": "\t\t\t\t},",
            "lineNumber": 87
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 88
          },
          {
            "lineNumber": 89
          },
          {
            "text": "\t\t\t// Canvas node context menu (event name is undocumented; try workspace.on(\"canvas:node-menu\")).",
            "lineNumber": 90
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.14471834897994995
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "column": 71
          },
          "endPosition": {
            "line": 30,
            "column": 108
          }
        },
        "contents": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";\nimport {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";\nimport {\n\tdismissAllOutput as runnerDismissAllOutput,\n\tdismissOutput as runnerDismissOutput,\n\trunChain as runnerRunChain,\n\trunEntireCanvas as runnerRunEntireCanvas,\n\trunNode as runnerRunNode,\n} from \"./engine/runner\";\nimport {\n\tclearCanvasEdgeModeLabels,\n\tclearCanvasLegend,\n\tclearCanvasRoleLabels,\n\tsyncCanvasEdgeModeLabels,\n\tsyncCanvasRoleLabels,\n} from \"./canvas/canvasNodeLabels\";\nimport {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";\n\n/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */\nfunction resolveCanvasNodeId(node: unknown): string | undefined {\n\tif (!node || typeof node !== \"object\") return undefined;\n\tconst n = node as Record&lt;string, unknown&gt;;\n\tif (typeof n.id === \"string\") return n.id;\n\tconst inner = n.node as Record&lt;string, unknown&gt; | undefined;\n\tif (inner &amp;&amp; typeof inner.id === \"string\") return inner.id;\n\tconst data = typeof n.getData === \"function\" ? (n.getData as () =&gt; { id?: string })() : undefined;\n\treturn data?.id;\n}\n\n/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";",
            "lineNumber": 2
          },
          {
            "text": "import {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";",
            "lineNumber": 3
          },
          {
            "text": "import {",
            "lineNumber": 4
          },
          {
            "text": "\tdismissAllOutput as runnerDismissAllOutput,",
            "lineNumber": 5
          },
          {
            "text": "\tdismissOutput as runnerDismissOutput,",
            "lineNumber": 6
          },
          {
            "text": "\trunChain as runnerRunChain,",
            "lineNumber": 7
          },
          {
            "text": "\trunEntireCanvas as runnerRunEntireCanvas,",
            "lineNumber": 8
          },
          {
            "text": "\trunNode as runnerRunNode,",
            "lineNumber": 9
          },
          {
            "text": "} from \"./engine/runner\";",
            "lineNumber": 10
          },
          {
            "text": "import {",
            "lineNumber": 11
          },
          {
            "text": "\tclearCanvasEdgeModeLabels,",
            "lineNumber": 12
          },
          {
            "text": "\tclearCanvasLegend,",
            "lineNumber": 13
          },
          {
            "text": "\tclearCanvasRoleLabels,",
            "lineNumber": 14
          },
          {
            "text": "\tsyncCanvasEdgeModeLabels,",
            "lineNumber": 15
          },
          {
            "text": "\tsyncCanvasRoleLabels,",
            "lineNumber": 16
          },
          {
            "text": "} from \"./canvas/canvasNodeLabels\";",
            "lineNumber": 17
          },
          {
            "text": "import {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";",
            "lineNumber": 18
          },
          {
            "lineNumber": 19
          },
          {
            "text": "/** Resolve canvas node id from context-menu payload (shape may vary by Obsidian version). */",
            "lineNumber": 20
          },
          {
            "text": "function resolveCanvasNodeId(node: unknown): string | undefined {",
            "lineNumber": 21,
            "isSignature": true
          },
          {
            "text": "\tif (!node || typeof node !== \"object\") return undefined;",
            "lineNumber": 22
          },
          {
            "text": "\tconst n = node as Record&lt;string, unknown&gt;;",
            "lineNumber": 23
          },
          {
            "text": "\tif (typeof n.id === \"string\") return n.id;",
            "lineNumber": 24
          },
          {
            "text": "\tconst inner = n.node as Record&lt;string, unknown&gt; | undefined;",
            "lineNumber": 25
          },
          {
            "text": "\tif (inner &amp;&amp; typeof inner.id === \"string\") return inner.id;",
            "lineNumber": 26
          },
          {
            "text": "\tconst data = typeof n.getData === \"function\" ? (n.getData as () =&gt; { id?: string })() : undefined;",
            "lineNumber": 27
          },
          {
            "text": "\treturn data?.id;",
            "lineNumber": 28
          },
          {
            "text": "}",
            "lineNumber": 29,
            "isSignature": true
          },
          {
            "lineNumber": 30
          },
          {
            "text": "/** Debug: set to true when canvas:node-menu callback has fired at least once (proves event is received). */",
            "lineNumber": 31
          }
        ]
      },
      "score": 0.13394060730934143
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 113
          },
          "endPosition": {
            "line": 120,
            "column": 113
          }
        },
        "contents": "export function getFileNodePath(node: CanvasFileData): string {\n\n}\n\n/** Fixed padding between source node and its Green output node (Part 1). */\nexport const GREEN_NODE_PADDING = 20;\n\n/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export function getFileNodePath(node: CanvasFileData): string {",
            "lineNumber": 114,
            "isSignature": true
          },
          {
            "lineNumber": 115
          },
          {
            "text": "}",
            "lineNumber": 116,
            "isSignature": true
          },
          {
            "lineNumber": 117
          },
          {
            "text": "/** Fixed padding between source node and its Green output node (Part 1). */",
            "lineNumber": 118
          },
          {
            "text": "export const GREEN_NODE_PADDING = 20;",
            "lineNumber": 119
          },
          {
            "lineNumber": 120
          },
          {
            "text": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
            "lineNumber": 121
          }
        ]
      },
      "score": 0.13131356239318848
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 220,
            "column": 1
          },
          "endPosition": {
            "line": 329,
            "column": 1
          }
        },
        "contents": "/**\n * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,\n * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG\n * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasEdgeModeLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.edges) {\n\t\tclearCanvasEdgeModeLabels(containerEl);\n\t\treturn;\n\t}\n\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).\n\tclearCanvasEdgeModeLabels(containerEl);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tconst runningNodeId = getRunningNodeId(canvasKey);\n\tconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\tconst Y_OFFSET_BELOW_PATH = 12;\n\tconst FONT_SIZE = 11;\n\tconst FONT_SIZE_RUNNING = 20;\n\tconst DOT_R = 2.5;\n\tconst DOT_R_RUNNING = 5;\n\tconst DOT_TEXT_GAP = 6;\n\tfor (const edge of data.edges) {\n\t\tif (isOutputEdge(edge)) continue;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/**",
            "lineNumber": 223
          },
          {
            "text": " * Sync floating edge mode labels: for each edge with a mode (inject/concatenate) or incoming to the running node,",
            "lineNumber": 224
          },
          {
            "text": " * show a label in the middle of the arrow via a foreignObject in the edge's SVG &lt;g&gt;, using path midpoint in SVG",
            "lineNumber": 225
          },
          {
            "text": " * coordinates so the label stays correct under pan/zoom. FO is placed at path midpoint (no left offset) to avoid clipping.",
            "lineNumber": 226
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 227
          },
          {
            "text": " */",
            "lineNumber": 228
          },
          {
            "text": "export async function syncCanvasEdgeModeLabels(",
            "lineNumber": 229,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 230,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 231,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 232,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 234,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 235,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 236
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 237
          },
          {
            "text": "\tif (!data?.edges) {",
            "lineNumber": 238
          },
          {
            "text": "\t\tclearCanvasEdgeModeLabels(containerEl);",
            "lineNumber": 239
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 240
          },
          {
            "text": "\t}",
            "lineNumber": 241
          },
          {
            "text": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).",
            "lineNumber": 242
          },
          {
            "text": "\tclearCanvasEdgeModeLabels(containerEl);",
            "lineNumber": 243
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 244
          },
          {
            "text": "\tconst runningNodeId = getRunningNodeId(canvasKey);",
            "lineNumber": 245
          },
          {
            "text": "\tconst SVG_NS = \"http://www.w3.org/2000/svg\";",
            "lineNumber": 246
          },
          {
            "text": "\tconst Y_OFFSET_BELOW_PATH = 12;",
            "lineNumber": 247
          },
          {
            "text": "\tconst FONT_SIZE = 11;",
            "lineNumber": 248
          },
          {
            "text": "\tconst FONT_SIZE_RUNNING = 20;",
            "lineNumber": 249
          },
          {
            "text": "\tconst DOT_R = 2.5;",
            "lineNumber": 250
          },
          {
            "text": "\tconst DOT_R_RUNNING = 5;",
            "lineNumber": 251
          },
          {
            "text": "\tconst DOT_TEXT_GAP = 6;",
            "lineNumber": 252
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 253
          },
          {
            "text": "\t\tif (isOutputEdge(edge)) continue;",
            "lineNumber": 254
          },
          {
            "text": "}",
            "lineNumber": 330,
            "isSignature": true
          }
        ]
      },
      "score": 0.1313098967075348
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 525,
            "column": 1
          },
          "endPosition": {
            "line": 545,
            "column": 1
          }
        },
        "contents": "/** Remove all Green output nodes and their output edges on the canvas; mutates data and saves. */\nexport async function dismissAllOutput(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (!data) return;\n\tconst outputNodeIds = new Set(\n\t\tdata.edges\n\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT)\n\t\t\t.map((e) =&gt; e.toNode)\n\t);\n\tdata.nodes = data.nodes.filter((n) =&gt; !outputNodeIds.has(n.id));\n\tdata.edges = data.edges.filter((e) =&gt; parseEdgeVariableName(e.label) !== EDGE_LABEL_OUTPUT);\n\tliveCanvas?.setData?.(data);\n\tif (liveCanvas?.requestSave) liveCanvas.requestSave();\n\tawait saveCanvasData(vault, canvasFilePath, data);\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Remove all Green output nodes and their output edges on the canvas; mutates data and saves. */",
            "lineNumber": 528
          },
          {
            "text": "export async function dismissAllOutput(",
            "lineNumber": 529,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 530,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 531,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 532,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 533,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 534
          },
          {
            "text": "\tif (!data) return;",
            "lineNumber": 535
          },
          {
            "text": "\tconst outputNodeIds = new Set(",
            "lineNumber": 536
          },
          {
            "text": "\t\tdata.edges",
            "lineNumber": 537
          },
          {
            "text": "\t\t\t.filter((e) =&gt; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT)",
            "lineNumber": 538
          },
          {
            "text": "\t\t\t.map((e) =&gt; e.toNode)",
            "lineNumber": 539
          },
          {
            "text": "\t);",
            "lineNumber": 540
          },
          {
            "text": "\tdata.nodes = data.nodes.filter((n) =&gt; !outputNodeIds.has(n.id));",
            "lineNumber": 541
          },
          {
            "text": "\tdata.edges = data.edges.filter((e) =&gt; parseEdgeVariableName(e.label) !== EDGE_LABEL_OUTPUT);",
            "lineNumber": 542
          },
          {
            "text": "\tliveCanvas?.setData?.(data);",
            "lineNumber": 543
          },
          {
            "text": "\tif (liveCanvas?.requestSave) liveCanvas.requestSave();",
            "lineNumber": 544
          },
          {
            "text": "\tawait saveCanvasData(vault, canvasFilePath, data);",
            "lineNumber": 545
          },
          {
            "text": "}",
            "lineNumber": 546,
            "isSignature": true
          }
        ]
      },
      "score": 0.12957200407981873
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\nconst runSyncLabels = \n\n\t\t\t\tif (leaf?.view) {\n\t\t\t\t\tconst itemView = leaf.view as ViewWithFlag;\n\t\t\t\t\tif (itemView._ztbTitleBarActionsAdded) {\n\t\t\t\t\t\taddedToTitleBar = true;\n\t\t\t\t\t} else if (typeof itemView.addAction === \"function\") {\n\t\t\t\t\t\titemView.addAction(\"play\", \"Run entire canvas\", () =&gt; this.runEntireCanvas());\n\t\t\t\t\t\titemView.addAction(\"trash\", \"Dismiss all output\", () =&gt; this.dismissAllOutput());\n\t\t\t\t\t\titemView._ztbTitleBarActionsAdded = true;\n\t\t\t\t\t\taddedToTitleBar = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!addedToTitleBar) this.addCanvasToolbarToContainer(view.containerEl);\n\t\t\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;\n\t\t\t\tconst isStillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;\n\t\t\t\tsyncCanvasRoleLabels(this.app.vault, view.file.path, view.containerEl, this.settings, liveCanvas, isStillActive);\n\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, view.file.path, view.containerEl, liveCanvas, isStillActive);\n\t\t\t\tif (roleLabelsIntervalId == null) {\n\t\t\t\t\troleLabelsIntervalId = window.setInterval(() =&gt; {\n\t\t\t\t\t\tconst v = this.getActiveCanvasView();\n\t\t\t\t\t\tif (v != null &amp;&amp; v.containerEl === roleLabelsContainerEl) {\n\t\t\t\t\t\t\tconst stillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;\n\t\t\t\t\t\t\tsyncCanvasRoleLabels(this.app.vault, v.file.path, v.containerEl, this.settings, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);\n\t\t\t\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, v.file.path, v.containerEl, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 2000);\n\t\t\t\t\t(this as unknown as { _roleLabelsIntervalId: number })._roleLabelsIntervalId = roleLabelsIntervalId;\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.registerEvent(this.app.workspace.on(\"active-leaf-change\", runSyncLabels));\n\t\t\trunSyncLabels();\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Zettel Thinking Board onload error:\", e);\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tonunload() {\n\t\tterminateAllKernels();\n\t\tconst id = (;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 37,
                "column": 2
              },
              "endPosition": {
                "line": 38,
                "column": 3
              }
            },
            {
              "startPosition": {
                "line": 184,
                "column": 4
              },
              "endPosition": {
                "line": 184,
                "column": 10
              }
            },
            {
              "startPosition": {
                "line": 184,
                "column": 10
              },
              "endPosition": {
                "line": 184,
                "column": 26
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 37
          },
          {
            "text": "const runSyncLabels = ",
            "lineNumber": 184
          },
          {
            "lineNumber": 212
          },
          {
            "text": "\t\t\t\tif (leaf?.view) {",
            "lineNumber": 213
          },
          {
            "text": "\t\t\t\t\tconst itemView = leaf.view as ViewWithFlag;",
            "lineNumber": 214
          },
          {
            "text": "\t\t\t\t\tif (itemView._ztbTitleBarActionsAdded) {",
            "lineNumber": 215
          },
          {
            "text": "\t\t\t\t\t\taddedToTitleBar = true;",
            "lineNumber": 216
          },
          {
            "text": "\t\t\t\t\t} else if (typeof itemView.addAction === \"function\") {",
            "lineNumber": 217
          },
          {
            "text": "\t\t\t\t\t\titemView.addAction(\"play\", \"Run entire canvas\", () =&gt; this.runEntireCanvas());",
            "lineNumber": 218
          },
          {
            "text": "\t\t\t\t\t\titemView.addAction(\"trash\", \"Dismiss all output\", () =&gt; this.dismissAllOutput());",
            "lineNumber": 219
          },
          {
            "text": "\t\t\t\t\t\titemView._ztbTitleBarActionsAdded = true;",
            "lineNumber": 220
          },
          {
            "text": "\t\t\t\t\t\taddedToTitleBar = true;",
            "lineNumber": 221
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 222
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 223
          },
          {
            "text": "\t\t\t\tif (!addedToTitleBar) this.addCanvasToolbarToContainer(view.containerEl);",
            "lineNumber": 224
          },
          {
            "text": "\t\t\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;",
            "lineNumber": 225
          },
          {
            "text": "\t\t\t\tconst isStillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;",
            "lineNumber": 226
          },
          {
            "text": "\t\t\t\tsyncCanvasRoleLabels(this.app.vault, view.file.path, view.containerEl, this.settings, liveCanvas, isStillActive);",
            "lineNumber": 227
          },
          {
            "text": "\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, view.file.path, view.containerEl, liveCanvas, isStillActive);",
            "lineNumber": 228
          },
          {
            "text": "\t\t\t\tif (roleLabelsIntervalId == null) {",
            "lineNumber": 229
          },
          {
            "text": "\t\t\t\t\troleLabelsIntervalId = window.setInterval(() =&gt; {",
            "lineNumber": 230
          },
          {
            "text": "\t\t\t\t\t\tconst v = this.getActiveCanvasView();",
            "lineNumber": 231
          },
          {
            "text": "\t\t\t\t\t\tif (v != null &amp;&amp; v.containerEl === roleLabelsContainerEl) {",
            "lineNumber": 232
          },
          {
            "text": "\t\t\t\t\t\t\tconst stillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === roleLabelsContainerEl;",
            "lineNumber": 233
          },
          {
            "text": "\t\t\t\t\t\t\tsyncCanvasRoleLabels(this.app.vault, v.file.path, v.containerEl, this.settings, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);",
            "lineNumber": 234
          },
          {
            "text": "\t\t\t\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, v.file.path, v.containerEl, v.canvas as import(\"./engine/canvasApi\").LiveCanvas, stillActive);",
            "lineNumber": 235
          },
          {
            "text": "\t\t\t\t\t\t}",
            "lineNumber": 236
          },
          {
            "text": "\t\t\t\t\t}, 2000);",
            "lineNumber": 237
          },
          {
            "text": "\t\t\t\t\t(this as unknown as { _roleLabelsIntervalId: number })._roleLabelsIntervalId = roleLabelsIntervalId;",
            "lineNumber": 238
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 239
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 240
          },
          {
            "text": "\t\t\tthis.registerEvent(this.app.workspace.on(\"active-leaf-change\", runSyncLabels));",
            "lineNumber": 241
          },
          {
            "text": "\t\t\trunSyncLabels();",
            "lineNumber": 242
          },
          {
            "text": "\t\t} catch (e) {",
            "lineNumber": 243
          },
          {
            "text": "\t\t\tconsole.error(\"Zettel Thinking Board onload error:\", e);",
            "lineNumber": 244
          },
          {
            "text": "\t\t\tthrow e;",
            "lineNumber": 245
          },
          {
            "text": "\t\t}",
            "lineNumber": 246
          },
          {
            "text": "\t}",
            "lineNumber": 247
          },
          {
            "lineNumber": 248
          },
          {
            "text": "\tonunload() {",
            "lineNumber": 249
          },
          {
            "text": "\t\tterminateAllKernels();",
            "lineNumber": 250
          },
          {
            "text": "\t\tconst id = (;",
            "lineNumber": 251
          },
          {
            "text": "\t}",
            "lineNumber": 253
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.12125399708747864
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 184,
            "column": 1
          },
          "endPosition": {
            "line": 216,
            "column": 117
          }
        },
        "contents": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */\nasync function updateEdgeLabelsAndSave(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tedgeModes: Map&lt;string, EdgeInputMode&gt;,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tsetEdgeModes(canvasKey, edgeModes);\n\tlet changed = false;\n\tfor (const edge of data.edges) {\n\t\tif (edge.toNode !== nodeId) continue;\n\t\tif (isOutputEdge(edge)) continue;\n\t\tconst mode = edgeModes.get(edge.id);\n\t\tif (mode == null) continue;\n\t\tconst baseName = parseEdgeVariableName(edge.label);\n\t\tif (baseName.length === 0) continue;\n\t\t// Keep only the variable name in the stored label so the user can edit it without touching (injected)/(concatenated)\n\t\tif (edge.label !== baseName) {\n\t\t\tedge.label = baseName;\n\t\t\tchanged = true;\n\t\t}\n\t}\n\t// Always persist so output node/edge mutations from ensureOutputNodeAndEdge are saved\n\tliveCanvas?.setData?.(data);\n\tawait saveCanvasData(vault, canvasFilePath, data);\n}\n\n/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
            "lineNumber": 187
          },
          {
            "text": "async function updateEdgeLabelsAndSave(",
            "lineNumber": 188,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 189,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 190,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 191,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 192,
            "isSignature": true
          },
          {
            "text": "\tedgeModes: Map&lt;string, EdgeInputMode&gt;,",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 194,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 195,
            "isSignature": true
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 196
          },
          {
            "text": "\tsetEdgeModes(canvasKey, edgeModes);",
            "lineNumber": 197
          },
          {
            "text": "\tlet changed = false;",
            "lineNumber": 198
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 199
          },
          {
            "text": "\t\tif (edge.toNode !== nodeId) continue;",
            "lineNumber": 200
          },
          {
            "text": "\t\tif (isOutputEdge(edge)) continue;",
            "lineNumber": 201
          },
          {
            "text": "\t\tconst mode = edgeModes.get(edge.id);",
            "lineNumber": 202
          },
          {
            "text": "\t\tif (mode == null) continue;",
            "lineNumber": 203
          },
          {
            "text": "\t\tconst baseName = parseEdgeVariableName(edge.label);",
            "lineNumber": 204
          },
          {
            "text": "\t\tif (baseName.length === 0) continue;",
            "lineNumber": 205
          },
          {
            "text": "\t\t// Keep only the variable name in the stored label so the user can edit it without touching (injected)/(concatenated)",
            "lineNumber": 206
          },
          {
            "text": "\t\tif (edge.label !== baseName) {",
            "lineNumber": 207
          },
          {
            "text": "\t\t\tedge.label = baseName;",
            "lineNumber": 208
          },
          {
            "text": "\t\t\tchanged = true;",
            "lineNumber": 209
          },
          {
            "text": "\t\t}",
            "lineNumber": 210
          },
          {
            "text": "\t}",
            "lineNumber": 211
          },
          {
            "text": "\t// Always persist so output node/edge mutations from ensureOutputNodeAndEdge are saved",
            "lineNumber": 212
          },
          {
            "text": "\tliveCanvas?.setData?.(data);",
            "lineNumber": 213
          },
          {
            "text": "\tawait saveCanvasData(vault, canvasFilePath, data);",
            "lineNumber": 214
          },
          {
            "text": "}",
            "lineNumber": 215,
            "isSignature": true
          },
          {
            "lineNumber": 216
          },
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 217
          }
        ]
      },
      "score": 0.1192793995141983
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 33
          },
          "endPosition": {
            "line": 389,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\n\n\n\t/** Dismiss the Green output node for the given source node (call from context menu with node id). */\n\tasync dismissOutput(nodeId: string): Promise&lt;void&gt; {\n\t\tconst view = this.getActiveCanvasView();\n\t\tif (!view) return;\n\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;\n\t\tawait runnerDismissOutput(this.app.vault, view.file.path, nodeId, this.settings, liveCanvas);\n\t}\n\n\t/** Run entire canvas (call from canvas background context menu). */\n\tasync runEntireCanvas(): Promise&lt;void&gt; {\n\t\tconst view = this.getActiveCanvasView();\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 34,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 34,
                "column": 16
              },
              "endPosition": {
                "line": 35,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "lineNumber": 357
          },
          {
            "lineNumber": 358
          },
          {
            "text": "\t/** Dismiss the Green output node for the given source node (call from context menu with node id). */",
            "lineNumber": 359
          },
          {
            "text": "\tasync dismissOutput(nodeId: string): Promise&lt;void&gt; {",
            "lineNumber": 360
          },
          {
            "text": "\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 361
          },
          {
            "text": "\t\tif (!view) return;",
            "lineNumber": 362
          },
          {
            "text": "\t\tconst liveCanvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;",
            "lineNumber": 363
          },
          {
            "text": "\t\tawait runnerDismissOutput(this.app.vault, view.file.path, nodeId, this.settings, liveCanvas);",
            "lineNumber": 364
          },
          {
            "text": "\t}",
            "lineNumber": 365
          },
          {
            "lineNumber": 366
          },
          {
            "text": "\t/** Run entire canvas (call from canvas background context menu). */",
            "lineNumber": 367
          },
          {
            "text": "\tasync runEntireCanvas(): Promise&lt;void&gt; {",
            "lineNumber": 368
          },
          {
            "text": "\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 369
          },
          {
            "text": "\t}",
            "lineNumber": 374
          },
          {
            "text": "}",
            "lineNumber": 390,
            "isSignature": true
          }
        ]
      },
      "score": 0.11909335851669312
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---


Checking where the vertical offset constant is defined and how the output y is computed:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "GREEN_NODE_PADDING|GREEN_",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "GREEN_NODE_PADDING|GREEN_",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/canvas/types.ts",
              "matches": [
                {
                  "lineNumber": 119,
                  "content": "export const GREEN_NODE_PADDING = 20;"
                },
                {
                  "lineNumber": 135,
                  "content": "\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;"
                }
              ]
            },
            {
              "file": "src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 10,
                  "content": "\tGREEN_NODE_PADDING,"
                },
                {
                  "lineNumber": 350,
                  "content": "\tconst y = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;"
                }
              ]
            },
            {
              "file": "src/canvas/types.test.ts",
              "matches": [
                {
                  "lineNumber": 11,
                  "content": "\tGREEN_NODE_PADDING,"
                },
                {
                  "lineNumber": 200,
                  "content": "\t\tconst greenY = sourceY + 50 + GREEN_NODE_PADDING; // 170"
                },
                {
                  "lineNumber": 231,
                  "content": "describe(\"GREEN_NODE_PADDING\", () =&gt; {"
                },
                {
                  "lineNumber": 233,
                  "content": "\t\texpect(GREEN_NODE_PADDING).toBe(20);"
                }
              ]
            },
            {
              "file": "src/canvas/nodes.ts",
              "matches": [
                {
                  "lineNumber": 67,
                  "content": "\tGREEN_NODE_PADDING,"
                }
              ]
            }
          ],
          "totalLines": 9,
          "totalMatchedLines": 9
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---


Here’s where things live and how to move the output note lower.

---

## Collision avoidance (horizontal only)

Collision logic is in **`src/engine/runner.ts`**:

- **Constants (lines 284–287)**  
  - `OUTPUT_COLLISION_MAX_RADIUS = 500` — max horizontal shift when avoiding overlap  
  - `OUTPUT_COLLISION_STEP = 80` — step between candidate x positions  

- **Helpers**  
  - `rectanglesOverlap` (289–298) — checks if two rectangles overlap  
  - `chooseOutputPosition` (301–333) — picks an **x** so the output box doesn’t overlap other nodes (tries `defaultX`, then right/left in steps). It does **not** change **y**.

So “collision avoidance” in this codebase is only about **horizontal** placement.

---

## Vertical position (how low the output note is)

The **vertical** position of the output note is set in the same file, in **`ensureOutputNodeAndEdge`**:

```350:350:src/engine/runner.ts
	const y = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;
```

So the output is placed at: **source bottom + `GREEN_NODE_PADDING`**.

`GREEN_NODE_PADDING` is defined in **`src/canvas/types.ts`**:

```119:119:src/canvas/types.ts
export const GREEN_NODE_PADDING = 20;
```

That’s the only value controlling how far **below** the source the output is placed (20 px today).

---

## Moving the output note lower

To place the output note lower:

1. **Increase `GREEN_NODE_PADDING`** in **`src/canvas/types.ts`** (e.g. from `20` to `40` or `60`).  
   - This is used both for placing the node (`runner.ts`) and for the position fallback in `findOutputNodeForSource` in `types.ts`, so one constant keeps behavior consistent.

2. **Or** add an extra vertical offset only where the node is created: in **`src/engine/runner.ts`**, in `ensureOutputNodeAndEdge`, change the `y` line to something like:
   - `const y = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING + 40;`  
   (or introduce a new constant for the extra offset).  
   - If you do that, consider whether `findOutputNodeForSource` in `types.ts` (which uses `expectedY = source.y + source.height + GREEN_NODE_PADDING` and a tolerance) still matches the actual placement; you may need to use the same formula or a constant there too.

So: **collision avoidance** = `runner.ts` (x only). **How low the output sits** = `GREEN_NODE_PADDING` in `types.ts` and the `y` assignment in `ensureOutputNodeAndEdge` in `runner.ts`. Increasing `GREEN_NODE_PADDING` (or adding a fixed extra offset in that `y` calculation) will move the output note lower.

---

_**User**_

Help me add collision avoidance for vertical placement too. 

---

_**Agent (model default, mode Agent)**_


Adding vertical collision avoidance: implementing a position chooser that tries candidate (x, y) and returns the first non-overlapping placement.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---


Adding vertical collision constants and a combined position chooser that returns both x and y.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---


Simplifying the position logic: iterating candidate (x, y) in a single loop.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---


Updating `ensureOutputNodeAndEdge` to use the new (x, y) chooser and the returned `chosenY`:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---


Checking `findOutputNodeForSource`: it uses a position fallback with a y-tolerance; we should relax that so output nodes placed lower by collision avoidance are still found.


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts</summary>

</details>
</tool-use>

---


Relaxing the y-tolerance in the position fallback so we still find output nodes placed lower by collision avoidance.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts</summary>

</details>

</tool-use>

---


Checking tests that reference the position fallback or tolerance:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "findOutputNodeForSource|expectedY|tolerance|GREEN_NODE",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "glob": "*.test.ts",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "findOutputNodeForSource|expectedY|tolerance|GREEN_NODE",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/canvas/types.test.ts",
              "matches": [
                {
                  "lineNumber": 8,
                  "content": "\tfindOutputNodeForSource,"
                },
                {
                  "lineNumber": 11,
                  "content": "\tGREEN_NODE_PADDING,"
                },
                {
                  "lineNumber": 191,
                  "content": "describe(\"findOutputNodeForSource\", () =&gt; {"
                },
                {
                  "lineNumber": 196,
                  "content": "\t\texpect(findOutputNodeForSource(data, \"missing\", settings)).toBeNull();"
                },
                {
                  "lineNumber": 198,
                  "content": "\tit(\"returns green node id when it sits below source within tolerance\", () =&gt; {"
                },
                {
                  "lineNumber": 200,
                  "content": "\t\tconst greenY = sourceY + 50 + GREEN_NODE_PADDING; // 170"
                },
                {
                  "lineNumber": 208,
                  "content": "\t\texpect(findOutputNodeForSource(data, \"src\", settings)).toBe(\"out\");"
                },
                {
                  "lineNumber": 215,
                  "content": "\t\texpect(findOutputNodeForSource(data, \"src\", settings)).toBeNull();"
                },
                {
                  "lineNumber": 227,
                  "content": "\t\texpect(findOutputNodeForSource(data, \"src\", settings)).toBe(\"out\");"
                },
                {
                  "lineNumber": 231,
                  "content": "describe(\"GREEN_NODE_PADDING\", () =&gt; {"
                },
                {
                  "lineNumber": 233,
                  "content": "\t\texpect(GREEN_NODE_PADDING).toBe(20);"
                }
              ]
            }
          ],
          "totalLines": 11,
          "totalMatchedLines": 11
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.test.ts</summary>

</details>
</tool-use>

---


Confirming the test: greenY = 170 is within [expectedY - 30, expectedY + 450]. Running tests and lint:


---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2** • Run command: cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build 2>&1</summary>

```bash
cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build 2>&1
```

```

&gt; zettel-thinking-board@1.0.0 build
&gt; tsc -noEmit -skipLibCheck &amp;&amp; node esbuild.config.mjs production


```
</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts",
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
    },
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---





---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2** • Run command: cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm test 2>&1</summary>

```bash
cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm test 2>&1
```

```

&gt; zettel-thinking-board@1.0.0 test
&gt; vitest run


 RUN  v1.6.1 /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board

 ✓ src/engine/state.test.ts  (7 tests) 2ms
 ✓ src/canvas/types.test.ts  (27 tests) 5ms

 Test Files  2 passed (2)
      Tests  34 passed (34)
   Start at  17:50:56
   Duration  277ms (transform 69ms, setup 0ms, collect 89ms, tests 7ms, environment 0ms, prepare 105ms)


```
</details>
</tool-use>

---


Summary of changes for vertical collision avoidance:

### 1. **`src/engine/runner.ts`**

- **Constants**
  - `OUTPUT_COLLISION_MAX_VERTICAL = 400` — max vertical offset (px) below the default placement.
  - `OUTPUT_COLLISION_VERTICAL_STEP = 60` — vertical step between candidate y positions.

- **`chooseOutputPosition` → `chooseOutputPositionXY`**
  - Returns `{ x, y }` instead of only `x`.
  - For each candidate y (`defaultY`, then `defaultY + 60`, `defaultY + 120`, … up to `defaultY + 400`), tries all horizontal offsets (0, ±80, ±160, … up to ±500) and returns the first `(x, y)` where the output box does not overlap any other node.
  - So it tries the default spot first, then shifts horizontally, then moves down and repeats.

- **`ensureOutputNodeAndEdge`**
  - Uses `chooseOutputPositionXY` and applies both `chosenX` and `chosenY` when creating or updating the green output node.

### 2. **`src/canvas/types.ts`**

- **`OUTPUT_POSITION_FALLBACK_MAX_Y = 450`**
  - Used in `findOutputNodeForSource` when resolving the output node by position (no edge). The allowed y range is now `[expectedY - 30, expectedY + 450]` so output nodes that were pushed down by collision avoidance are still found.

Build and tests pass. Output notes will first try the default position, then horizontal shifts, then steps downward (60 px at a time, up to 400 px) until a non-overlapping spot is found.

---

_**User**_

Can you give a greater buffer for collision avoidance? So it’s not touching the other notes and instead it is at least some buffer space away. If possible.

---

_**Agent (model default, mode Agent)**_


Adding a buffer so the output node is placed at least a few pixels away from other nodes. Checking the current overlap logic:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---


Adding a buffer constant and treating other nodes as expanded by that amount when checking overlap:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---





---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2** • Run command: cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build 2>&1</summary>

```bash
cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build 2>&1
```

```

&gt; zettel-thinking-board@1.0.0 build
&gt; tsc -noEmit -skipLibCheck &amp;&amp; node esbuild.config.mjs production


```
</details>
</tool-use>

---


Summary of changes:

**`src/engine/runner.ts`**

- **`OUTPUT_COLLISION_BUFFER = 24`**  
  Minimum gap in pixels between the output box and any other node.

- **Overlap check**  
  When testing a candidate position, each existing node is treated as **expanded by the buffer** on all sides (node rect plus 24px left, right, top, bottom). The output box is accepted only if it does **not** overlap these expanded rectangles, so in practice there is always at least 24px of space between the output note and others.

You can change the spacing by editing `OUTPUT_COLLISION_BUFFER` (e.g. 32 or 40 for a larger gap). Build succeeds with the current value.

---

