<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 523fdac6-ede6-46f4-8176-7fb7ae09e13e (2026-02-07 07:51Z) -->

# Python code fencing removal for execution (2026-02-07 07:51Z)

_**User**_

Check that if I have the Python notes with the code fencing, when I try to run the Python node, the code fencing will automatically be removed so that the Python can run properly 

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>

The user is asking about a feature in their Obsidian plugin - when running a Python node, the code should automatically have its markdown code fencing removed so the Python code can run properly. They want me to check if this behavior is implemented.

Let me search the codebase for how Python nodes are run and whether code fencing (```python ... ```) is stripped before execution.
</details></think>

---





---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Where is Python code executed and how is code fencing or markdown stripped before running?",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 195,
            "column": 1
          },
          "endPosition": {
            "line": 210,
            "column": 119
          }
        },
        "contents": "/** Strip optional markdown code fence (&#96;&#96;&#96;python or &#96;&#96;&#96;) so execution runs raw code. */\nfunction stripPythonCodeFence(template: string): string {\n\tconst lines = template.split(/\\r?\\n/);\n\tif (lines.length &lt; 2) return template.trim();\n\tconst first = lines[0];\n\tconst last = lines[lines.length - 1];\n\tif (first == null || last == null) return template.trim();\n\tif (/^&#96;&#96;&#96;(?:python)?\\s*$/i.test(first.trim()) &amp;&amp; /^&#96;&#96;&#96;\\s*$/.test(last.trim())) {\n\t\treturn lines.slice(1, -1).join(\"\\n\").trim();\n\t}\n\treturn template.trim();\n}\n\n/** Build concatenated context, template with {{var:name}} (and optionally {{name}}) substituted, and per-edge mode. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Strip optional markdown code fence (&#96;&#96;&#96;python or &#96;&#96;&#96;) so execution runs raw code. */",
            "lineNumber": 198
          },
          {
            "text": "function stripPythonCodeFence(template: string): string {",
            "lineNumber": 199,
            "isSignature": true
          },
          {
            "text": "\tconst lines = template.split(/\\r?\\n/);",
            "lineNumber": 200
          },
          {
            "text": "\tif (lines.length &lt; 2) return template.trim();",
            "lineNumber": 201
          },
          {
            "text": "\tconst first = lines[0];",
            "lineNumber": 202
          },
          {
            "text": "\tconst last = lines[lines.length - 1];",
            "lineNumber": 203
          },
          {
            "text": "\tif (first == null || last == null) return template.trim();",
            "lineNumber": 204
          },
          {
            "text": "\tif (/^&#96;&#96;&#96;(?:python)?\\s*$/i.test(first.trim()) &amp;&amp; /^&#96;&#96;&#96;\\s*$/.test(last.trim())) {",
            "lineNumber": 205
          },
          {
            "text": "\t\treturn lines.slice(1, -1).join(\"\\n\").trim();",
            "lineNumber": 206
          },
          {
            "text": "\t}",
            "lineNumber": 207
          },
          {
            "text": "\treturn template.trim();",
            "lineNumber": 208
          },
          {
            "text": "}",
            "lineNumber": 209,
            "isSignature": true
          },
          {
            "lineNumber": 210
          },
          {
            "text": "/** Build concatenated context, template with {{var:name}} (and optionally {{name}}) substituted, and per-edge mode. */",
            "lineNumber": 211
          }
        ]
      },
      "score": 0.5637405514717102
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 333,
            "column": 1
          },
          "endPosition": {
            "line": 457,
            "column": 1
          }
        },
        "contents": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */\nasync function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null,\n\trunStartData: RunStartCanvasData\n): Promise&lt;string&gt; {\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return \"\";\n\tconst role = getNodeRole(node, settings);\n\tif (!role || role === \"yellow\" || role === \"green\") {\n\t\t// Yellow = text (input pass-through): merge parent results with own content, same as AI/Python nodes\n\t\tif (role === \"yellow\") {\n\t\t\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\t\t\tconst nodeInput = await getNodeContent(node, app.vault);\n\t\t\tconst { concatenatedPart, template } = buildInputWithVariables(\n\t\t\t\tcanvasKey,\n\t\t\t\tnodeInput,\n\t\t\t\tincoming,\n\t\t\t\tsettings\n\t\t\t);\n\t\t\tconst fullContent =\n\t\t\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\t\t\tsetNodeResult(canvasKey, nodeId, fullContent);\n\t\t\treturn fullContent;\n\t\t}\n\t\treturn \"\";\n\t}\n\t// For Python (blue) text nodes, auto-wrap content in &#96;&#96;&#96;python ... &#96;&#96;&#96; so # comments render correctly\n\tif (role === \"blue\" &amp;&amp; isTextNode(node)) {\n\t\tconst raw = getTextNodeContent(node as CanvasTextData);\n\t\tif (!isPythonCodeFenced(raw)) {\n\t\t\t(node as CanvasTextData).text = ensurePythonCodeFence(raw);\n\t\t\tconst liveData = liveCanvas?.getData?.();\n\t\t\tif (liveData?.nodes) mergePreserveUserNodeProps(data, liveData);\n\t\t\tliveCanvas?.setData?.(data);\n\t\t\tif (liveCanvas?.requestSave) liveCanvas.requestSave();\n\t\t\tawait saveCanvasData(app.vault, canvasFilePath, data);\n\t\t}\n\t}\n\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\tconst nodeInput = await getNodeContent(node, app.vault);\n\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(\n\t\tcanvasKey,\n\t\tnodeInput,\n\t\tincoming,\n\t\tsettings\n\t);\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ?;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 336
          },
          {
            "text": "async function runSingleNode(",
            "lineNumber": 337,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 338,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 339,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 340,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 341,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 342,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 343,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null,",
            "lineNumber": 344,
            "isSignature": true
          },
          {
            "text": "\trunStartData: RunStartCanvasData",
            "lineNumber": 345,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 346,
            "isSignature": true
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 347
          },
          {
            "text": "\tif (!node) return \"\";",
            "lineNumber": 348
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 349
          },
          {
            "text": "\tif (!role || role === \"yellow\" || role === \"green\") {",
            "lineNumber": 350
          },
          {
            "text": "\t\t// Yellow = text (input pass-through): merge parent results with own content, same as AI/Python nodes",
            "lineNumber": 351
          },
          {
            "text": "\t\tif (role === \"yellow\") {",
            "lineNumber": 352
          },
          {
            "text": "\t\t\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 353
          },
          {
            "text": "\t\t\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 354
          },
          {
            "text": "\t\t\tconst { concatenatedPart, template } = buildInputWithVariables(",
            "lineNumber": 355
          },
          {
            "text": "\t\t\t\tcanvasKey,",
            "lineNumber": 356
          },
          {
            "text": "\t\t\t\tnodeInput,",
            "lineNumber": 357
          },
          {
            "text": "\t\t\t\tincoming,",
            "lineNumber": 358
          },
          {
            "text": "\t\t\t\tsettings",
            "lineNumber": 359
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 360
          },
          {
            "text": "\t\t\tconst fullContent =",
            "lineNumber": 361
          },
          {
            "text": "\t\t\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 362
          },
          {
            "text": "\t\t\tsetNodeResult(canvasKey, nodeId, fullContent);",
            "lineNumber": 363
          },
          {
            "text": "\t\t\treturn fullContent;",
            "lineNumber": 364
          },
          {
            "text": "\t\t}",
            "lineNumber": 365
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 366
          },
          {
            "text": "\t}",
            "lineNumber": 367
          },
          {
            "text": "\t// For Python (blue) text nodes, auto-wrap content in &#96;&#96;&#96;python ... &#96;&#96;&#96; so # comments render correctly",
            "lineNumber": 368
          },
          {
            "text": "\tif (role === \"blue\" &amp;&amp; isTextNode(node)) {",
            "lineNumber": 369
          },
          {
            "text": "\t\tconst raw = getTextNodeContent(node as CanvasTextData);",
            "lineNumber": 370
          },
          {
            "text": "\t\tif (!isPythonCodeFenced(raw)) {",
            "lineNumber": 371
          },
          {
            "text": "\t\t\t(node as CanvasTextData).text = ensurePythonCodeFence(raw);",
            "lineNumber": 372
          },
          {
            "text": "\t\t\tconst liveData = liveCanvas?.getData?.();",
            "lineNumber": 373
          },
          {
            "text": "\t\t\tif (liveData?.nodes) mergePreserveUserNodeProps(data, liveData);",
            "lineNumber": 374
          },
          {
            "text": "\t\t\tliveCanvas?.setData?.(data);",
            "lineNumber": 375
          },
          {
            "text": "\t\t\tif (liveCanvas?.requestSave) liveCanvas.requestSave();",
            "lineNumber": 376
          },
          {
            "text": "\t\t\tawait saveCanvasData(app.vault, canvasFilePath, data);",
            "lineNumber": 377
          },
          {
            "text": "\t\t}",
            "lineNumber": 378
          },
          {
            "text": "\t}",
            "lineNumber": 379
          },
          {
            "text": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 380
          },
          {
            "text": "\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 381
          },
          {
            "text": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(",
            "lineNumber": 382
          },
          {
            "text": "\t\tcanvasKey,",
            "lineNumber": 383
          },
          {
            "text": "\t\tnodeInput,",
            "lineNumber": 384
          },
          {
            "text": "\t\tincoming,",
            "lineNumber": 385
          },
          {
            "text": "\t\tsettings",
            "lineNumber": 386
          },
          {
            "text": "\t);",
            "lineNumber": 387
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 388
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ?;",
            "lineNumber": 389
          },
          {
            "text": "}",
            "lineNumber": 458,
            "isSignature": true
          }
        ]
      },
      "score": 0.4791715145111084
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 189,
            "column": 1
          },
          "endPosition": {
            "line": 197,
            "column": 88
          }
        },
        "contents": "/** Wrap in &#96;&#96;&#96;python ... &#96;&#96;&#96; if not already fenced (so Obsidian renders # as comment). */\nfunction ensurePythonCodeFence(text: string): string {\n\tif (isPythonCodeFenced(text)) return text;\n\treturn \"&#96;&#96;&#96;python\\n\" + text.trim() + \"\\n&#96;&#96;&#96;\";\n}\n\n/** Strip optional markdown code fence (&#96;&#96;&#96;python or &#96;&#96;&#96;) so execution runs raw code. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Wrap in &#96;&#96;&#96;python ... &#96;&#96;&#96; if not already fenced (so Obsidian renders # as comment). */",
            "lineNumber": 192
          },
          {
            "text": "function ensurePythonCodeFence(text: string): string {",
            "lineNumber": 193,
            "isSignature": true
          },
          {
            "text": "\tif (isPythonCodeFenced(text)) return text;",
            "lineNumber": 194
          },
          {
            "text": "\treturn \"&#96;&#96;&#96;python\\n\" + text.trim() + \"\\n&#96;&#96;&#96;\";",
            "lineNumber": 195
          },
          {
            "text": "}",
            "lineNumber": 196,
            "isSignature": true
          },
          {
            "lineNumber": 197
          },
          {
            "text": "/** Strip optional markdown code fence (&#96;&#96;&#96;python or &#96;&#96;&#96;) so execution runs raw code. */",
            "lineNumber": 198
          }
        ]
      },
      "score": 0.46206870675086975
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/pythonKernel.ts",
        "range": {
          "startPosition": {
            "line": 16
          },
          "endPosition": {
            "line": 128,
            "column": 1
          }
        },
        "contents": "export function createPythonKernel(pythonPath: string): PythonKernel {\nfunction spawnProcess(): Promise&lt;void&gt; {\n(resolve, reject) =&gt; {\n catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t});\n\t}\n\n\tasync function run(code: string, inputText: string): Promise&lt;string&gt; {\n\t\tawait spawnProcess();\n\t\tif (!child?.stdin) throw new Error(\"Python process not running\");\n\t\tconst fullCode =\n\t\t\tOBSIDIAN_LOG_STUB +\n\t\t\t\"\\ninput = \" +\n\t\t\tJSON.stringify(inputText) +\n\t\t\t\"\\n\\n\" +\n\t\t\tcode +\n\t\t\t\"\\nprint(\" +\n\t\t\tJSON.stringify(END_MARKER) +\n\t\t\t\")\\n\";\n\t\t// Encode as base64 so we can send without escaping issues\n\t\tconst b64 = Buffer.from(fullCode, \"utf-8\").toString(\"base64\");\n\t\tconst payload = &#96;exec(__import__('base64').b64decode(\"${b64}\").decode())\\n&#96;;\n\t\tstdoutBuf = \"\";\n\t\treturn new Promise((resolve, reject) =&gt; {\n\t\t\tpendingResolve = resolve;\n\t\t\tpendingReject = reject;\n\t\t\tchild!.stdin!.write(payload, (err) =&gt; {\n\t\t\t\tif (err) {\n\t\t\t\t\tpendingReject?.(err);\n\t\t\t\t\tpendingResolve = null;\n\t\t\t\t\tpendingReject = null;\n\t\t\t\t}\n\t\t\t});\n\t\t\tsetTimeout(() =&gt; {\n\t\t\t\tif (pendingReject) {\n\t\t\t\t\tpendingReject(new Error(\"Python execution timeout (60s)\"));\n\t\t\t\t\tpendingResolve = null;\n\t\t\t\t\tpendingReject = null;\n\t\t\t\t}\n\t\t\t}, 60_000);\n\t\t});\n\t}\n\n\treturn {\n\t\tget onLog() {\n\t\t\treturn onLogCb;\n\t\t},\n\t\tset onLog(cb: ((line: string) =&gt; void) | undefined) {\n\t\t\tonLogCb = cb;\n\t\t},\n\t\trun,\n\t\tterminate() {\n\t\t\tif (child) {\n\t\t\t\tchild.kill();\n\t\t\t\tchild = null;\n\t\t\t}\n\t\t\tif (pendingReject) {\n\t\t\t\tpendingReject(new Error(\"Kernel terminated\"));\n\t\t\t\tpendingResolve = null;\n\t\t\t\tpendingReject = null;\n\t\t\t}\n\t\t},\n\t};\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 17,
                "column": 1
              },
              "endPosition": {
                "line": 17,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 17,
                "column": 8
              },
              "endPosition": {
                "line": 18,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export function createPythonKernel(pythonPath: string): PythonKernel {",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "text": "function spawnProcess(): Promise&lt;void&gt; {",
            "lineNumber": 24
          },
          {
            "text": "(resolve, reject) =&gt; {",
            "lineNumber": 26
          },
          {
            "text": " catch (e) {",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t\treject(e);",
            "lineNumber": 68
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 69
          },
          {
            "text": "\t\t});",
            "lineNumber": 70
          },
          {
            "text": "\t}",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "\tasync function run(code: string, inputText: string): Promise&lt;string&gt; {",
            "lineNumber": 73
          },
          {
            "text": "\t\tawait spawnProcess();",
            "lineNumber": 74
          },
          {
            "text": "\t\tif (!child?.stdin) throw new Error(\"Python process not running\");",
            "lineNumber": 75
          },
          {
            "text": "\t\tconst fullCode =",
            "lineNumber": 76
          },
          {
            "text": "\t\t\tOBSIDIAN_LOG_STUB +",
            "lineNumber": 77
          },
          {
            "text": "\t\t\t\"\\ninput = \" +",
            "lineNumber": 78
          },
          {
            "text": "\t\t\tJSON.stringify(inputText) +",
            "lineNumber": 79
          },
          {
            "text": "\t\t\t\"\\n\\n\" +",
            "lineNumber": 80
          },
          {
            "text": "\t\t\tcode +",
            "lineNumber": 81
          },
          {
            "text": "\t\t\t\"\\nprint(\" +",
            "lineNumber": 82
          },
          {
            "text": "\t\t\tJSON.stringify(END_MARKER) +",
            "lineNumber": 83
          },
          {
            "text": "\t\t\t\")\\n\";",
            "lineNumber": 84
          },
          {
            "text": "\t\t// Encode as base64 so we can send without escaping issues",
            "lineNumber": 85
          },
          {
            "text": "\t\tconst b64 = Buffer.from(fullCode, \"utf-8\").toString(\"base64\");",
            "lineNumber": 86
          },
          {
            "text": "\t\tconst payload = &#96;exec(__import__('base64').b64decode(\"${b64}\").decode())\\n&#96;;",
            "lineNumber": 87
          },
          {
            "text": "\t\tstdoutBuf = \"\";",
            "lineNumber": 88
          },
          {
            "text": "\t\treturn new Promise((resolve, reject) =&gt; {",
            "lineNumber": 89
          },
          {
            "text": "\t\t\tpendingResolve = resolve;",
            "lineNumber": 90
          },
          {
            "text": "\t\t\tpendingReject = reject;",
            "lineNumber": 91
          },
          {
            "text": "\t\t\tchild!.stdin!.write(payload, (err) =&gt; {",
            "lineNumber": 92
          },
          {
            "text": "\t\t\t\tif (err) {",
            "lineNumber": 93
          },
          {
            "text": "\t\t\t\t\tpendingReject?.(err);",
            "lineNumber": 94
          },
          {
            "text": "\t\t\t\t\tpendingResolve = null;",
            "lineNumber": 95
          },
          {
            "text": "\t\t\t\t\tpendingReject = null;",
            "lineNumber": 96
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 97
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 98
          },
          {
            "text": "\t\t\tsetTimeout(() =&gt; {",
            "lineNumber": 99
          },
          {
            "text": "\t\t\t\tif (pendingReject) {",
            "lineNumber": 100
          },
          {
            "text": "\t\t\t\t\tpendingReject(new Error(\"Python execution timeout (60s)\"));",
            "lineNumber": 101
          },
          {
            "text": "\t\t\t\t\tpendingResolve = null;",
            "lineNumber": 102
          },
          {
            "text": "\t\t\t\t\tpendingReject = null;",
            "lineNumber": 103
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 104
          },
          {
            "text": "\t\t\t}, 60_000);",
            "lineNumber": 105
          },
          {
            "text": "\t\t});",
            "lineNumber": 106
          },
          {
            "text": "\t}",
            "lineNumber": 107
          },
          {
            "lineNumber": 108
          },
          {
            "text": "\treturn {",
            "lineNumber": 109
          },
          {
            "text": "\t\tget onLog() {",
            "lineNumber": 110
          },
          {
            "text": "\t\t\treturn onLogCb;",
            "lineNumber": 111
          },
          {
            "text": "\t\t},",
            "lineNumber": 112
          },
          {
            "text": "\t\tset onLog(cb: ((line: string) =&gt; void) | undefined) {",
            "lineNumber": 113
          },
          {
            "text": "\t\t\tonLogCb = cb;",
            "lineNumber": 114
          },
          {
            "text": "\t\t},",
            "lineNumber": 115
          },
          {
            "text": "\t\trun,",
            "lineNumber": 116
          },
          {
            "text": "\t\tterminate() {",
            "lineNumber": 117
          },
          {
            "text": "\t\t\tif (child) {",
            "lineNumber": 118
          },
          {
            "text": "\t\t\t\tchild.kill();",
            "lineNumber": 119
          },
          {
            "text": "\t\t\t\tchild = null;",
            "lineNumber": 120
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 121
          },
          {
            "text": "\t\t\tif (pendingReject) {",
            "lineNumber": 122
          },
          {
            "text": "\t\t\t\tpendingReject(new Error(\"Kernel terminated\"));",
            "lineNumber": 123
          },
          {
            "text": "\t\t\t\tpendingResolve = null;",
            "lineNumber": 124
          },
          {
            "text": "\t\t\t\tpendingReject = null;",
            "lineNumber": 125
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 126
          },
          {
            "text": "\t\t},",
            "lineNumber": 127
          },
          {
            "text": "\t};",
            "lineNumber": 128
          },
          {
            "text": "}",
            "lineNumber": 129,
            "isSignature": true
          }
        ]
      },
      "score": 0.4538213014602661
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 336
          },
          "endPosition": {
            "line": 459,
            "column": 99
          }
        },
        "contents": "async function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null,\n\trunStartData: RunStartCanvasData\n): Promise&lt;string&gt; {\n\n\tif (role === \"red\") {\n\t\tconst model = settings.ollamaRedModel || \"llama2\";\n\t\tconst temperature = settings.ollamaRedTemperature ?? DEFAULT_SETTINGS.ollamaRedTemperature;\n\t\tconst start = performance.now();\n\t\tconst result = await ollamaGenerate({\n\t\t\tmodel,\n\t\t\tprompt: fullPrompt,\n\t\t\tstream: false,\n\t\t\toptions: { temperature },\n\t\t});\n\t\tsetNodeDuration(canvasKey, nodeId, performance.now() - start);\n\t\tsetNodeResult(canvasKey, nodeId, result.response);\n\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {\n\t\t\tfullPrompt,\n\t\t\tthinking: result.thinking,\n\t\t});\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas, runStartData);\n\t\treturn result.response;\n\t}\n\tif (role === \"blue\") {\n\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);\n\t\tconst code = stripPythonCodeFence(template);\n\t\tconst result = await kernel.run(code, concatenatedPart);\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas, runStartData);\n\t\treturn result;\n\t}\n\treturn \"\";\n}\n\n/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 337,
                "column": 1
              },
              "endPosition": {
                "line": 347,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "async function runSingleNode(",
            "lineNumber": 337,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 338,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 339,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 340,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 341,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 342,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 343,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null,",
            "lineNumber": 344,
            "isSignature": true
          },
          {
            "text": "\trunStartData: RunStartCanvasData",
            "lineNumber": 345,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 346,
            "isSignature": true
          },
          {
            "lineNumber": 428
          },
          {
            "text": "\tif (role === \"red\") {",
            "lineNumber": 429
          },
          {
            "text": "\t\tconst model = settings.ollamaRedModel || \"llama2\";",
            "lineNumber": 430
          },
          {
            "text": "\t\tconst temperature = settings.ollamaRedTemperature ?? DEFAULT_SETTINGS.ollamaRedTemperature;",
            "lineNumber": 431
          },
          {
            "text": "\t\tconst start = performance.now();",
            "lineNumber": 432
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({",
            "lineNumber": 433
          },
          {
            "text": "\t\t\tmodel,",
            "lineNumber": 434
          },
          {
            "text": "\t\t\tprompt: fullPrompt,",
            "lineNumber": 435
          },
          {
            "text": "\t\t\tstream: false,",
            "lineNumber": 436
          },
          {
            "text": "\t\t\toptions: { temperature },",
            "lineNumber": 437
          },
          {
            "text": "\t\t});",
            "lineNumber": 438
          },
          {
            "text": "\t\tsetNodeDuration(canvasKey, nodeId, performance.now() - start);",
            "lineNumber": 439
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result.response);",
            "lineNumber": 440
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {",
            "lineNumber": 441
          },
          {
            "text": "\t\t\tfullPrompt,",
            "lineNumber": 442
          },
          {
            "text": "\t\t\tthinking: result.thinking,",
            "lineNumber": 443
          },
          {
            "text": "\t\t});",
            "lineNumber": 444
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas, runStartData);",
            "lineNumber": 445
          },
          {
            "text": "\t\treturn result.response;",
            "lineNumber": 446
          },
          {
            "text": "\t}",
            "lineNumber": 447
          },
          {
            "text": "\tif (role === \"blue\") {",
            "lineNumber": 448
          },
          {
            "text": "\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);",
            "lineNumber": 449
          },
          {
            "text": "\t\tconst code = stripPythonCodeFence(template);",
            "lineNumber": 450
          },
          {
            "text": "\t\tconst result = await kernel.run(code, concatenatedPart);",
            "lineNumber": 451
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 452
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 453
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas, runStartData);",
            "lineNumber": 454
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 455
          },
          {
            "text": "\t}",
            "lineNumber": 456
          },
          {
            "text": "\treturn \"\";",
            "lineNumber": 457
          },
          {
            "text": "}",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "lineNumber": 459
          },
          {
            "text": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
            "lineNumber": 460
          }
        ]
      },
      "score": 0.4335465133190155
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 179,
            "column": 1
          },
          "endPosition": {
            "line": 191,
            "column": 90
          }
        },
        "contents": "/** True if text is already wrapped in &#96;&#96;&#96;python or &#96;&#96;&#96; ... &#96;&#96;&#96;. */\nfunction isPythonCodeFenced(text: string): boolean {\n\tconst lines = text.trim().split(/\\r?\\n/);\n\tif (lines.length &lt; 2) return false;\n\tconst first = lines[0];\n\tconst last = lines[lines.length - 1];\n\tif (first == null || last == null) return false;\n\treturn /^&#96;&#96;&#96;(?:python)?\\s*$/i.test(first.trim()) &amp;&amp; /^&#96;&#96;&#96;\\s*$/.test(last.trim());\n}\n\n/** Wrap in &#96;&#96;&#96;python ... &#96;&#96;&#96; if not already fenced (so Obsidian renders # as comment). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** True if text is already wrapped in &#96;&#96;&#96;python or &#96;&#96;&#96; ... &#96;&#96;&#96;. */",
            "lineNumber": 182
          },
          {
            "text": "function isPythonCodeFenced(text: string): boolean {",
            "lineNumber": 183,
            "isSignature": true
          },
          {
            "text": "\tconst lines = text.trim().split(/\\r?\\n/);",
            "lineNumber": 184
          },
          {
            "text": "\tif (lines.length &lt; 2) return false;",
            "lineNumber": 185
          },
          {
            "text": "\tconst first = lines[0];",
            "lineNumber": 186
          },
          {
            "text": "\tconst last = lines[lines.length - 1];",
            "lineNumber": 187
          },
          {
            "text": "\tif (first == null || last == null) return false;",
            "lineNumber": 188
          },
          {
            "text": "\treturn /^&#96;&#96;&#96;(?:python)?\\s*$/i.test(first.trim()) &amp;&amp; /^&#96;&#96;&#96;\\s*$/.test(last.trim());",
            "lineNumber": 189
          },
          {
            "text": "}",
            "lineNumber": 190,
            "isSignature": true
          },
          {
            "lineNumber": 191
          },
          {
            "text": "/** Wrap in &#96;&#96;&#96;python ... &#96;&#96;&#96; if not already fenced (so Obsidian renders # as comment). */",
            "lineNumber": 192
          }
        ]
      },
      "score": 0.40688854455947876
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/pythonKernel.ts",
        "range": {
          "startPosition": {
            "line": 14,
            "column": 1
          },
          "endPosition": {
            "line": 128,
            "column": 1
          }
        },
        "contents": "export function createPythonKernel(pythonPath: string): PythonKernel {\n\tlet child: import(\"child_process\").ChildProcess | null = null;\n\tlet onLogCb: ((line: string) =&gt; void) | undefined;\n\tlet pendingResolve: ((value: string) =&gt; void) | null = null;\n\tlet pendingReject: ((err: Error) =&gt; void) | null = null;\n\tlet stdoutBuf = \"\";\n\n\tfunction spawnProcess(): Promise&lt;void&gt; {\n\t\tif (child) return Promise.resolve();\n\t\treturn new Promise((resolve, reject) =&gt; {\n\t\t\ttry {\n\t\t\t\tconst { spawn } = require(\"child_process\") as typeof import(\"child_process\");\n\t\t\t\tchild = spawn(pythonPath, [\"-u\", \"-i\"], {\n\t\t\t\t\tstdio: [\"pipe\", \"pipe\", \"pipe\"],\n\t\t\t\t\tshell: false,\n\t\t\t\t});\n\t\t\t\tchild.stdout?.on(\"data\", (chunk: Buffer) =&gt; {\n\t\t\t\t\tconst s = chunk.toString();\n\t\t\t\t\tstdoutBuf += s;\n\t\t\t\t\tif (stdoutBuf.includes(END_MARKER)) {\n\t\t\t\t\t\tconst parts = stdoutBuf.split(END_MARKER);\n\t\t\t\t\t\tstdoutBuf = parts.pop() ?? \"\";\n\t\t\t\t\t\tconst result = parts.join(END_MARKER).trim();\n\t\t\t\t\t\tif (pendingResolve) {\n\t\t\t\t\t\t\tpendingResolve(result);\n\t\t\t\t\t\t\tpendingResolve = null;\n\t\t\t\t\t\t\tpendingReject = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchild.stderr?.on(\"data\", (chunk: Buffer) =&gt; {\n\t\t\t\t\tconst s = chunk.toString();\n\t\t\t\t\tconst lines = s.split(\"\\n\");\n\t\t\t\t\tfor (const line of lines) {\n\t\t\t\t\t\tif (line.startsWith(\"OBSIDIAN_LOG:\")) {\n\t\t\t\t\t\t\tonLogCb?.(line.slice(\"OBSIDIAN_LOG:\".length).trim());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tchild.on(\"error\", reject);\n\t\t\t\tchild.on(\"exit\", (code) =&gt; {\n\t\t\t\t\tchild = null;\n\t\t\t\t\tif (pendingReject) {\n\t\t\t\t\t\tpendingReject(new Error(&#96;Python exited with code ${code ?? \"unknown\"}&#96;));\n\t\t\t\t\t\tpendingResolve = null;\n\t\t\t\t\t\tpendingReject = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// Allow process to start\n\t\t\t\tsetTimeout(() =&gt; resolve(), 100);\n\t\t\t} catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t});\n\t}\n\n\tasync function run(code: string, inputText: string): Promise&lt;string&gt; {\n\t\t\n\t}\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export function createPythonKernel(pythonPath: string): PythonKernel {",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "text": "\tlet child: import(\"child_process\").ChildProcess | null = null;",
            "lineNumber": 18
          },
          {
            "text": "\tlet onLogCb: ((line: string) =&gt; void) | undefined;",
            "lineNumber": 19
          },
          {
            "text": "\tlet pendingResolve: ((value: string) =&gt; void) | null = null;",
            "lineNumber": 20
          },
          {
            "text": "\tlet pendingReject: ((err: Error) =&gt; void) | null = null;",
            "lineNumber": 21
          },
          {
            "text": "\tlet stdoutBuf = \"\";",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "\tfunction spawnProcess(): Promise&lt;void&gt; {",
            "lineNumber": 24
          },
          {
            "text": "\t\tif (child) return Promise.resolve();",
            "lineNumber": 25
          },
          {
            "text": "\t\treturn new Promise((resolve, reject) =&gt; {",
            "lineNumber": 26
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 27
          },
          {
            "text": "\t\t\t\tconst { spawn } = require(\"child_process\") as typeof import(\"child_process\");",
            "lineNumber": 28
          },
          {
            "text": "\t\t\t\tchild = spawn(pythonPath, [\"-u\", \"-i\"], {",
            "lineNumber": 29
          },
          {
            "text": "\t\t\t\t\tstdio: [\"pipe\", \"pipe\", \"pipe\"],",
            "lineNumber": 30
          },
          {
            "text": "\t\t\t\t\tshell: false,",
            "lineNumber": 31
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 32
          },
          {
            "text": "\t\t\t\tchild.stdout?.on(\"data\", (chunk: Buffer) =&gt; {",
            "lineNumber": 33
          },
          {
            "text": "\t\t\t\t\tconst s = chunk.toString();",
            "lineNumber": 34
          },
          {
            "text": "\t\t\t\t\tstdoutBuf += s;",
            "lineNumber": 35
          },
          {
            "text": "\t\t\t\t\tif (stdoutBuf.includes(END_MARKER)) {",
            "lineNumber": 36
          },
          {
            "text": "\t\t\t\t\t\tconst parts = stdoutBuf.split(END_MARKER);",
            "lineNumber": 37
          },
          {
            "text": "\t\t\t\t\t\tstdoutBuf = parts.pop() ?? \"\";",
            "lineNumber": 38
          },
          {
            "text": "\t\t\t\t\t\tconst result = parts.join(END_MARKER).trim();",
            "lineNumber": 39
          },
          {
            "text": "\t\t\t\t\t\tif (pendingResolve) {",
            "lineNumber": 40
          },
          {
            "text": "\t\t\t\t\t\t\tpendingResolve(result);",
            "lineNumber": 41
          },
          {
            "text": "\t\t\t\t\t\t\tpendingResolve = null;",
            "lineNumber": 42
          },
          {
            "text": "\t\t\t\t\t\t\tpendingReject = null;",
            "lineNumber": 43
          },
          {
            "text": "\t\t\t\t\t\t}",
            "lineNumber": 44
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 45
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 46
          },
          {
            "text": "\t\t\t\tchild.stderr?.on(\"data\", (chunk: Buffer) =&gt; {",
            "lineNumber": 47
          },
          {
            "text": "\t\t\t\t\tconst s = chunk.toString();",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\t\tconst lines = s.split(\"\\n\");",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t\t\tfor (const line of lines) {",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t\t\t\tif (line.startsWith(\"OBSIDIAN_LOG:\")) {",
            "lineNumber": 51
          },
          {
            "text": "\t\t\t\t\t\t\tonLogCb?.(line.slice(\"OBSIDIAN_LOG:\".length).trim());",
            "lineNumber": 52
          },
          {
            "text": "\t\t\t\t\t\t}",
            "lineNumber": 53
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 54
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 55
          },
          {
            "text": "\t\t\t\tchild.on(\"error\", reject);",
            "lineNumber": 56
          },
          {
            "text": "\t\t\t\tchild.on(\"exit\", (code) =&gt; {",
            "lineNumber": 57
          },
          {
            "text": "\t\t\t\t\tchild = null;",
            "lineNumber": 58
          },
          {
            "text": "\t\t\t\t\tif (pendingReject) {",
            "lineNumber": 59
          },
          {
            "text": "\t\t\t\t\t\tpendingReject(new Error(&#96;Python exited with code ${code ?? \"unknown\"}&#96;));",
            "lineNumber": 60
          },
          {
            "text": "\t\t\t\t\t\tpendingResolve = null;",
            "lineNumber": 61
          },
          {
            "text": "\t\t\t\t\t\tpendingReject = null;",
            "lineNumber": 62
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 63
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 64
          },
          {
            "text": "\t\t\t\t// Allow process to start",
            "lineNumber": 65
          },
          {
            "text": "\t\t\t\tsetTimeout(() =&gt; resolve(), 100);",
            "lineNumber": 66
          },
          {
            "text": "\t\t\t} catch (e) {",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t\treject(e);",
            "lineNumber": 68
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 69
          },
          {
            "text": "\t\t});",
            "lineNumber": 70
          },
          {
            "text": "\t}",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "\tasync function run(code: string, inputText: string): Promise&lt;string&gt; {",
            "lineNumber": 73
          },
          {
            "text": "\t\t",
            "lineNumber": 74
          },
          {
            "text": "\t}",
            "lineNumber": 107
          },
          {
            "text": "}",
            "lineNumber": 129,
            "isSignature": true
          }
        ]
      },
      "score": 0.32975149154663086
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/pythonKernel.ts",
        "range": {
          "startPosition": {
            "column": 133
          },
          "endPosition": {
            "line": 14,
            "column": 1
          }
        },
        "contents": "export const OBSIDIAN_LOG_STUB = &#96;\nimport sys\ndef obsidian_log(*args):\n    msg = \" \".join(str(a) for a in args)\n    print(\"OBSIDIAN_LOG:\" + msg, file=sys.stderr, flush=True)\n&#96;;\n\nconst END_MARKER = \"__ZTB_END__\";\n\nexport interface PythonKernel {\n\trun\n;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export const OBSIDIAN_LOG_STUB = &#96;",
            "lineNumber": 2
          },
          {
            "text": "import sys",
            "lineNumber": 3
          },
          {
            "text": "def obsidian_log(*args):",
            "lineNumber": 4
          },
          {
            "text": "    msg = \" \".join(str(a) for a in args)",
            "lineNumber": 5
          },
          {
            "text": "    print(\"OBSIDIAN_LOG:\" + msg, file=sys.stderr, flush=True)",
            "lineNumber": 6
          },
          {
            "text": "&#96;;",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "const END_MARKER = \"__ZTB_END__\";",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "export interface PythonKernel {",
            "lineNumber": 11,
            "isSignature": true
          },
          {
            "text": "\trun",
            "lineNumber": 12
          },
          {
            "text": ";",
            "lineNumber": 14,
            "isSignature": true
          },
          {
            "text": "}",
            "lineNumber": 15,
            "isSignature": true
          }
        ]
      },
      "score": 0.30922719836235046
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 340
          },
          "endPosition": {
            "line": 1010,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\n\n\n\t/** Process the next job in the run queue, if any. */\n\tprivate async processQueue(): Promise&lt;void&gt; {\n\t\tconst job = dequeueRun();\n\t\tif (job == null) {\n\t\t\tclearRunStartCanvasData();\n\t\t\treturn;\n\t\t}\n\t\tif (job.type === \"chain\" &amp;&amp; \"nodeId\" in job) {\n\t\t\tconst chainIds = await getChainNodeIds(this.app, this.settings, job.canvasFilePath, job.nodeId);\n\t\t\tif (chainIds &amp;&amp; chainIds.length &gt; 0) {\n\t\t\t\tremoveQueuedNodeIds(getCanvasKey(job.canvasFilePath), chainIds);\n\t\t\t}\n\t\t}\n\t\tsetRunInProgress(true);\n\t\tconst view = this.getCanvasViewByPath(job.canvasFilePath);\n\t\t// Run-start data is set by the first run (runNode/runChain/runEntireCanvas); queued jobs use it\n\t\tconst liveCanvas = view\n\t\t\t? (view.canvas as import(\"./engine/canvasApi\").LiveCanvas)\n\t\t\t: null;\n\t\tif (view &amp;&amp; liveCanvas) {\n\t\t\tconst viewWithData = view as unknown as { getData?: () =&gt; unknown };\n\t\t\tif (!liveCanvas.getData &amp;&amp; typeof viewWithData.getData === \"function\") {\n\t\t\t\t(liveCanvas as { getData?: () =&gt; unknown }).getData = () =&gt; viewWithData.getData?.();\n\t\t\t}\n\t\t}\n\t\tconst runStartData = getRunStartCanvasData(getCanvasKey(job.canvasFilePath));\n\t\ttry {\n\t\t\tif (job.type === \"node\" &amp;&amp; \"nodeId\" in job) {\n\t\t\t\tconst result = await runnerRunNode(this.app, this.settings, job.canvasFilePath, job.nodeId, liveCanvas, runStartData);\n\t\t\t\tif (!result.ok) new Notice(result.message ?? \"Run node failed.\");\n\t\t\t} else if (job.type === \"chain\" &amp;&amp; \"nodeId\" in job) {\n\t\t\t\tconst result = await runnerRunChain(this.app, this.settings, job.canvasFilePath, job.nodeId, liveCanvas, undefined, runStartData);\n\t\t\t\tif (!result.ok) new Notice(result.message ?? \"Run chain failed.\");\n\t\t\t} else if (job.type === \"entire\") {\n\t\t\t\tconst result = await runnerRunEntireCanvas(this.app, this.settings, job.canvasFilePath, liveCanvas, runStartData);\n\t\t\t\tif (!result.ok) new Notice(result.message ?? \"Run entire canvas failed.\");\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnew Notice(e instanceof Error ? e.message : String(e));\n\t\t} finally {\n\t\t\tsetRunInProgress(false);\n\t\t\tawait this.processQueue();\n\t\t}\n\t}\n\n\t/** Run a single node (call from context menu with node id). */\n\tasync runNode(nodeId: string): Promise&lt;void&gt; {\n\t\tconst view = this.getActiveCanvasView();\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 341,
                "column": 1
              },
              "endPosition": {
                "line": 341,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 341,
                "column": 16
              },
              "endPosition": {
                "line": 342,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 341,
            "isSignature": true
          },
          {
            "lineNumber": 838
          },
          {
            "lineNumber": 839
          },
          {
            "text": "\t/** Process the next job in the run queue, if any. */",
            "lineNumber": 840
          },
          {
            "text": "\tprivate async processQueue(): Promise&lt;void&gt; {",
            "lineNumber": 841
          },
          {
            "text": "\t\tconst job = dequeueRun();",
            "lineNumber": 842
          },
          {
            "text": "\t\tif (job == null) {",
            "lineNumber": 843
          },
          {
            "text": "\t\t\tclearRunStartCanvasData();",
            "lineNumber": 844
          },
          {
            "text": "\t\t\treturn;",
            "lineNumber": 845
          },
          {
            "text": "\t\t}",
            "lineNumber": 846
          },
          {
            "text": "\t\tif (job.type === \"chain\" &amp;&amp; \"nodeId\" in job) {",
            "lineNumber": 847
          },
          {
            "text": "\t\t\tconst chainIds = await getChainNodeIds(this.app, this.settings, job.canvasFilePath, job.nodeId);",
            "lineNumber": 848
          },
          {
            "text": "\t\t\tif (chainIds &amp;&amp; chainIds.length &gt; 0) {",
            "lineNumber": 849
          },
          {
            "text": "\t\t\t\tremoveQueuedNodeIds(getCanvasKey(job.canvasFilePath), chainIds);",
            "lineNumber": 850
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 851
          },
          {
            "text": "\t\t}",
            "lineNumber": 852
          },
          {
            "text": "\t\tsetRunInProgress(true);",
            "lineNumber": 853
          },
          {
            "text": "\t\tconst view = this.getCanvasViewByPath(job.canvasFilePath);",
            "lineNumber": 854
          },
          {
            "text": "\t\t// Run-start data is set by the first run (runNode/runChain/runEntireCanvas); queued jobs use it",
            "lineNumber": 855
          },
          {
            "text": "\t\tconst liveCanvas = view",
            "lineNumber": 856
          },
          {
            "text": "\t\t\t? (view.canvas as import(\"./engine/canvasApi\").LiveCanvas)",
            "lineNumber": 857
          },
          {
            "text": "\t\t\t: null;",
            "lineNumber": 858
          },
          {
            "text": "\t\tif (view &amp;&amp; liveCanvas) {",
            "lineNumber": 859
          },
          {
            "text": "\t\t\tconst viewWithData = view as unknown as { getData?: () =&gt; unknown };",
            "lineNumber": 860
          },
          {
            "text": "\t\t\tif (!liveCanvas.getData &amp;&amp; typeof viewWithData.getData === \"function\") {",
            "lineNumber": 861
          },
          {
            "text": "\t\t\t\t(liveCanvas as { getData?: () =&gt; unknown }).getData = () =&gt; viewWithData.getData?.();",
            "lineNumber": 862
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 863
          },
          {
            "text": "\t\t}",
            "lineNumber": 864
          },
          {
            "text": "\t\tconst runStartData = getRunStartCanvasData(getCanvasKey(job.canvasFilePath));",
            "lineNumber": 865
          },
          {
            "text": "\t\ttry {",
            "lineNumber": 866
          },
          {
            "text": "\t\t\tif (job.type === \"node\" &amp;&amp; \"nodeId\" in job) {",
            "lineNumber": 867
          },
          {
            "text": "\t\t\t\tconst result = await runnerRunNode(this.app, this.settings, job.canvasFilePath, job.nodeId, liveCanvas, runStartData);",
            "lineNumber": 868
          },
          {
            "text": "\t\t\t\tif (!result.ok) new Notice(result.message ?? \"Run node failed.\");",
            "lineNumber": 869
          },
          {
            "text": "\t\t\t} else if (job.type === \"chain\" &amp;&amp; \"nodeId\" in job) {",
            "lineNumber": 870
          },
          {
            "text": "\t\t\t\tconst result = await runnerRunChain(this.app, this.settings, job.canvasFilePath, job.nodeId, liveCanvas, undefined, runStartData);",
            "lineNumber": 871
          },
          {
            "text": "\t\t\t\tif (!result.ok) new Notice(result.message ?? \"Run chain failed.\");",
            "lineNumber": 872
          },
          {
            "text": "\t\t\t} else if (job.type === \"entire\") {",
            "lineNumber": 873
          },
          {
            "text": "\t\t\t\tconst result = await runnerRunEntireCanvas(this.app, this.settings, job.canvasFilePath, liveCanvas, runStartData);",
            "lineNumber": 874
          },
          {
            "text": "\t\t\t\tif (!result.ok) new Notice(result.message ?? \"Run entire canvas failed.\");",
            "lineNumber": 875
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 876
          },
          {
            "text": "\t\t} catch (e) {",
            "lineNumber": 877
          },
          {
            "text": "\t\t\tnew Notice(e instanceof Error ? e.message : String(e));",
            "lineNumber": 878
          },
          {
            "text": "\t\t} finally {",
            "lineNumber": 879
          },
          {
            "text": "\t\t\tsetRunInProgress(false);",
            "lineNumber": 880
          },
          {
            "text": "\t\t\tawait this.processQueue();",
            "lineNumber": 881
          },
          {
            "text": "\t\t}",
            "lineNumber": 882
          },
          {
            "text": "\t}",
            "lineNumber": 883
          },
          {
            "lineNumber": 884
          },
          {
            "text": "\t/** Run a single node (call from context menu with node id). */",
            "lineNumber": 885
          },
          {
            "text": "\tasync runNode(nodeId: string): Promise&lt;void&gt; {",
            "lineNumber": 886
          },
          {
            "text": "\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 887
          },
          {
            "text": "\t}",
            "lineNumber": 915
          },
          {
            "text": "}",
            "lineNumber": 1011,
            "isSignature": true
          }
        ]
      },
      "score": 0.2707442045211792
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 208,
            "column": 1
          },
          "endPosition": {
            "line": 252,
            "column": 108
          }
        },
        "contents": "/** Build concatenated context, template with {{var:name}} (and optionally {{name}}) substituted, and per-edge mode. */\nfunction buildInputWithVariables(\n\tcanvasKey: string,\n\tnodeInput: string,\n\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[],\n\tsettings: ZettelPluginSettings\n): { concatenatedPart: string; template: string; edgeModes: Map&lt;string, EdgeInputMode&gt; } {\n\tconst edgeModes = new Map&lt;string, EdgeInputMode&gt;();\n\tconst parentResults = new Map&lt;string, string&gt;();\n\tfor (const { parentId } of incoming) {\n\t\tconst r = getNodeResult(canvasKey, parentId);\n\t\tif (r != null) parentResults.set(parentId, r);\n\t}\n\tlet concatenatedPart = \"\";\n\tconst varValues: Record&lt;string, string&gt; = {};\n\tconst shorthand = settings.supportShorthandPlaceholders;\n\tfor (const { parentId, edge, variableName } of incoming) {\n\t\tconst result = parentResults.get(parentId);\n\t\tif (result == null) continue;\n\t\tconst usedAsVar =\n\t\t\tvariableName.length &gt; 0 &amp;&amp;\n\t\t\t(nodeInput.includes(&#96;{{var:${variableName}}}&#96;) || (shorthand &amp;&amp; nodeInput.includes(&#96;{{${variableName}}}&#96;)));\n\t\tif (usedAsVar) {\n\t\t\tedgeModes.set(edge.id, \"inject\");\n\t\t\tvarValues[variableName] = result;\n\t\t} else {\n\t\t\tedgeModes.set(edge.id, \"concatenate\");\n\t\t\tconcatenatedPart += result + \"\\n\\n\";\n\t\t}\n\t}\n\tlet template = nodeInput;\n\tfor (const [name, value] of Object.entries(varValues)) {\n\t\ttemplate = template.split(&#96;{{var:${name}}}&#96;).join(value);\n\t\tif (shorthand) template = template.split(&#96;{{${name}}}&#96;).join(value);\n\t}\n\treturn {\n\t\tconcatenatedPart: concatenatedPart.trim(),\n\t\ttemplate,\n\t\tedgeModes,\n\t};\n}\n\n/** Set of node ids that are our output/prompt/thinking nodes; we must not overwrite them with live data. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build concatenated context, template with {{var:name}} (and optionally {{name}}) substituted, and per-edge mode. */",
            "lineNumber": 211
          },
          {
            "text": "function buildInputWithVariables(",
            "lineNumber": 212,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 213,
            "isSignature": true
          },
          {
            "text": "\tnodeInput: string,",
            "lineNumber": 214,
            "isSignature": true
          },
          {
            "text": "\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[],",
            "lineNumber": 215,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 216,
            "isSignature": true
          },
          {
            "text": "): { concatenatedPart: string; template: string; edgeModes: Map&lt;string, EdgeInputMode&gt; } {",
            "lineNumber": 217,
            "isSignature": true
          },
          {
            "text": "\tconst edgeModes = new Map&lt;string, EdgeInputMode&gt;();",
            "lineNumber": 218
          },
          {
            "text": "\tconst parentResults = new Map&lt;string, string&gt;();",
            "lineNumber": 219
          },
          {
            "text": "\tfor (const { parentId } of incoming) {",
            "lineNumber": 220
          },
          {
            "text": "\t\tconst r = getNodeResult(canvasKey, parentId);",
            "lineNumber": 221
          },
          {
            "text": "\t\tif (r != null) parentResults.set(parentId, r);",
            "lineNumber": 222
          },
          {
            "text": "\t}",
            "lineNumber": 223
          },
          {
            "text": "\tlet concatenatedPart = \"\";",
            "lineNumber": 224
          },
          {
            "text": "\tconst varValues: Record&lt;string, string&gt; = {};",
            "lineNumber": 225
          },
          {
            "text": "\tconst shorthand = settings.supportShorthandPlaceholders;",
            "lineNumber": 226
          },
          {
            "text": "\tfor (const { parentId, edge, variableName } of incoming) {",
            "lineNumber": 227
          },
          {
            "text": "\t\tconst result = parentResults.get(parentId);",
            "lineNumber": 228
          },
          {
            "text": "\t\tif (result == null) continue;",
            "lineNumber": 229
          },
          {
            "text": "\t\tconst usedAsVar =",
            "lineNumber": 230
          },
          {
            "text": "\t\t\tvariableName.length &gt; 0 &amp;&amp;",
            "lineNumber": 231
          },
          {
            "text": "\t\t\t(nodeInput.includes(&#96;{{var:${variableName}}}&#96;) || (shorthand &amp;&amp; nodeInput.includes(&#96;{{${variableName}}}&#96;)));",
            "lineNumber": 232
          },
          {
            "text": "\t\tif (usedAsVar) {",
            "lineNumber": 233
          },
          {
            "text": "\t\t\tedgeModes.set(edge.id, \"inject\");",
            "lineNumber": 234
          },
          {
            "text": "\t\t\tvarValues[variableName] = result;",
            "lineNumber": 235
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 236
          },
          {
            "text": "\t\t\tedgeModes.set(edge.id, \"concatenate\");",
            "lineNumber": 237
          },
          {
            "text": "\t\t\tconcatenatedPart += result + \"\\n\\n\";",
            "lineNumber": 238
          },
          {
            "text": "\t\t}",
            "lineNumber": 239
          },
          {
            "text": "\t}",
            "lineNumber": 240
          },
          {
            "text": "\tlet template = nodeInput;",
            "lineNumber": 241
          },
          {
            "text": "\tfor (const [name, value] of Object.entries(varValues)) {",
            "lineNumber": 242
          },
          {
            "text": "\t\ttemplate = template.split(&#96;{{var:${name}}}&#96;).join(value);",
            "lineNumber": 243
          },
          {
            "text": "\t\tif (shorthand) template = template.split(&#96;{{${name}}}&#96;).join(value);",
            "lineNumber": 244
          },
          {
            "text": "\t}",
            "lineNumber": 245
          },
          {
            "text": "\treturn {",
            "lineNumber": 246
          },
          {
            "text": "\t\tconcatenatedPart: concatenatedPart.trim(),",
            "lineNumber": 247
          },
          {
            "text": "\t\ttemplate,",
            "lineNumber": 248
          },
          {
            "text": "\t\tedgeModes,",
            "lineNumber": 249
          },
          {
            "text": "\t};",
            "lineNumber": 250
          },
          {
            "text": "}",
            "lineNumber": 251,
            "isSignature": true
          },
          {
            "lineNumber": 252
          },
          {
            "text": "/** Set of node ids that are our output/prompt/thinking nodes; we must not overwrite them with live data. */",
            "lineNumber": 253
          }
        ]
      },
      "score": 0.27048689126968384
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/pythonKernel.ts",
        "range": {
          "startPosition": {
            "line": 1
          },
          "endPosition": {
            "line": 128,
            "column": 1
          }
        },
        "contents": "export const OBSIDIAN_LOG_STUB = &#96;\n&#96;;\n\nconst END_MARKER = \"__ZTB_END__\";\n\nexport interface PythonKernel {\n\trun(code: string, inputText: string): Promise&lt;string&gt;;\n\tonLog?: ((line: string) =&gt; void) | undefined;\n\tterminate(): void;\n}\n\nexport function createPythonKernel(pythonPath: string): PythonKernel {\n\tlet child: import(\"child_process\").ChildProcess | null = null;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export const OBSIDIAN_LOG_STUB = &#96;",
            "lineNumber": 2
          },
          {
            "text": "&#96;;",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "const END_MARKER = \"__ZTB_END__\";",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "export interface PythonKernel {",
            "lineNumber": 11,
            "isSignature": true
          },
          {
            "text": "\trun(code: string, inputText: string): Promise&lt;string&gt;;",
            "lineNumber": 12
          },
          {
            "text": "\tonLog?: ((line: string) =&gt; void) | undefined;",
            "lineNumber": 13
          },
          {
            "text": "\tterminate(): void;",
            "lineNumber": 14,
            "isSignature": true
          },
          {
            "text": "}",
            "lineNumber": 15,
            "isSignature": true
          },
          {
            "lineNumber": 16
          },
          {
            "text": "export function createPythonKernel(pythonPath: string): PythonKernel {",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "text": "\tlet child: import(\"child_process\").ChildProcess | null = null;",
            "lineNumber": 18
          },
          {
            "text": "}",
            "lineNumber": 129,
            "isSignature": true
          }
        ]
      },
      "score": 0.2670820951461792
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 844,
            "column": 1
          },
          "endPosition": {
            "line": 880,
            "column": 93
          }
        },
        "contents": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */\nexport async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null,\n\trunStartData?: RunStartCanvasData | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return { ok: false, message: \"Node not found.\" };\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };\n\tconst parentIds = getParentIdsSortedByY(nodeId, data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tfor (const pid of parentIds) {\n\t\tif (getNodeResult(canvasKey, pid) == null) {\n\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas, nodeId, runStartData ?? null);\n\t\t}\n\t}\n\ttry {\n\t\tsetRunningNodeId(canvasKey, nodeId);\n\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas, runStartData ?? null);\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t} finally {\n\t\tsetRunningNodeId(canvasKey, null);\n\t}\n}\n\nconst CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 847
          },
          {
            "text": "export async function runNode(",
            "lineNumber": 848,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 849,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 850,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 851,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 852,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null,",
            "lineNumber": 853,
            "isSignature": true
          },
          {
            "text": "\trunStartData?: RunStartCanvasData | null",
            "lineNumber": 854,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 855,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 856
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 857
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 858
          },
          {
            "text": "\tif (!node) return { ok: false, message: \"Node not found.\" };",
            "lineNumber": 859
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 860
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 861
          },
          {
            "text": "\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };",
            "lineNumber": 862
          },
          {
            "text": "\tconst parentIds = getParentIdsSortedByY(nodeId, data);",
            "lineNumber": 863
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 864
          },
          {
            "text": "\tfor (const pid of parentIds) {",
            "lineNumber": 865
          },
          {
            "text": "\t\tif (getNodeResult(canvasKey, pid) == null) {",
            "lineNumber": 866
          },
          {
            "text": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas, nodeId, runStartData ?? null);",
            "lineNumber": 867
          },
          {
            "text": "\t\t}",
            "lineNumber": 868
          },
          {
            "text": "\t}",
            "lineNumber": 869
          },
          {
            "text": "\ttry {",
            "lineNumber": 870
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, nodeId);",
            "lineNumber": 871
          },
          {
            "text": "\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas, runStartData ?? null);",
            "lineNumber": 872
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 873
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 874
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 875
          },
          {
            "text": "\t} finally {",
            "lineNumber": 876
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 877
          },
          {
            "text": "\t}",
            "lineNumber": 878
          },
          {
            "text": "}",
            "lineNumber": 879,
            "isSignature": true
          },
          {
            "lineNumber": 880
          },
          {
            "text": "const CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";",
            "lineNumber": 881
          }
        ]
      },
      "score": 0.265093594789505
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./README.md",
        "range": {
          "startPosition": {
            "line": 271
          },
          "endPosition": {
            "line": 282
          }
        },
        "contents": "*   **Build:** &#96;npm run build&#96;\n*   **Tests:** &#96;npm run test&#96; (unit tests with Vitest). &#96;npm run test:watch&#96; for watch mode.\n*   **Deploy to a test vault:** Run &#96;npm run deploy-to-vault&#96; to build and copy &#96;main.js&#96;, &#96;manifest.json&#96;, and &#96;styles.css&#96; into the &#96;zettel-thinking-board/&#96; folder. Copy that folder into your vault at &#96;.obsidian/plugins/zettel-thinking-board/&#96;, then reload the plugin in Obsidian. Alternatively, use the provided &#96;sendToNovelVault.sh&#96; script (edit the path inside it to point at your vault) to build and copy in one step.\n\n##  Security Warning\nThis plugin allows the execution of **arbitrary Python code** on your machine via the Canvas.\n*   **Never** run a canvas file you downloaded from an untrusted source.\n*   The Python process runs with your user privileges.\n\n##  License\nMIT",
        "signatures": {},
        "detailedLines": [
          {
            "text": "*   **Build:** &#96;npm run build&#96;",
            "lineNumber": 272
          },
          {
            "text": "*   **Tests:** &#96;npm run test&#96; (unit tests with Vitest). &#96;npm run test:watch&#96; for watch mode.",
            "lineNumber": 273
          },
          {
            "text": "*   **Deploy to a test vault:** Run &#96;npm run deploy-to-vault&#96; to build and copy &#96;main.js&#96;, &#96;manifest.json&#96;, and &#96;styles.css&#96; into the &#96;zettel-thinking-board/&#96; folder. Copy that folder into your vault at &#96;.obsidian/plugins/zettel-thinking-board/&#96;, then reload the plugin in Obsidian. Alternatively, use the provided &#96;sendToNovelVault.sh&#96; script (edit the path inside it to point at your vault) to build and copy in one step.",
            "lineNumber": 274
          },
          {
            "lineNumber": 275
          },
          {
            "text": "##  Security Warning",
            "lineNumber": 276
          },
          {
            "text": "This plugin allows the execution of **arbitrary Python code** on your machine via the Canvas.",
            "lineNumber": 277
          },
          {
            "text": "*   **Never** run a canvas file you downloaded from an untrusted source.",
            "lineNumber": 278
          },
          {
            "text": "*   The Python process runs with your user privileges.",
            "lineNumber": 279
          },
          {
            "lineNumber": 280
          },
          {
            "text": "##  License",
            "lineNumber": 281
          },
          {
            "text": "MIT",
            "lineNumber": 282
          }
        ]
      },
      "score": 0.25556516647338867
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 340
          },
          "endPosition": {
            "line": 1010,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\n\n\n\t/** Run a single node (call from context menu with node id). */\n\tasync runNode(nodeId: string): Promise&lt;void&gt; {\n\t\tconst view = this.getActiveCanvasView();\n\t\tif (!view) return;\n\t\tif (getRunInProgress()) {\n\t\t\tenqueueRun({ type: \"node\", canvasFilePath: view.file.path, nodeId });\n\t\t\tnew Notice(\"Run queued.\");\n\t\t\tconst active = this.getActiveCanvasView();\n\t\t\tif (active?.file.path === view.file.path) {\n\t\t\t\tconst liveCanvas = active.canvas as import(\"./engine/canvasApi\").LiveCanvas;\n\t\t\t\tconst isStillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === view.containerEl;\n\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, view.file.path, view.containerEl, liveCanvas, isStillActive);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst canvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;\n\t\tconst liveCanvas = canvas;\n\t\tconst viewWithData = view as unknown as { getData?: () =&gt; unknown };\n\t\tif (!liveCanvas.getData &amp;&amp; typeof viewWithData.getData === \"function\") {\n\t\t\t(liveCanvas as { getData?: () =&gt; unknown }).getData = () =&gt; viewWithData.getData?.();\n\t\t}\n\t\tsetRunInProgress(true);\n\t\tsetRunStartCanvasData(getCanvasKey(view.file.path), liveCanvas.getData?.() ?? null);\n\t\ttry {\n\t\t\tconst result = await runnerRunNode(this.app, this.settings, view.file.path, nodeId, liveCanvas, getRunStartCanvasData(getCanvasKey(view.file.path)));\n\t\t\tif (!result.ok) new Notice(result.message ?? \"Run node failed.\");\n\t\t} finally {\n\t\t\tsetRunInProgress(false);\n\t\t\tawait this.processQueue();\n\t\t}\n\t}\n\n\t/** Run chain from roots to the given node (call from context menu with node id). */\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 341,
                "column": 1
              },
              "endPosition": {
                "line": 341,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 341,
                "column": 16
              },
              "endPosition": {
                "line": 342,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 341,
            "isSignature": true
          },
          {
            "lineNumber": 883
          },
          {
            "lineNumber": 884
          },
          {
            "text": "\t/** Run a single node (call from context menu with node id). */",
            "lineNumber": 885
          },
          {
            "text": "\tasync runNode(nodeId: string): Promise&lt;void&gt; {",
            "lineNumber": 886
          },
          {
            "text": "\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 887
          },
          {
            "text": "\t\tif (!view) return;",
            "lineNumber": 888
          },
          {
            "text": "\t\tif (getRunInProgress()) {",
            "lineNumber": 889
          },
          {
            "text": "\t\t\tenqueueRun({ type: \"node\", canvasFilePath: view.file.path, nodeId });",
            "lineNumber": 890
          },
          {
            "text": "\t\t\tnew Notice(\"Run queued.\");",
            "lineNumber": 891
          },
          {
            "text": "\t\t\tconst active = this.getActiveCanvasView();",
            "lineNumber": 892
          },
          {
            "text": "\t\t\tif (active?.file.path === view.file.path) {",
            "lineNumber": 893
          },
          {
            "text": "\t\t\t\tconst liveCanvas = active.canvas as import(\"./engine/canvasApi\").LiveCanvas;",
            "lineNumber": 894
          },
          {
            "text": "\t\t\t\tconst isStillActive = (): boolean =&gt; this.getActiveCanvasView()?.containerEl === view.containerEl;",
            "lineNumber": 895
          },
          {
            "text": "\t\t\t\tsyncCanvasEdgeModeLabels(this.app.vault, view.file.path, view.containerEl, liveCanvas, isStillActive);",
            "lineNumber": 896
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 897
          },
          {
            "text": "\t\t\treturn;",
            "lineNumber": 898
          },
          {
            "text": "\t\t}",
            "lineNumber": 899
          },
          {
            "text": "\t\tconst canvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;",
            "lineNumber": 900
          },
          {
            "text": "\t\tconst liveCanvas = canvas;",
            "lineNumber": 901
          },
          {
            "text": "\t\tconst viewWithData = view as unknown as { getData?: () =&gt; unknown };",
            "lineNumber": 902
          },
          {
            "text": "\t\tif (!liveCanvas.getData &amp;&amp; typeof viewWithData.getData === \"function\") {",
            "lineNumber": 903
          },
          {
            "text": "\t\t\t(liveCanvas as { getData?: () =&gt; unknown }).getData = () =&gt; viewWithData.getData?.();",
            "lineNumber": 904
          },
          {
            "text": "\t\t}",
            "lineNumber": 905
          },
          {
            "text": "\t\tsetRunInProgress(true);",
            "lineNumber": 906
          },
          {
            "text": "\t\tsetRunStartCanvasData(getCanvasKey(view.file.path), liveCanvas.getData?.() ?? null);",
            "lineNumber": 907
          },
          {
            "text": "\t\ttry {",
            "lineNumber": 908
          },
          {
            "text": "\t\t\tconst result = await runnerRunNode(this.app, this.settings, view.file.path, nodeId, liveCanvas, getRunStartCanvasData(getCanvasKey(view.file.path)));",
            "lineNumber": 909
          },
          {
            "text": "\t\t\tif (!result.ok) new Notice(result.message ?? \"Run node failed.\");",
            "lineNumber": 910
          },
          {
            "text": "\t\t} finally {",
            "lineNumber": 911
          },
          {
            "text": "\t\t\tsetRunInProgress(false);",
            "lineNumber": 912
          },
          {
            "text": "\t\t\tawait this.processQueue();",
            "lineNumber": 913
          },
          {
            "text": "\t\t}",
            "lineNumber": 914
          },
          {
            "text": "\t}",
            "lineNumber": 915
          },
          {
            "lineNumber": 916
          },
          {
            "text": "\t/** Run chain from roots to the given node (call from context menu with node id). */",
            "lineNumber": 917
          },
          {
            "text": "}",
            "lineNumber": 1011,
            "isSignature": true
          }
        ]
      },
      "score": 0.25184404850006104
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./README.md",
        "range": {
          "startPosition": {
            "line": 64
          },
          "endPosition": {
            "line": 118
          }
        },
        "contents": "*   **Download time:** ~5-10 minutes\n\nEach model has a **Check** button to verify installation and a **Download** button for one-click installation via &#96;ollama pull&#96;.\n\n### Manual Installation\n\nIf you prefer manual setup:\n\n**Python:**\n*   macOS: &#96;brew install python3&#96; or download from [python.org](https://www.python.org/downloads/)\n*   Windows: Download installer from [python.org](https://www.python.org/downloads/) (check \"Add to PATH\")\n*   Linux: &#96;sudo apt install python3&#96; or your distribution's package manager\n\n**Ollama:**\n*   macOS: Download from [ollama.ai](https://ollama.ai/download) or &#96;brew install ollama&#96;\n*   Windows: Download installer from [ollama.ai](https://ollama.ai/download)\n*   Linux: &#96;curl -fsSL https://ollama.ai/install.sh | sh&#96;\n\nAfter installing Ollama, start it with &#96;ollama serve&#96; (macOS/Linux) or it will auto-start on Windows.\n\n##  Quick Start\n\n### 1. Setup\n1.  **Install dependencies** (see Installation &amp; Setup above)\n2.  Open the **Zettel Thinking Board** side panel (Right Ribbon)\n3.  Select your models for Orange and Purple inputs\n4.  (Optional) Add Environment Variables (e.g., &#96;MY_NAME&#96; = &#96;John&#96;)\n\n### 2. Create a Chain\n1.  Add an **Orange Card**: \"Write a haiku about rust programming.\"\n2.  Add a **Blue Card** and draw an arrow from **Orange -&gt; Blue**.\n3.  In the Blue Card, write:\n    &#96;&#96;&#96;python\n    # 'input' is the string output from the Orange card\n    lines = input.split('\\n')\n    print(f\"Haiku has {len(lines)} lines\") # Goes to Green Note\n\n    # Send a log to the side panel\n    obsidian_log(\"Analyzing structure...\")\n    &#96;&#96;&#96;\n\n### 3. Run It\n*   Right-click the **Blue Card** and select **Run Chain**.\n*   **What happens?**\n    1.  The Orange card runs. A Green note appears below it with the Haiku.\n    2.  The Blue card receives the Haiku text instantly.\n    3.  The Blue card runs. A Green note appears below it saying \"Haiku has 3 lines\".\n    4.  \"Analyzing structure...\" appears in your Side Panel Console.\n\n##  Edge variable injection\n\nBy default, all parent outputs are concatenated and passed to the child. You can instead **inject** a parent's output at a specific place in the child note.\n\n1. **Name the edge:** Select the edge (line) from parent to child and set its **label** to a variable name (e.g. &#96;summary&#96;).",
        "signatures": {},
        "detailedLines": [
          {
            "text": "*   **Download time:** ~5-10 minutes",
            "lineNumber": 65
          },
          {
            "lineNumber": 66
          },
          {
            "text": "Each model has a **Check** button to verify installation and a **Download** button for one-click installation via &#96;ollama pull&#96;.",
            "lineNumber": 67
          },
          {
            "lineNumber": 68
          },
          {
            "text": "### Manual Installation",
            "lineNumber": 69
          },
          {
            "lineNumber": 70
          },
          {
            "text": "If you prefer manual setup:",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "**Python:**",
            "lineNumber": 73
          },
          {
            "text": "*   macOS: &#96;brew install python3&#96; or download from [python.org](https://www.python.org/downloads/)",
            "lineNumber": 74
          },
          {
            "text": "*   Windows: Download installer from [python.org](https://www.python.org/downloads/) (check \"Add to PATH\")",
            "lineNumber": 75
          },
          {
            "text": "*   Linux: &#96;sudo apt install python3&#96; or your distribution's package manager",
            "lineNumber": 76
          },
          {
            "lineNumber": 77
          },
          {
            "text": "**Ollama:**",
            "lineNumber": 78
          },
          {
            "text": "*   macOS: Download from [ollama.ai](https://ollama.ai/download) or &#96;brew install ollama&#96;",
            "lineNumber": 79
          },
          {
            "text": "*   Windows: Download installer from [ollama.ai](https://ollama.ai/download)",
            "lineNumber": 80
          },
          {
            "text": "*   Linux: &#96;curl -fsSL https://ollama.ai/install.sh | sh&#96;",
            "lineNumber": 81
          },
          {
            "lineNumber": 82
          },
          {
            "text": "After installing Ollama, start it with &#96;ollama serve&#96; (macOS/Linux) or it will auto-start on Windows.",
            "lineNumber": 83
          },
          {
            "lineNumber": 84
          },
          {
            "text": "##  Quick Start",
            "lineNumber": 85
          },
          {
            "lineNumber": 86
          },
          {
            "text": "### 1. Setup",
            "lineNumber": 87
          },
          {
            "text": "1.  **Install dependencies** (see Installation &amp; Setup above)",
            "lineNumber": 88
          },
          {
            "text": "2.  Open the **Zettel Thinking Board** side panel (Right Ribbon)",
            "lineNumber": 89
          },
          {
            "text": "3.  Select your models for Orange and Purple inputs",
            "lineNumber": 90
          },
          {
            "text": "4.  (Optional) Add Environment Variables (e.g., &#96;MY_NAME&#96; = &#96;John&#96;)",
            "lineNumber": 91
          },
          {
            "lineNumber": 92
          },
          {
            "text": "### 2. Create a Chain",
            "lineNumber": 93
          },
          {
            "text": "1.  Add an **Orange Card**: \"Write a haiku about rust programming.\"",
            "lineNumber": 94
          },
          {
            "text": "2.  Add a **Blue Card** and draw an arrow from **Orange -&gt; Blue**.",
            "lineNumber": 95
          },
          {
            "text": "3.  In the Blue Card, write:",
            "lineNumber": 96
          },
          {
            "text": "    &#96;&#96;&#96;python",
            "lineNumber": 97
          },
          {
            "text": "    # 'input' is the string output from the Orange card",
            "lineNumber": 98
          },
          {
            "text": "    lines = input.split('\\n')",
            "lineNumber": 99
          },
          {
            "text": "    print(f\"Haiku has {len(lines)} lines\") # Goes to Green Note",
            "lineNumber": 100
          },
          {
            "lineNumber": 101
          },
          {
            "text": "    # Send a log to the side panel",
            "lineNumber": 102
          },
          {
            "text": "    obsidian_log(\"Analyzing structure...\")",
            "lineNumber": 103
          },
          {
            "text": "    &#96;&#96;&#96;",
            "lineNumber": 104
          },
          {
            "lineNumber": 105
          },
          {
            "text": "### 3. Run It",
            "lineNumber": 106
          },
          {
            "text": "*   Right-click the **Blue Card** and select **Run Chain**.",
            "lineNumber": 107
          },
          {
            "text": "*   **What happens?**",
            "lineNumber": 108
          },
          {
            "text": "    1.  The Orange card runs. A Green note appears below it with the Haiku.",
            "lineNumber": 109
          },
          {
            "text": "    2.  The Blue card receives the Haiku text instantly.",
            "lineNumber": 110
          },
          {
            "text": "    3.  The Blue card runs. A Green note appears below it saying \"Haiku has 3 lines\".",
            "lineNumber": 111
          },
          {
            "text": "    4.  \"Analyzing structure...\" appears in your Side Panel Console.",
            "lineNumber": 112
          },
          {
            "lineNumber": 113
          },
          {
            "text": "##  Edge variable injection",
            "lineNumber": 114
          },
          {
            "lineNumber": 115
          },
          {
            "text": "By default, all parent outputs are concatenated and passed to the child. You can instead **inject** a parent's output at a specific place in the child note.",
            "lineNumber": 116
          },
          {
            "lineNumber": 117
          },
          {
            "text": "1. **Name the edge:** Select the edge (line) from parent to child and set its **label** to a variable name (e.g. &#96;summary&#96;).",
            "lineNumber": 118
          }
        ]
      },
      "score": 0.2463996410369873
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 336
          },
          "endPosition": {
            "line": 457,
            "column": 1
          }
        },
        "contents": "async function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null,\n\trunStartData: RunStartCanvasData\n): Promise&lt;string&gt; {\n\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n\t\tconst temperature = settings.ollamaOrangeTemperature ?? DEFAULT_SETTINGS.ollamaOrangeTemperature;\n\t\tconst start = performance.now();\n\t\tconst result = await ollamaGenerate({\n\t\t\tmodel,\n\t\t\tprompt: fullPrompt,\n\t\t\tstream: false,\n\t\t\toptions: { temperature },\n\t\t});\n\t\tsetNodeDuration(canvasKey, nodeId, performance.now() - start);\n\t\tsetNodeResult(canvasKey, nodeId, result.response);\n\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {\n\t\t\tfullPrompt,\n\t\t\tthinking: result.thinking,\n\t\t});\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas, runStartData);\n\t\treturn result.response;\n\t}\n\tif (role === \"purple\") {\n\t\tconst model = settings.ollamaPurpleModel || \"llama2\";\n\t\tconst temperature = settings.ollamaPurpleTemperature ?? DEFAULT_SETTINGS.ollamaPurpleTemperature;\n\t\tconst start = performance.now();\n\t\tconst result = await ollamaGenerate({\n\t\t\tmodel,\n\t\t\tprompt: fullPrompt,\n\t\t\tstream: false,\n\t\t\toptions: { temperature },\n\t\t});\n\t\tsetNodeDuration(canvasKey, nodeId, performance.now() - start);\n\t\tsetNodeResult(canvasKey, nodeId, result.response);\n\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {\n\t\t\tfullPrompt,\n\t\t\tthinking: result.thinking,\n\t\t});\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas, runStartData);\n\t\treturn result.response;\n\t}\n\tif (role === \"red\") {\n\t\tconst model = settings.ollamaRedModel || \"llama2\";\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 337,
                "column": 1
              },
              "endPosition": {
                "line": 347,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "async function runSingleNode(",
            "lineNumber": 337,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 338,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 339,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 340,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 341,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 342,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 343,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null,",
            "lineNumber": 344,
            "isSignature": true
          },
          {
            "text": "\trunStartData: RunStartCanvasData",
            "lineNumber": 345,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 346,
            "isSignature": true
          },
          {
            "lineNumber": 387
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 388
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 389
          },
          {
            "lineNumber": 390
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 391
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 392
          },
          {
            "text": "\t\tconst temperature = settings.ollamaOrangeTemperature ?? DEFAULT_SETTINGS.ollamaOrangeTemperature;",
            "lineNumber": 393
          },
          {
            "text": "\t\tconst start = performance.now();",
            "lineNumber": 394
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({",
            "lineNumber": 395
          },
          {
            "text": "\t\t\tmodel,",
            "lineNumber": 396
          },
          {
            "text": "\t\t\tprompt: fullPrompt,",
            "lineNumber": 397
          },
          {
            "text": "\t\t\tstream: false,",
            "lineNumber": 398
          },
          {
            "text": "\t\t\toptions: { temperature },",
            "lineNumber": 399
          },
          {
            "text": "\t\t});",
            "lineNumber": 400
          },
          {
            "text": "\t\tsetNodeDuration(canvasKey, nodeId, performance.now() - start);",
            "lineNumber": 401
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result.response);",
            "lineNumber": 402
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {",
            "lineNumber": 403
          },
          {
            "text": "\t\t\tfullPrompt,",
            "lineNumber": 404
          },
          {
            "text": "\t\t\tthinking: result.thinking,",
            "lineNumber": 405
          },
          {
            "text": "\t\t});",
            "lineNumber": 406
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas, runStartData);",
            "lineNumber": 407
          },
          {
            "text": "\t\treturn result.response;",
            "lineNumber": 408
          },
          {
            "text": "\t}",
            "lineNumber": 409
          },
          {
            "text": "\tif (role === \"purple\") {",
            "lineNumber": 410
          },
          {
            "text": "\t\tconst model = settings.ollamaPurpleModel || \"llama2\";",
            "lineNumber": 411
          },
          {
            "text": "\t\tconst temperature = settings.ollamaPurpleTemperature ?? DEFAULT_SETTINGS.ollamaPurpleTemperature;",
            "lineNumber": 412
          },
          {
            "text": "\t\tconst start = performance.now();",
            "lineNumber": 413
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({",
            "lineNumber": 414
          },
          {
            "text": "\t\t\tmodel,",
            "lineNumber": 415
          },
          {
            "text": "\t\t\tprompt: fullPrompt,",
            "lineNumber": 416
          },
          {
            "text": "\t\t\tstream: false,",
            "lineNumber": 417
          },
          {
            "text": "\t\t\toptions: { temperature },",
            "lineNumber": 418
          },
          {
            "text": "\t\t});",
            "lineNumber": 419
          },
          {
            "text": "\t\tsetNodeDuration(canvasKey, nodeId, performance.now() - start);",
            "lineNumber": 420
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result.response);",
            "lineNumber": 421
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {",
            "lineNumber": 422
          },
          {
            "text": "\t\t\tfullPrompt,",
            "lineNumber": 423
          },
          {
            "text": "\t\t\tthinking: result.thinking,",
            "lineNumber": 424
          },
          {
            "text": "\t\t});",
            "lineNumber": 425
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas, runStartData);",
            "lineNumber": 426
          },
          {
            "text": "\t\treturn result.response;",
            "lineNumber": 427
          },
          {
            "text": "\t}",
            "lineNumber": 428
          },
          {
            "text": "\tif (role === \"red\") {",
            "lineNumber": 429
          },
          {
            "text": "\t\tconst model = settings.ollamaRedModel || \"llama2\";",
            "lineNumber": 430
          },
          {
            "text": "}",
            "lineNumber": 458,
            "isSignature": true
          }
        ]
      },
      "score": 0.23690369725227356
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./PRD.md",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 29
          }
        },
        "contents": "# Part 1: Product Requirement Document (PRD)\n\n**Project Name:** Zettel Thinking Board\n**Platform:** Obsidian (Desktop)\n**Version:** 1.0.0\n**Status:** Requirements Finalized\n\n## 1. Executive Summary\n**Zettel Thinking Board** transforms the Obsidian Canvas into an interactive AI workbench. It allows users to create chains of thought using LLMs and Python scripts. Unlike traditional flow-based tools, the execution logic flows directly between prompt/code nodes, while the output is visualized as detached \"sidecar\" notes, keeping the logic graph clean and readable.\n\n## 2. Core Philosophy\n*   **Logic over Layout:** Connections define the data flow (e.g., Prompt -&gt; Code). Visual outputs (Green nodes) are artifacts, not dependencies.\n*   **Invisible Data Passing:** Node A passes its result to Node B internally in memory, regardless of whether a visual output node exists.\n*   **Stateful Intelligence:** A persistent Python kernel **per canvas** allows for variable retention across different nodes in the same graph; each open canvas has its own kernel, which is torn down when the canvas is closed.\n\n## 3. Functional Requirements\n\n### 3.1. Node Logic &amp; Routing (The Color System)\nThe plugin parses colors to determine behavior.\n*   **Orange Node (Primary LLM):** Sends input + parent context to the mapped \"Orange\" Ollama model.\n*   **Purple Node (Secondary LLM):** Sends input + parent context to the mapped \"Purple\" Ollama model.\n*   **Blue Node (Python):** Executes code.\n    *   *Input:* &#96;input&#96; variable contains the result string from the parent node.\n    *   *State:* Access to shared global variables from previous Blue nodes.\n*   **Yellow Node (Text / input):**\n    *   No execution.\n    *   Passes its text as input to the next node (pass-through). Uncolored or unused-color nodes are not connected to any node and do not add to the prompt.\n*   **Green Node (Visual Output):**\n    *   **Behavior:** Generated automatically upon successful execution of an Orange, Purple, or Blue node. Re-running the source node **replaces** the green note's content (no duplicate output notes).",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Part 1: Product Requirement Document (PRD)",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "**Project Name:** Zettel Thinking Board",
            "lineNumber": 3
          },
          {
            "text": "**Platform:** Obsidian (Desktop)",
            "lineNumber": 4
          },
          {
            "text": "**Version:** 1.0.0",
            "lineNumber": 5
          },
          {
            "text": "**Status:** Requirements Finalized",
            "lineNumber": 6
          },
          {
            "lineNumber": 7
          },
          {
            "text": "## 1. Executive Summary",
            "lineNumber": 8
          },
          {
            "text": "**Zettel Thinking Board** transforms the Obsidian Canvas into an interactive AI workbench. It allows users to create chains of thought using LLMs and Python scripts. Unlike traditional flow-based tools, the execution logic flows directly between prompt/code nodes, while the output is visualized as detached \"sidecar\" notes, keeping the logic graph clean and readable.",
            "lineNumber": 9
          },
          {
            "lineNumber": 10
          },
          {
            "text": "## 2. Core Philosophy",
            "lineNumber": 11
          },
          {
            "text": "*   **Logic over Layout:** Connections define the data flow (e.g., Prompt -&gt; Code). Visual outputs (Green nodes) are artifacts, not dependencies.",
            "lineNumber": 12
          },
          {
            "text": "*   **Invisible Data Passing:** Node A passes its result to Node B internally in memory, regardless of whether a visual output node exists.",
            "lineNumber": 13
          },
          {
            "text": "*   **Stateful Intelligence:** A persistent Python kernel **per canvas** allows for variable retention across different nodes in the same graph; each open canvas has its own kernel, which is torn down when the canvas is closed.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "## 3. Functional Requirements",
            "lineNumber": 16
          },
          {
            "lineNumber": 17
          },
          {
            "text": "### 3.1. Node Logic &amp; Routing (The Color System)",
            "lineNumber": 18
          },
          {
            "text": "The plugin parses colors to determine behavior.",
            "lineNumber": 19
          },
          {
            "text": "*   **Orange Node (Primary LLM):** Sends input + parent context to the mapped \"Orange\" Ollama model.",
            "lineNumber": 20
          },
          {
            "text": "*   **Purple Node (Secondary LLM):** Sends input + parent context to the mapped \"Purple\" Ollama model.",
            "lineNumber": 21
          },
          {
            "text": "*   **Blue Node (Python):** Executes code.",
            "lineNumber": 22
          },
          {
            "text": "    *   *Input:* &#96;input&#96; variable contains the result string from the parent node.",
            "lineNumber": 23
          },
          {
            "text": "    *   *State:* Access to shared global variables from previous Blue nodes.",
            "lineNumber": 24
          },
          {
            "text": "*   **Yellow Node (Text / input):**",
            "lineNumber": 25
          },
          {
            "text": "    *   No execution.",
            "lineNumber": 26
          },
          {
            "text": "    *   Passes its text as input to the next node (pass-through). Uncolored or unused-color nodes are not connected to any node and do not add to the prompt.",
            "lineNumber": 27
          },
          {
            "text": "*   **Green Node (Visual Output):**",
            "lineNumber": 28
          },
          {
            "text": "    *   **Behavior:** Generated automatically upon successful execution of an Orange, Purple, or Blue node. Re-running the source node **replaces** the green note's content (no duplicate output notes).",
            "lineNumber": 29
          }
        ]
      },
      "score": 0.23265093564987183
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/views/ZettelControlsView.ts",
        "range": {
          "startPosition": {
            "line": 25
          },
          "endPosition": {
            "line": 215,
            "column": 1
          }
        },
        "contents": "export class ZettelControlsView extends ItemView {\nasync onOpen(): Promise&lt;void&gt; {\n\n\t\tconst addEnvRow = (key = \"\", value = \"\") =&gt; {\n\t\t\tconst row = envList.createDiv({ cls: \"ztb-env-row\" });\n\t\t\tconst keyInp = row.createEl(\"input\", { type: \"text\", cls: \"ztb-env-key\" });\n\t\t\tkeyInp.placeholder = \"KEY\";\n\t\t\tkeyInp.value = key;\n\t\t\tconst valInp = row.createEl(\"input\", { type: \"text\", cls: \"ztb-env-val\" });\n\t\t\tvalInp.placeholder = \"value\";\n\t\t\tvalInp.value = value;\n\t\t\tkeyInp.addEventListener(\"change\", () =&gt; {\n\t\t\t\tif (key) delete envVars[key];\n\t\t\t\tenvVars[keyInp.value.trim()] = valInp.value.trim();\n\t\t\t});\n\t\t\tvalInp.addEventListener(\"change\", () =&gt; {\n\t\t\t\tenvVars[keyInp.value.trim()] = valInp.value.trim();\n\t\t\t});\n\t\t\trow.createEl(\"button\", { text: \"Remove\", cls: \"ztb-env-remove\" }).addEventListener(\"click\", () =&gt; {\n\t\t\t\tdelete envVars[keyInp.value.trim()];\n\t\t\t\trow.remove();\n\t\t\t});\n\t\t};\n\t\tfor (const [k, v] of Object.entries(envVars)) addEnvRow(k, v);\n\t\tconst addBtn = el.createEl(\"button\", { text: \"Add variable\", cls: \"ztb-env-add\" });\n\t\taddBtn.addEventListener(\"click\", () =&gt; addEnvRow());\n\n\t\t// Console (obsidian_log output)\n\t\tel.createEl(\"h4\", { text: \"Console\", cls: \"ztb-section-title\" });\n\t\tconst consoleTip = el.createEl(\"p\", { cls: \"ztb-controls-tip\" });\n\t\tconsoleTip.setText(\"In Python cards, call obsidian_log('your message') to see output here.\");\n\t\tconst consoleEl = el.createDiv({ cls: \"ztb-console\" });\n\t\tconst appendLog = (line: string) =&gt; {\n\t\t\tconst p = consoleEl.createEl(\"p\", { cls: \"ztb-console-line\" });\n\t\t\tp.setText(line);\n\t\t\tconsoleEl.scrollTop = consoleEl.scrollHeight;\n\t\t};\n\n\t\tconst wireKernelLog = () =&gt; {\n\t\t\tconst kernel = this.plugin.getKernelForActiveCanvas();\n\t\t\tif (kernel) kernel.onLog = (line: string) =&gt; {\n\t\t\t\tif (this.containerEl.isConnected) appendLog(line);\n\t\t\t};\n\t\t};\n\t\twireKernelLog();\n\t\tthis.plugin.registerEvent(\n\t\t\tthis.plugin.app.workspace.on(\"active-leaf-change\", wireKernelLog)\n\t\t);\n\n\t\t// Guide tips (features that are not immediately obvious)\n\t\tel.createEl(\"h4\", { text: \"Guide tips\", cls: \"ztb-section-title\" });\n\t\tconst guideDetails = el.createEl(\"details\", { cls: \"ztb-guide-details\" });\n\t\tguideDetails.createEl(\"summary\", { cls: \"ztb-guide-summary\",\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 26,
                "column": 1
              },
              "endPosition": {
                "line": 26,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 26,
                "column": 8
              },
              "endPosition": {
                "line": 27,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 43,
                "column": 2
              },
              "endPosition": {
                "line": 44,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export class ZettelControlsView extends ItemView {",
            "lineNumber": 26,
            "isSignature": true
          },
          {
            "text": "async onOpen(): Promise&lt;void&gt; {",
            "lineNumber": 43
          },
          {
            "lineNumber": 144
          },
          {
            "text": "\t\tconst addEnvRow = (key = \"\", value = \"\") =&gt; {",
            "lineNumber": 145
          },
          {
            "text": "\t\t\tconst row = envList.createDiv({ cls: \"ztb-env-row\" });",
            "lineNumber": 146
          },
          {
            "text": "\t\t\tconst keyInp = row.createEl(\"input\", { type: \"text\", cls: \"ztb-env-key\" });",
            "lineNumber": 147
          },
          {
            "text": "\t\t\tkeyInp.placeholder = \"KEY\";",
            "lineNumber": 148
          },
          {
            "text": "\t\t\tkeyInp.value = key;",
            "lineNumber": 149
          },
          {
            "text": "\t\t\tconst valInp = row.createEl(\"input\", { type: \"text\", cls: \"ztb-env-val\" });",
            "lineNumber": 150
          },
          {
            "text": "\t\t\tvalInp.placeholder = \"value\";",
            "lineNumber": 151
          },
          {
            "text": "\t\t\tvalInp.value = value;",
            "lineNumber": 152
          },
          {
            "text": "\t\t\tkeyInp.addEventListener(\"change\", () =&gt; {",
            "lineNumber": 153
          },
          {
            "text": "\t\t\t\tif (key) delete envVars[key];",
            "lineNumber": 154
          },
          {
            "text": "\t\t\t\tenvVars[keyInp.value.trim()] = valInp.value.trim();",
            "lineNumber": 155
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 156
          },
          {
            "text": "\t\t\tvalInp.addEventListener(\"change\", () =&gt; {",
            "lineNumber": 157
          },
          {
            "text": "\t\t\t\tenvVars[keyInp.value.trim()] = valInp.value.trim();",
            "lineNumber": 158
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 159
          },
          {
            "text": "\t\t\trow.createEl(\"button\", { text: \"Remove\", cls: \"ztb-env-remove\" }).addEventListener(\"click\", () =&gt; {",
            "lineNumber": 160
          },
          {
            "text": "\t\t\t\tdelete envVars[keyInp.value.trim()];",
            "lineNumber": 161
          },
          {
            "text": "\t\t\t\trow.remove();",
            "lineNumber": 162
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 163
          },
          {
            "text": "\t\t};",
            "lineNumber": 164
          },
          {
            "text": "\t\tfor (const [k, v] of Object.entries(envVars)) addEnvRow(k, v);",
            "lineNumber": 165
          },
          {
            "text": "\t\tconst addBtn = el.createEl(\"button\", { text: \"Add variable\", cls: \"ztb-env-add\" });",
            "lineNumber": 166
          },
          {
            "text": "\t\taddBtn.addEventListener(\"click\", () =&gt; addEnvRow());",
            "lineNumber": 167
          },
          {
            "lineNumber": 168
          },
          {
            "text": "\t\t// Console (obsidian_log output)",
            "lineNumber": 169
          },
          {
            "text": "\t\tel.createEl(\"h4\", { text: \"Console\", cls: \"ztb-section-title\" });",
            "lineNumber": 170
          },
          {
            "text": "\t\tconst consoleTip = el.createEl(\"p\", { cls: \"ztb-controls-tip\" });",
            "lineNumber": 171
          },
          {
            "text": "\t\tconsoleTip.setText(\"In Python cards, call obsidian_log('your message') to see output here.\");",
            "lineNumber": 172
          },
          {
            "text": "\t\tconst consoleEl = el.createDiv({ cls: \"ztb-console\" });",
            "lineNumber": 173
          },
          {
            "text": "\t\tconst appendLog = (line: string) =&gt; {",
            "lineNumber": 174
          },
          {
            "text": "\t\t\tconst p = consoleEl.createEl(\"p\", { cls: \"ztb-console-line\" });",
            "lineNumber": 175
          },
          {
            "text": "\t\t\tp.setText(line);",
            "lineNumber": 176
          },
          {
            "text": "\t\t\tconsoleEl.scrollTop = consoleEl.scrollHeight;",
            "lineNumber": 177
          },
          {
            "text": "\t\t};",
            "lineNumber": 178
          },
          {
            "lineNumber": 179
          },
          {
            "text": "\t\tconst wireKernelLog = () =&gt; {",
            "lineNumber": 180
          },
          {
            "text": "\t\t\tconst kernel = this.plugin.getKernelForActiveCanvas();",
            "lineNumber": 181
          },
          {
            "text": "\t\t\tif (kernel) kernel.onLog = (line: string) =&gt; {",
            "lineNumber": 182
          },
          {
            "text": "\t\t\t\tif (this.containerEl.isConnected) appendLog(line);",
            "lineNumber": 183
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 184
          },
          {
            "text": "\t\t};",
            "lineNumber": 185
          },
          {
            "text": "\t\twireKernelLog();",
            "lineNumber": 186
          },
          {
            "text": "\t\tthis.plugin.registerEvent(",
            "lineNumber": 187
          },
          {
            "text": "\t\t\tthis.plugin.app.workspace.on(\"active-leaf-change\", wireKernelLog)",
            "lineNumber": 188
          },
          {
            "text": "\t\t);",
            "lineNumber": 189
          },
          {
            "lineNumber": 190
          },
          {
            "text": "\t\t// Guide tips (features that are not immediately obvious)",
            "lineNumber": 191
          },
          {
            "text": "\t\tel.createEl(\"h4\", { text: \"Guide tips\", cls: \"ztb-section-title\" });",
            "lineNumber": 192
          },
          {
            "text": "\t\tconst guideDetails = el.createEl(\"details\", { cls: \"ztb-guide-details\" });",
            "lineNumber": 193
          },
          {
            "text": "\t\tguideDetails.createEl(\"summary\", { cls: \"ztb-guide-summary\",",
            "lineNumber": 194
          },
          {
            "text": "\t}",
            "lineNumber": 210
          },
          {
            "text": "}",
            "lineNumber": 216,
            "isSignature": true
          }
        ]
      },
      "score": 0.22661644220352173
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 878,
            "column": 1
          },
          "endPosition": {
            "line": 911,
            "column": 113
          }
        },
        "contents": "const CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";\n\n/** Run all nodes reachable from any root, in topological order. */\nexport async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null,\n\trunStartData?: RunStartCanvasData | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst topo = topologicalOrderFull(data, settings);\n\tif (\"cycle\" in topo) return { ok: false, message: CYCLE_ERROR_MESSAGE };\n\tconst order = topo.order;\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\ttry {\n\t\tfor (const nid of order) {\n\t\t\ttry {\n\t\t\t\tsetRunningNodeId(canvasKey, nid);\n\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas, runStartData ?? null);\n\t\t\t} finally {\n\t\t\t\tsetRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t}\n}\n\n/** Return ordered node IDs for a chain from roots to the given target, or null if no data, no path, or cycle. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "const CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";",
            "lineNumber": 881
          },
          {
            "lineNumber": 882
          },
          {
            "text": "/** Run all nodes reachable from any root, in topological order. */",
            "lineNumber": 883
          },
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 884,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 885,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 886,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 887,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null,",
            "lineNumber": 888,
            "isSignature": true
          },
          {
            "text": "\trunStartData?: RunStartCanvasData | null",
            "lineNumber": 889,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 890,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 891
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 892
          },
          {
            "text": "\tconst topo = topologicalOrderFull(data, settings);",
            "lineNumber": 893
          },
          {
            "text": "\tif (\"cycle\" in topo) return { ok: false, message: CYCLE_ERROR_MESSAGE };",
            "lineNumber": 894
          },
          {
            "text": "\tconst order = topo.order;",
            "lineNumber": 895
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 896
          },
          {
            "text": "\ttry {",
            "lineNumber": 897
          },
          {
            "text": "\t\tfor (const nid of order) {",
            "lineNumber": 898
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 899
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, nid);",
            "lineNumber": 900
          },
          {
            "text": "\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas, runStartData ?? null);",
            "lineNumber": 901
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 902
          },
          {
            "text": "\t\t\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 903
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 904
          },
          {
            "text": "\t\t}",
            "lineNumber": 905
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 906
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 907
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 908
          },
          {
            "text": "\t}",
            "lineNumber": 909
          },
          {
            "text": "}",
            "lineNumber": 910,
            "isSignature": true
          },
          {
            "lineNumber": 911
          },
          {
            "text": "/** Return ordered node IDs for a chain from roots to the given target, or null if no data, no path, or cycle. */",
            "lineNumber": 912
          }
        ]
      },
      "score": 0.21815496683120728
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./README.md",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 28
          }
        },
        "contents": "# Zettel Thinking Board \n\n**A Visual AI Whiteboard for Obsidian.**\n\n&lt;img width=\"2555\" height=\"1415\" alt=\"98548\" src=\"https://github.com/user-attachments/assets/44d9556e-5e25-49bf-bcaf-efedc2317b80\" /&gt;\n\n\nZettel Thinking Board turns your Canvas into an executable flow diagram for python and ollama models. Chain together **Local LLMs** (Ollama) and **Python Scripts** to build complex AI workflows, visualize the results, and refine your thoughts.\n\n##  The \"Zettel\" Workflow\n\nUnlike other canvas tools where the output sits *between* nodes, Zettel Thinking Board keeps your logic clean.\n\n*   **The Chain:** Connect your Prompt (Orange) directly to your Code (Blue).\n*   **The Result:** When you run a node, a **Green Note** spawns below it (or updates if it already exists), connected by an edge labeled **&#96;output&#96;**. Re-running replaces the green note's content.\n*   **The Flow:** Data passes invisibly from parent to child. The Green Note is just for you to read; the Code node reads the raw data directly from the Prompt node. The &#96;output&#96; edge is reservedRun Node and Run Chain ignore it (green notes are not part of the execution graph).\n\n##  Features\n\n*   **Color-Coded Intelligence:**\n    *    **Orange:** Primary LLM (e.g., Llama 3).\n    *    **Purple:** Secondary LLM (e.g., Mistral - great for critiquing Orange).\n    *    **Blue:** Python Code (Persistent State).\n    *    **Green:** Auto-generated output (Visual Sidecar).\n    *    **Yellow:** Text (input pass-through). Uncolored or unused-color nodes are not connected and do not add to the prompt.\n*   **Persistent Memory:** Variables defined in one Blue node are accessible in connected Blue nodes downstream.\n*   **Edge variable injection:** Put a **variable name** on an edge (edit the edge label). In the target note, use &#96;{{var:variableName}}&#96; to inject that parent's output at that spot instead of concatenating it. Edges update after run to show \"(injected)\" or \"(concatenated)\". The label **&#96;output&#96;** is reserved for the run node  green output note and is not a variable name; Run Node / Run Chain ignore output edges.\n*   **Side Channel Logging:** Send debug info to the side panel console without cluttering your canvas.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Zettel Thinking Board ",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "**A Visual AI Whiteboard for Obsidian.**",
            "lineNumber": 3
          },
          {
            "lineNumber": 4
          },
          {
            "text": "&lt;img width=\"2555\" height=\"1415\" alt=\"98548\" src=\"https://github.com/user-attachments/assets/44d9556e-5e25-49bf-bcaf-efedc2317b80\" /&gt;",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "lineNumber": 7
          },
          {
            "text": "Zettel Thinking Board turns your Canvas into an executable flow diagram for python and ollama models. Chain together **Local LLMs** (Ollama) and **Python Scripts** to build complex AI workflows, visualize the results, and refine your thoughts.",
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "##  The \"Zettel\" Workflow",
            "lineNumber": 10
          },
          {
            "lineNumber": 11
          },
          {
            "text": "Unlike other canvas tools where the output sits *between* nodes, Zettel Thinking Board keeps your logic clean.",
            "lineNumber": 12
          },
          {
            "lineNumber": 13
          },
          {
            "text": "*   **The Chain:** Connect your Prompt (Orange) directly to your Code (Blue).",
            "lineNumber": 14
          },
          {
            "text": "*   **The Result:** When you run a node, a **Green Note** spawns below it (or updates if it already exists), connected by an edge labeled **&#96;output&#96;**. Re-running replaces the green note's content.",
            "lineNumber": 15
          },
          {
            "text": "*   **The Flow:** Data passes invisibly from parent to child. The Green Note is just for you to read; the Code node reads the raw data directly from the Prompt node. The &#96;output&#96; edge is reservedRun Node and Run Chain ignore it (green notes are not part of the execution graph).",
            "lineNumber": 16
          },
          {
            "lineNumber": 17
          },
          {
            "text": "##  Features",
            "lineNumber": 18
          },
          {
            "lineNumber": 19
          },
          {
            "text": "*   **Color-Coded Intelligence:**",
            "lineNumber": 20
          },
          {
            "text": "    *    **Orange:** Primary LLM (e.g., Llama 3).",
            "lineNumber": 21
          },
          {
            "text": "    *    **Purple:** Secondary LLM (e.g., Mistral - great for critiquing Orange).",
            "lineNumber": 22
          },
          {
            "text": "    *    **Blue:** Python Code (Persistent State).",
            "lineNumber": 23
          },
          {
            "text": "    *    **Green:** Auto-generated output (Visual Sidecar).",
            "lineNumber": 24
          },
          {
            "text": "    *    **Yellow:** Text (input pass-through). Uncolored or unused-color nodes are not connected and do not add to the prompt.",
            "lineNumber": 25
          },
          {
            "text": "*   **Persistent Memory:** Variables defined in one Blue node are accessible in connected Blue nodes downstream.",
            "lineNumber": 26
          },
          {
            "text": "*   **Edge variable injection:** Put a **variable name** on an edge (edit the edge label). In the target note, use &#96;{{var:variableName}}&#96; to inject that parent's output at that spot instead of concatenating it. Edges update after run to show \"(injected)\" or \"(concatenated)\". The label **&#96;output&#96;** is reserved for the run node  green output note and is not a variable name; Run Node / Run Chain ignore output edges.",
            "lineNumber": 27
          },
          {
            "text": "*   **Side Channel Logging:** Send debug info to the side panel console without cluttering your canvas.",
            "lineNumber": 28
          }
        ]
      },
      "score": 0.21771705150604248
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/installer.ts",
        "range": {
          "startPosition": {
            "line": 29,
            "column": 2
          },
          "endPosition": {
            "line": 122,
            "column": 1
          }
        },
        "contents": "/** Check Python installation status by trying to spawn a process */\nexport async function checkPythonInstallation(): Promise&lt;{\n\tinstalled: boolean;\n\tversion?: string;\n\tpath?: string;\n}&gt; {\n\t// In Obsidian desktop, we can use require for Node modules (desktop only)\n\t// Check if we're in a Node.js environment\n\tif (typeof require === \"undefined\" || !Platform.isDesktopApp) {\n\t\treturn {installed: false};\n\t}\n\n\ttry {\n\t\t// Dynamic require to avoid bundling issues\n\t\tconst {execSync} = require(\"child_process\") as typeof import(\"child_process\");\n\t\tconst pythonCommands = [\"python3\", \"python\"];\n\n\t\tfor (const cmd of pythonCommands) {\n\t\t\ttry {\n\t\t\t\tconst version = execSync(&#96;${cmd} --version&#96;, {\n\t\t\t\t\tencoding: \"utf8\",\n\t\t\t\t\ttimeout: 5000,\n\t\t\t\t}).trim();\n\n\t\t\t\tconst path = execSync(\n\t\t\t\t\tPlatform.isWin ? &#96;where ${cmd}&#96; : &#96;which ${cmd}&#96;,\n\t\t\t\t\t{encoding: \"utf8\", timeout: 5000}\n\t\t\t\t).trim().split(\"\\n\")[0];\n\n\t\t\t\treturn {\n\t\t\t\t\tinstalled: true,\n\t\t\t\t\tversion,\n\t\t\t\t\tpath,\n\t\t\t\t};\n\t\t\t} catch {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tconsole.error(\"Error checking Python installation:\", error);\n\t}\n\n\treturn {installed: false};\n}\n\n/** Check Ollama installation status */\nexport async function checkOllamaInstallation(): Promise&lt;{\n\tinstalled: boolean;\n\trunning: boolean;\n\tversion?: string;\n}&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Check Python installation status by trying to spawn a process */",
            "lineNumber": 32
          },
          {
            "text": "export async function checkPythonInstallation(): Promise&lt;{",
            "lineNumber": 33,
            "isSignature": true
          },
          {
            "text": "\tinstalled: boolean;",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "text": "\tversion?: string;",
            "lineNumber": 35,
            "isSignature": true
          },
          {
            "text": "\tpath?: string;",
            "lineNumber": 36,
            "isSignature": true
          },
          {
            "text": "}&gt; {",
            "lineNumber": 37,
            "isSignature": true
          },
          {
            "text": "\t// In Obsidian desktop, we can use require for Node modules (desktop only)",
            "lineNumber": 38
          },
          {
            "text": "\t// Check if we're in a Node.js environment",
            "lineNumber": 39
          },
          {
            "text": "\tif (typeof require === \"undefined\" || !Platform.isDesktopApp) {",
            "lineNumber": 40
          },
          {
            "text": "\t\treturn {installed: false};",
            "lineNumber": 41
          },
          {
            "text": "\t}",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "\ttry {",
            "lineNumber": 44
          },
          {
            "text": "\t\t// Dynamic require to avoid bundling issues",
            "lineNumber": 45
          },
          {
            "text": "\t\tconst {execSync} = require(\"child_process\") as typeof import(\"child_process\");",
            "lineNumber": 46
          },
          {
            "text": "\t\tconst pythonCommands = [\"python3\", \"python\"];",
            "lineNumber": 47
          },
          {
            "lineNumber": 48
          },
          {
            "text": "\t\tfor (const cmd of pythonCommands) {",
            "lineNumber": 49
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t\tconst version = execSync(&#96;${cmd} --version&#96;, {",
            "lineNumber": 51
          },
          {
            "text": "\t\t\t\t\tencoding: \"utf8\",",
            "lineNumber": 52
          },
          {
            "text": "\t\t\t\t\ttimeout: 5000,",
            "lineNumber": 53
          },
          {
            "text": "\t\t\t\t}).trim();",
            "lineNumber": 54
          },
          {
            "lineNumber": 55
          },
          {
            "text": "\t\t\t\tconst path = execSync(",
            "lineNumber": 56
          },
          {
            "text": "\t\t\t\t\tPlatform.isWin ? &#96;where ${cmd}&#96; : &#96;which ${cmd}&#96;,",
            "lineNumber": 57
          },
          {
            "text": "\t\t\t\t\t{encoding: \"utf8\", timeout: 5000}",
            "lineNumber": 58
          },
          {
            "text": "\t\t\t\t).trim().split(\"\\n\")[0];",
            "lineNumber": 59
          },
          {
            "lineNumber": 60
          },
          {
            "text": "\t\t\t\treturn {",
            "lineNumber": 61
          },
          {
            "text": "\t\t\t\t\tinstalled: true,",
            "lineNumber": 62
          },
          {
            "text": "\t\t\t\t\tversion,",
            "lineNumber": 63
          },
          {
            "text": "\t\t\t\t\tpath,",
            "lineNumber": 64
          },
          {
            "text": "\t\t\t\t};",
            "lineNumber": 65
          },
          {
            "text": "\t\t\t} catch {",
            "lineNumber": 66
          },
          {
            "text": "\t\t\t\tcontinue;",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 68
          },
          {
            "text": "\t\t}",
            "lineNumber": 69
          },
          {
            "text": "\t} catch (error) {",
            "lineNumber": 70
          },
          {
            "text": "\t\tconsole.error(\"Error checking Python installation:\", error);",
            "lineNumber": 71
          },
          {
            "text": "\t}",
            "lineNumber": 72
          },
          {
            "lineNumber": 73
          },
          {
            "text": "\treturn {installed: false};",
            "lineNumber": 74
          },
          {
            "text": "}",
            "lineNumber": 75,
            "isSignature": true
          },
          {
            "lineNumber": 76
          },
          {
            "text": "/** Check Ollama installation status */",
            "lineNumber": 77
          },
          {
            "text": "export async function checkOllamaInstallation(): Promise&lt;{",
            "lineNumber": 78,
            "isSignature": true
          },
          {
            "text": "\tinstalled: boolean;",
            "lineNumber": 79,
            "isSignature": true
          },
          {
            "text": "\trunning: boolean;",
            "lineNumber": 80,
            "isSignature": true
          },
          {
            "text": "\tversion?: string;",
            "lineNumber": 81,
            "isSignature": true
          },
          {
            "text": "}&gt; {",
            "lineNumber": 82,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 83
          },
          {
            "text": "}",
            "lineNumber": 123,
            "isSignature": true
          }
        ]
      },
      "score": 0.21090883016586304
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 340
          },
          "endPosition": {
            "line": 1010,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\n\n\n\t/** Run entire canvas (call from canvas background context menu). */\n\tasync runEntireCanvas(): Promise&lt;void&gt; {\n\t\tconst view = this.getActiveCanvasView();\n\t\tif (!view) return;\n\t\tif (getRunInProgress()) {\n\t\t\tenqueueRun({ type: \"entire\", canvasFilePath: view.file.path });\n\t\t\tnew Notice(\"Run queued.\");\n\t\t\treturn;\n\t\t}\n\t\tconst canvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;\n\t\tconst liveCanvas = canvas;\n\t\tconst viewWithData = view as unknown as { getData?: () =&gt; unknown };\n\t\tif (!liveCanvas.getData &amp;&amp; typeof viewWithData.getData === \"function\") {\n\t\t\t(liveCanvas as { getData?: () =&gt; unknown }).getData = () =&gt; viewWithData.getData?.();\n\t\t}\n\t\tsetRunInProgress(true);\n\t\tsetRunStartCanvasData(getCanvasKey(view.file.path), liveCanvas.getData?.() ?? null);\n\t\ttry {\n\t\t\tconst result = await runnerRunEntireCanvas(this.app, this.settings, view.file.path, liveCanvas, getRunStartCanvasData(getCanvasKey(view.file.path)));\n\t\t\tif (!result.ok) new Notice(result.message ?? \"Run entire canvas failed.\");\n\t\t} finally {\n\t\t\tsetRunInProgress(false);\n\t\t\tawait this.processQueue();\n\t\t}\n\t}\n\n\t/** Dismiss all output nodes on the canvas (call from canvas background context menu). */\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 341,
                "column": 1
              },
              "endPosition": {
                "line": 341,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 341,
                "column": 16
              },
              "endPosition": {
                "line": 342,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 341,
            "isSignature": true
          },
          {
            "lineNumber": 964
          },
          {
            "lineNumber": 965
          },
          {
            "text": "\t/** Run entire canvas (call from canvas background context menu). */",
            "lineNumber": 966
          },
          {
            "text": "\tasync runEntireCanvas(): Promise&lt;void&gt; {",
            "lineNumber": 967
          },
          {
            "text": "\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 968
          },
          {
            "text": "\t\tif (!view) return;",
            "lineNumber": 969
          },
          {
            "text": "\t\tif (getRunInProgress()) {",
            "lineNumber": 970
          },
          {
            "text": "\t\t\tenqueueRun({ type: \"entire\", canvasFilePath: view.file.path });",
            "lineNumber": 971
          },
          {
            "text": "\t\t\tnew Notice(\"Run queued.\");",
            "lineNumber": 972
          },
          {
            "text": "\t\t\treturn;",
            "lineNumber": 973
          },
          {
            "text": "\t\t}",
            "lineNumber": 974
          },
          {
            "text": "\t\tconst canvas = view.canvas as import(\"./engine/canvasApi\").LiveCanvas;",
            "lineNumber": 975
          },
          {
            "text": "\t\tconst liveCanvas = canvas;",
            "lineNumber": 976
          },
          {
            "text": "\t\tconst viewWithData = view as unknown as { getData?: () =&gt; unknown };",
            "lineNumber": 977
          },
          {
            "text": "\t\tif (!liveCanvas.getData &amp;&amp; typeof viewWithData.getData === \"function\") {",
            "lineNumber": 978
          },
          {
            "text": "\t\t\t(liveCanvas as { getData?: () =&gt; unknown }).getData = () =&gt; viewWithData.getData?.();",
            "lineNumber": 979
          },
          {
            "text": "\t\t}",
            "lineNumber": 980
          },
          {
            "text": "\t\tsetRunInProgress(true);",
            "lineNumber": 981
          },
          {
            "text": "\t\tsetRunStartCanvasData(getCanvasKey(view.file.path), liveCanvas.getData?.() ?? null);",
            "lineNumber": 982
          },
          {
            "text": "\t\ttry {",
            "lineNumber": 983
          },
          {
            "text": "\t\t\tconst result = await runnerRunEntireCanvas(this.app, this.settings, view.file.path, liveCanvas, getRunStartCanvasData(getCanvasKey(view.file.path)));",
            "lineNumber": 984
          },
          {
            "text": "\t\t\tif (!result.ok) new Notice(result.message ?? \"Run entire canvas failed.\");",
            "lineNumber": 985
          },
          {
            "text": "\t\t} finally {",
            "lineNumber": 986
          },
          {
            "text": "\t\t\tsetRunInProgress(false);",
            "lineNumber": 987
          },
          {
            "text": "\t\t\tawait this.processQueue();",
            "lineNumber": 988
          },
          {
            "text": "\t\t}",
            "lineNumber": 989
          },
          {
            "text": "\t}",
            "lineNumber": 990
          },
          {
            "lineNumber": 991
          },
          {
            "text": "\t/** Dismiss all output nodes on the canvas (call from canvas background context menu). */",
            "lineNumber": 992
          },
          {
            "text": "}",
            "lineNumber": 1011,
            "isSignature": true
          }
        ]
      },
      "score": 0.20632870495319366
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 932
          },
          "endPosition": {
            "line": 984,
            "column": 132
          }
        },
        "contents": "export async function runChain(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null,\n\tdisplayNodeId?: string,\n\trunStartData?: RunStartCanvasData | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\n\ttry {\n\t\tif (displayNodeId != null) setRunningNodeId(canvasKey, displayNodeId);\n\t\tfor (const nid of order) {\n\t\t\ttry {\n\t\t\t\tif (displayNodeId == null) setRunningNodeId(canvasKey, nid);\n\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas, runStartData ?? null);\n\t\t\t} finally {\n\t\t\t\tif (displayNodeId == null) setRunningNodeId(canvasKey, null);\n\t\t\t}\n\t\t}\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t} finally {\n\t\tif (displayNodeId != null) setRunningNodeId(canvasKey, null);\n\t}\n}\n\n/** Remove the Green output node and any prompt/thinking nodes (and their edges) for a given source node; mutates data and saves. */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 933,
                "column": 1
              },
              "endPosition": {
                "line": 933,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 933,
                "column": 8
              },
              "endPosition": {
                "line": 942,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export async function runChain(",
            "lineNumber": 933,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 934,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 935,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 936,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 937,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null,",
            "lineNumber": 938,
            "isSignature": true
          },
          {
            "text": "\tdisplayNodeId?: string,",
            "lineNumber": 939,
            "isSignature": true
          },
          {
            "text": "\trunStartData?: RunStartCanvasData | null",
            "lineNumber": 940,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 941,
            "isSignature": true
          },
          {
            "lineNumber": 966
          },
          {
            "text": "\ttry {",
            "lineNumber": 967
          },
          {
            "text": "\t\tif (displayNodeId != null) setRunningNodeId(canvasKey, displayNodeId);",
            "lineNumber": 968
          },
          {
            "text": "\t\tfor (const nid of order) {",
            "lineNumber": 969
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 970
          },
          {
            "text": "\t\t\t\tif (displayNodeId == null) setRunningNodeId(canvasKey, nid);",
            "lineNumber": 971
          },
          {
            "text": "\t\t\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nid, liveCanvas, runStartData ?? null);",
            "lineNumber": 972
          },
          {
            "text": "\t\t\t} finally {",
            "lineNumber": 973
          },
          {
            "text": "\t\t\t\tif (displayNodeId == null) setRunningNodeId(canvasKey, null);",
            "lineNumber": 974
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 975
          },
          {
            "text": "\t\t}",
            "lineNumber": 976
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 977
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 978
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 979
          },
          {
            "text": "\t} finally {",
            "lineNumber": 980
          },
          {
            "text": "\t\tif (displayNodeId != null) setRunningNodeId(canvasKey, null);",
            "lineNumber": 981
          },
          {
            "text": "\t}",
            "lineNumber": 982
          },
          {
            "text": "}",
            "lineNumber": 983,
            "isSignature": true
          },
          {
            "lineNumber": 984
          },
          {
            "text": "/** Remove the Green output node and any prompt/thinking nodes (and their edges) for a given source node; mutates data and saves. */",
            "lineNumber": 985
          }
        ]
      },
      "score": 0.20612290501594543
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./esbuild.config.mjs",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 48,
            "column": 1
          }
        },
        "contents": "import esbuild from \"esbuild\";\nimport process from \"process\";\nimport { builtinModules } from 'node:module';\n\nconst banner =\n&#96;/*\nTHIS IS A GENERATED/BUNDLED FILE BY ESBUILD\nif you want to view the source, please visit the github repository of this plugin\n*/\n&#96;;\n\nconst prod = (process.argv[2] === \"production\");\n\nconst context = await esbuild.context({\n\tbanner: {\n\t\tjs: banner,\n\t},\n\tentryPoints: [\"src/main.ts\"],\n\tbundle: true,\n\texternal: [\n\t\t\"obsidian\",\n\t\t\"electron\",\n\t\t\"@codemirror/autocomplete\",\n\t\t\"@codemirror/collab\",\n\t\t\"@codemirror/commands\",\n\t\t\"@codemirror/language\",\n\t\t\"@codemirror/lint\",\n\t\t\"@codemirror/search\",\n\t\t\"@codemirror/state\",\n\t\t\"@codemirror/view\",\n\t\t\"@lezer/common\",\n\t\t\"@lezer/highlight\",\n\t\t\"@lezer/lr\",\n\t\t...builtinModules],\n\tformat: \"cjs\",\n\ttarget: \"es2018\",\n\tlogLevel: \"info\",\n\tsourcemap: prod ? false : \"inline\",\n\ttreeShaking: true,\n\toutfile: \"main.js\",\n\tminify: prod,\n});\n\nif (prod) {\n\tawait context.rebuild();\n\tprocess.exit(0);\n} else {\n\tawait context.watch();\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import esbuild from \"esbuild\";",
            "lineNumber": 1
          },
          {
            "text": "import process from \"process\";",
            "lineNumber": 2
          },
          {
            "text": "import { builtinModules } from 'node:module';",
            "lineNumber": 3
          },
          {
            "lineNumber": 4
          },
          {
            "text": "const banner =",
            "lineNumber": 5
          },
          {
            "text": "&#96;/*",
            "lineNumber": 6
          },
          {
            "text": "THIS IS A GENERATED/BUNDLED FILE BY ESBUILD",
            "lineNumber": 7
          },
          {
            "text": "if you want to view the source, please visit the github repository of this plugin",
            "lineNumber": 8
          },
          {
            "text": "*/",
            "lineNumber": 9
          },
          {
            "text": "&#96;;",
            "lineNumber": 10
          },
          {
            "lineNumber": 11
          },
          {
            "text": "const prod = (process.argv[2] === \"production\");",
            "lineNumber": 12
          },
          {
            "lineNumber": 13
          },
          {
            "text": "const context = await esbuild.context({",
            "lineNumber": 14
          },
          {
            "text": "\tbanner: {",
            "lineNumber": 15
          },
          {
            "text": "\t\tjs: banner,",
            "lineNumber": 16
          },
          {
            "text": "\t},",
            "lineNumber": 17
          },
          {
            "text": "\tentryPoints: [\"src/main.ts\"],",
            "lineNumber": 18
          },
          {
            "text": "\tbundle: true,",
            "lineNumber": 19
          },
          {
            "text": "\texternal: [",
            "lineNumber": 20
          },
          {
            "text": "\t\t\"obsidian\",",
            "lineNumber": 21
          },
          {
            "text": "\t\t\"electron\",",
            "lineNumber": 22
          },
          {
            "text": "\t\t\"@codemirror/autocomplete\",",
            "lineNumber": 23
          },
          {
            "text": "\t\t\"@codemirror/collab\",",
            "lineNumber": 24
          },
          {
            "text": "\t\t\"@codemirror/commands\",",
            "lineNumber": 25
          },
          {
            "text": "\t\t\"@codemirror/language\",",
            "lineNumber": 26
          },
          {
            "text": "\t\t\"@codemirror/lint\",",
            "lineNumber": 27
          },
          {
            "text": "\t\t\"@codemirror/search\",",
            "lineNumber": 28
          },
          {
            "text": "\t\t\"@codemirror/state\",",
            "lineNumber": 29
          },
          {
            "text": "\t\t\"@codemirror/view\",",
            "lineNumber": 30
          },
          {
            "text": "\t\t\"@lezer/common\",",
            "lineNumber": 31
          },
          {
            "text": "\t\t\"@lezer/highlight\",",
            "lineNumber": 32
          },
          {
            "text": "\t\t\"@lezer/lr\",",
            "lineNumber": 33
          },
          {
            "text": "\t\t...builtinModules],",
            "lineNumber": 34
          },
          {
            "text": "\tformat: \"cjs\",",
            "lineNumber": 35
          },
          {
            "text": "\ttarget: \"es2018\",",
            "lineNumber": 36
          },
          {
            "text": "\tlogLevel: \"info\",",
            "lineNumber": 37
          },
          {
            "text": "\tsourcemap: prod ? false : \"inline\",",
            "lineNumber": 38
          },
          {
            "text": "\ttreeShaking: true,",
            "lineNumber": 39
          },
          {
            "text": "\toutfile: \"main.js\",",
            "lineNumber": 40
          },
          {
            "text": "\tminify: prod,",
            "lineNumber": 41
          },
          {
            "text": "});",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "if (prod) {",
            "lineNumber": 44
          },
          {
            "text": "\tawait context.rebuild();",
            "lineNumber": 45
          },
          {
            "text": "\tprocess.exit(0);",
            "lineNumber": 46
          },
          {
            "text": "} else {",
            "lineNumber": 47
          },
          {
            "text": "\tawait context.watch();",
            "lineNumber": 48
          },
          {
            "text": "}",
            "lineNumber": 49
          }
        ]
      },
      "score": 0.2045494019985199
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/views/ZettelControlsView.ts",
        "range": {
          "startPosition": {
            "line": 25
          },
          "endPosition": {
            "line": 215,
            "column": 1
          }
        },
        "contents": "export class ZettelControlsView extends ItemView {\nasync onOpen(): Promise&lt;void&gt; {\n\n\t\tconst guideDetails = el.createEl(\"details\", { cls: \"ztb-guide-details\" });\n\t\tguideDetails.createEl(\"summary\", { cls: \"ztb-guide-summary\", text: \"How to use the canvas\" });\n\t\tconst guideList = guideDetails.createEl(\"ul\", { cls: \"ztb-guide-list\" });\n\t\tconst tips = [\n\t\t\t\"Each color is a different way to work with text: one color might ask an AI a question, another might run a short Python snippet, and the green card is where the result shows up.\",\n\t\t\t\"Text (yellow) nodes are input pass-through: their content is sent to the next node. Uncolored or unused-color cards are not connected and do not add to any prompt.\",\n\t\t\t\"An arrow from one card to another sends its text as input. You can change how it's combined by clicking the arrow's label.\",\n\t\t\t\"Right-click a card and choose Run node to run just that card, or Run chain to run it and every card that feeds into it.\",\n\t\t\t\"The green card is where answers and results appear. It gets created or updated when you run an AI or Python card.\",\n\t\t\t\"You can plug text from one card into another by using {{var:name}} in the card text and giving the edge that variable name as its label.\",\n\t\t\t\"Python (blue) cards are auto-wrapped in a code block so # comments render as comments; the plugin adds the fence when you run the node if needed.\",\n\t\t\t\"Use the command \\\"Create tutorial canvas\\\" for a full showcase: every node type, concat vs variable injection, Run buttons, and this sidebar.\",\n\t\t];\n\t\tfor (const tip of tips) {\n\t\t\tconst li = guideList.createEl(\"li\");\n\t\t\tli.setText(tip);\n\t\t}\n\t}\n\n\tasync onClose(): Promise&lt;void&gt; {\n\t\tthis.containerEl.removeClass(\"ztb-controls-view\");\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 26,
                "column": 1
              },
              "endPosition": {
                "line": 26,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 26,
                "column": 8
              },
              "endPosition": {
                "line": 27,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 43,
                "column": 2
              },
              "endPosition": {
                "line": 44,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export class ZettelControlsView extends ItemView {",
            "lineNumber": 26,
            "isSignature": true
          },
          {
            "text": "async onOpen(): Promise&lt;void&gt; {",
            "lineNumber": 43
          },
          {
            "lineNumber": 192
          },
          {
            "text": "\t\tconst guideDetails = el.createEl(\"details\", { cls: \"ztb-guide-details\" });",
            "lineNumber": 193
          },
          {
            "text": "\t\tguideDetails.createEl(\"summary\", { cls: \"ztb-guide-summary\", text: \"How to use the canvas\" });",
            "lineNumber": 194
          },
          {
            "text": "\t\tconst guideList = guideDetails.createEl(\"ul\", { cls: \"ztb-guide-list\" });",
            "lineNumber": 195
          },
          {
            "text": "\t\tconst tips = [",
            "lineNumber": 196
          },
          {
            "text": "\t\t\t\"Each color is a different way to work with text: one color might ask an AI a question, another might run a short Python snippet, and the green card is where the result shows up.\",",
            "lineNumber": 197
          },
          {
            "text": "\t\t\t\"Text (yellow) nodes are input pass-through: their content is sent to the next node. Uncolored or unused-color cards are not connected and do not add to any prompt.\",",
            "lineNumber": 198
          },
          {
            "text": "\t\t\t\"An arrow from one card to another sends its text as input. You can change how it's combined by clicking the arrow's label.\",",
            "lineNumber": 199
          },
          {
            "text": "\t\t\t\"Right-click a card and choose Run node to run just that card, or Run chain to run it and every card that feeds into it.\",",
            "lineNumber": 200
          },
          {
            "text": "\t\t\t\"The green card is where answers and results appear. It gets created or updated when you run an AI or Python card.\",",
            "lineNumber": 201
          },
          {
            "text": "\t\t\t\"You can plug text from one card into another by using {{var:name}} in the card text and giving the edge that variable name as its label.\",",
            "lineNumber": 202
          },
          {
            "text": "\t\t\t\"Python (blue) cards are auto-wrapped in a code block so # comments render as comments; the plugin adds the fence when you run the node if needed.\",",
            "lineNumber": 203
          },
          {
            "text": "\t\t\t\"Use the command \\\"Create tutorial canvas\\\" for a full showcase: every node type, concat vs variable injection, Run buttons, and this sidebar.\",",
            "lineNumber": 204
          },
          {
            "text": "\t\t];",
            "lineNumber": 205
          },
          {
            "text": "\t\tfor (const tip of tips) {",
            "lineNumber": 206
          },
          {
            "text": "\t\t\tconst li = guideList.createEl(\"li\");",
            "lineNumber": 207
          },
          {
            "text": "\t\t\tli.setText(tip);",
            "lineNumber": 208
          },
          {
            "text": "\t\t}",
            "lineNumber": 209
          },
          {
            "text": "\t}",
            "lineNumber": 210
          },
          {
            "lineNumber": 211
          },
          {
            "text": "\tasync onClose(): Promise&lt;void&gt; {",
            "lineNumber": 212
          },
          {
            "text": "\t\tthis.containerEl.removeClass(\"ztb-controls-view\");",
            "lineNumber": 213
          },
          {
            "text": "\t}",
            "lineNumber": 215
          },
          {
            "text": "}",
            "lineNumber": 216,
            "isSignature": true
          }
        ]
      },
      "score": 0.20444490015506744
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>

I found the relevant code. Let me analyze what I found:

1. **`stripPythonCodeFence`** (lines 198-209 in runner.ts): This function strips markdown code fences (```python or ```) from the template before execution. It checks:
   - First line matches `/^```(?:python)?\s*$/i` (opening fence with optional "python" language tag)
   - Last line matches `/^```\s*$/` (closing fence)
   - If both match, it returns `lines.slice(1, -1).join("\n").trim()` - i.e., the content without the first and last lines

2. **Usage when running Python** (lines 435-442 in runner.ts):
```ts
if (role === "blue") {
    const kernel = getKernelForCanvas(canvasKey, settings.pythonPath);
    const code = stripPythonCodeFence(template);
    const result = await kernel.run(code, concatenatedPart);
```

So yes - when running a Python (blue) node, the code goes through `stripPythonCodeFence(template)` before being passed to the kernel. The code fencing is automatically removed.

Let me verify the `stripPythonCodeFence` logic handles edge cases properly:
- ````python\ncode\n```  -> strips to `code`
- ````\ncode\n```  -> strips to `code` (generic fence)
- `code only` -> returns `code` trimmed (no fence, returns as-is via `template.trim()`)
- Single line -> `lines.length < 2` returns `template.trim()` - so no stripping attempted
- Two lines that look like fence -> would strip if first is ```python and last is ```

Actually wait - for a minimal fenced block:
```
```python
print("hello")
```
```
That's 4 lines: line 0 = ```python, line 1 = print("hello"), line 2 = ```, line 3 = (empty?)
Actually in markdown it would be:
Line 0: ```python
Line 1: print("hello")
Line 2: ```

So lines.length >= 2, first line ```python, last line ```. Good.

One edge case: what if there's trailing newline after the closing ```? The regex `/^```\s*$/` would match ``` with optional whitespace. Good.

What if the first line has something like ``` python (with space)? The regex is `^```(?:python)?\s*$` - so ``` followed by optional "python", then optional whitespace. So ``` python would match. Good.

I should provide a clear answer to the user - yes, the code fencing is automatically removed when running Python nodes.
</details></think>

---


Yes. Code fencing is automatically removed before running Python nodes.

1. **Stripping logic** in `src/engine/runner.ts`:

```198:209:src/engine/runner.ts
/** Strip optional markdown code fence (```python or ```) so execution runs raw code. */
function stripPythonCodeFence(template: string): string {
	const lines = template.split(/\r?\n/);
	if (lines.length < 2) return template.trim();
	const first = lines[0];
	const last = lines[lines.length - 1];
	if (first == null || last == null) return template.trim();
	if (/^```(?:python)?\s*$/i.test(first.trim()) && /^```\s*$/.test(last.trim())) {
		return lines.slice(1, -1).join("\n").trim();
	}
	return template.trim();
}
```

2. **Usage when running Python** (blue) nodes:

```435:441:src/engine/runner.ts
	if (role === "blue") {
		const kernel = getKernelForCanvas(canvasKey, settings.pythonPath);
		const code = stripPythonCodeFence(template);
		const result = await kernel.run(code, concatenatedPart);
```

`template` is the Python content (including any variables). Before running it, its passed through `stripPythonCodeFence()` so that:

- ```python` (or plain ` ``` `) on the first line is removed
- Closing ` ``` ` on the last line is removed
- The inner code is executed

So notes with fenced Py

---

