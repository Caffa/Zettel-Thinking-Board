<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session facbe8a4-aedb-4a64-8e2e-b41307bf2ee2 (2026-02-03 13:54Z) -->

# Text node bug and prompt view improvements (2026-02-03 13:54Z)

_**User**_

There is a bug where if I pass a text node into a second text node and I pass that into an AI, the AI only gets the second text node and its own text. The text from the first node should have been in there, but it is not. 

Also the prompt view node, should be have overlap collision avoidance. If possible connect it to the AI model note it comes from by the side that is not already occupied by input or output arrows. 

---

_**Agent (model default, mode Agent)**_


Exploring the codebase to trace how text nodes feed into AI nodes and how the prompt view node is created and connected.


---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "How does text node content get passed into AI node or build prompt from connected nodes?",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 264,
            "column": 1
          },
          "endPosition": {
            "line": 369,
            "column": 1
          }
        },
        "contents": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */\nasync function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return \"\";\n\tconst role = getNodeRole(node, settings);\n\tif (!role || role === \"yellow\" || role === \"green\") {\n\t\t// Yellow = text (input pass-through): use node content as result\n\t\tif (role === \"yellow\") {\n\t\t\tconst content = await getNodeContent(node, app.vault);\n\t\t\tsetNodeResult(canvasKey, nodeId, content);\n\t\t\treturn content;\n\t\t}\n\t\treturn \"\";\n\t}\n\t// For Python (blue) text nodes, auto-wrap content in &#96;&#96;&#96;python ... &#96;&#96;&#96; so # comments render correctly\n\tif (role === \"blue\" &amp;&amp; isTextNode(node)) {\n\t\tconst raw = getTextNodeContent(node as CanvasTextData);\n\t\tif (!isPythonCodeFenced(raw)) {\n\t\t\t(node as CanvasTextData).text = ensurePythonCodeFence(raw);\n\t\t\tliveCanvas?.setData?.(data);\n\t\t\tif (liveCanvas?.requestSave) liveCanvas.requestSave();\n\t\t\tawait saveCanvasData(app.vault, canvasFilePath, data);\n\t\t}\n\t}\n\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\tconst nodeInput = await getNodeContent(node, app.vault);\n\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(\n\t\tcanvasKey,\n\t\tnodeInput,\n\t\tincoming\n\t);\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 267
          },
          {
            "text": "async function runSingleNode(",
            "lineNumber": 268,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 269,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 270,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 271,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 272,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 273,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 274,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 275,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 276,
            "isSignature": true
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 277
          },
          {
            "text": "\tif (!node) return \"\";",
            "lineNumber": 278
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 279
          },
          {
            "text": "\tif (!role || role === \"yellow\" || role === \"green\") {",
            "lineNumber": 280
          },
          {
            "text": "\t\t// Yellow = text (input pass-through): use node content as result",
            "lineNumber": 281
          },
          {
            "text": "\t\tif (role === \"yellow\") {",
            "lineNumber": 282
          },
          {
            "text": "\t\t\tconst content = await getNodeContent(node, app.vault);",
            "lineNumber": 283
          },
          {
            "text": "\t\t\tsetNodeResult(canvasKey, nodeId, content);",
            "lineNumber": 284
          },
          {
            "text": "\t\t\treturn content;",
            "lineNumber": 285
          },
          {
            "text": "\t\t}",
            "lineNumber": 286
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 287
          },
          {
            "text": "\t}",
            "lineNumber": 288
          },
          {
            "text": "\t// For Python (blue) text nodes, auto-wrap content in &#96;&#96;&#96;python ... &#96;&#96;&#96; so # comments render correctly",
            "lineNumber": 289
          },
          {
            "text": "\tif (role === \"blue\" &amp;&amp; isTextNode(node)) {",
            "lineNumber": 290
          },
          {
            "text": "\t\tconst raw = getTextNodeContent(node as CanvasTextData);",
            "lineNumber": 291
          },
          {
            "text": "\t\tif (!isPythonCodeFenced(raw)) {",
            "lineNumber": 292
          },
          {
            "text": "\t\t\t(node as CanvasTextData).text = ensurePythonCodeFence(raw);",
            "lineNumber": 293
          },
          {
            "text": "\t\t\tliveCanvas?.setData?.(data);",
            "lineNumber": 294
          },
          {
            "text": "\t\t\tif (liveCanvas?.requestSave) liveCanvas.requestSave();",
            "lineNumber": 295
          },
          {
            "text": "\t\t\tawait saveCanvasData(app.vault, canvasFilePath, data);",
            "lineNumber": 296
          },
          {
            "text": "\t\t}",
            "lineNumber": 297
          },
          {
            "text": "\t}",
            "lineNumber": 298
          },
          {
            "text": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 299
          },
          {
            "text": "\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 300
          },
          {
            "text": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(",
            "lineNumber": 301
          },
          {
            "text": "\t\tcanvasKey,",
            "lineNumber": 302
          },
          {
            "text": "\t\tnodeInput,",
            "lineNumber": 303
          },
          {
            "text": "\t\tincoming",
            "lineNumber": 304
          },
          {
            "text": "\t);",
            "lineNumber": 305
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 306
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 307
          },
          {
            "lineNumber": 308
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 309
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 310
          },
          {
            "text": "}",
            "lineNumber": 370,
            "isSignature": true
          }
        ]
      },
      "score": 0.5103927254676819
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 194,
            "column": 1
          },
          "endPosition": {
            "line": 234,
            "column": 107
          }
        },
        "contents": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */\nfunction buildInputWithVariables(\n\tcanvasKey: string,\n\tnodeInput: string,\n\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[]\n): { concatenatedPart: string; template: string; edgeModes: Map&lt;string, EdgeInputMode&gt; } {\n\tconst edgeModes = new Map&lt;string, EdgeInputMode&gt;();\n\tconst parentResults = new Map&lt;string, string&gt;();\n\tfor (const { parentId } of incoming) {\n\t\tconst r = getNodeResult(canvasKey, parentId);\n\t\tif (r != null) parentResults.set(parentId, r);\n\t}\n\tlet concatenatedPart = \"\";\n\tconst varValues: Record&lt;string, string&gt; = {};\n\tfor (const { parentId, edge, variableName } of incoming) {\n\t\tconst result = parentResults.get(parentId);\n\t\tif (result == null) continue;\n\t\tconst usedAsVar =\n\t\t\tvariableName.length &gt; 0 &amp;&amp; nodeInput.includes(&#96;{{var:${variableName}}}&#96;);\n\t\tif (usedAsVar) {\n\t\t\tedgeModes.set(edge.id, \"inject\");\n\t\t\tvarValues[variableName] = result;\n\t\t} else {\n\t\t\tedgeModes.set(edge.id, \"concatenate\");\n\t\t\tconcatenatedPart += result + \"\\n\\n\";\n\t\t}\n\t}\n\tlet template = nodeInput;\n\tfor (const [name, value] of Object.entries(varValues)) {\n\t\ttemplate = template.split(&#96;{{var:${name}}}&#96;).join(value);\n\t}\n\treturn {\n\t\tconcatenatedPart: concatenatedPart.trim(),\n\t\ttemplate,\n\t\tedgeModes,\n\t};\n}\n\n/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build concatenated context, template with {{var:name}} substituted, and per-edge mode. */",
            "lineNumber": 197
          },
          {
            "text": "function buildInputWithVariables(",
            "lineNumber": 198,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 199,
            "isSignature": true
          },
          {
            "text": "\tnodeInput: string,",
            "lineNumber": 200,
            "isSignature": true
          },
          {
            "text": "\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[]",
            "lineNumber": 201,
            "isSignature": true
          },
          {
            "text": "): { concatenatedPart: string; template: string; edgeModes: Map&lt;string, EdgeInputMode&gt; } {",
            "lineNumber": 202,
            "isSignature": true
          },
          {
            "text": "\tconst edgeModes = new Map&lt;string, EdgeInputMode&gt;();",
            "lineNumber": 203
          },
          {
            "text": "\tconst parentResults = new Map&lt;string, string&gt;();",
            "lineNumber": 204
          },
          {
            "text": "\tfor (const { parentId } of incoming) {",
            "lineNumber": 205
          },
          {
            "text": "\t\tconst r = getNodeResult(canvasKey, parentId);",
            "lineNumber": 206
          },
          {
            "text": "\t\tif (r != null) parentResults.set(parentId, r);",
            "lineNumber": 207
          },
          {
            "text": "\t}",
            "lineNumber": 208
          },
          {
            "text": "\tlet concatenatedPart = \"\";",
            "lineNumber": 209
          },
          {
            "text": "\tconst varValues: Record&lt;string, string&gt; = {};",
            "lineNumber": 210
          },
          {
            "text": "\tfor (const { parentId, edge, variableName } of incoming) {",
            "lineNumber": 211
          },
          {
            "text": "\t\tconst result = parentResults.get(parentId);",
            "lineNumber": 212
          },
          {
            "text": "\t\tif (result == null) continue;",
            "lineNumber": 213
          },
          {
            "text": "\t\tconst usedAsVar =",
            "lineNumber": 214
          },
          {
            "text": "\t\t\tvariableName.length &gt; 0 &amp;&amp; nodeInput.includes(&#96;{{var:${variableName}}}&#96;);",
            "lineNumber": 215
          },
          {
            "text": "\t\tif (usedAsVar) {",
            "lineNumber": 216
          },
          {
            "text": "\t\t\tedgeModes.set(edge.id, \"inject\");",
            "lineNumber": 217
          },
          {
            "text": "\t\t\tvarValues[variableName] = result;",
            "lineNumber": 218
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 219
          },
          {
            "text": "\t\t\tedgeModes.set(edge.id, \"concatenate\");",
            "lineNumber": 220
          },
          {
            "text": "\t\t\tconcatenatedPart += result + \"\\n\\n\";",
            "lineNumber": 221
          },
          {
            "text": "\t\t}",
            "lineNumber": 222
          },
          {
            "text": "\t}",
            "lineNumber": 223
          },
          {
            "text": "\tlet template = nodeInput;",
            "lineNumber": 224
          },
          {
            "text": "\tfor (const [name, value] of Object.entries(varValues)) {",
            "lineNumber": 225
          },
          {
            "text": "\t\ttemplate = template.split(&#96;{{var:${name}}}&#96;).join(value);",
            "lineNumber": 226
          },
          {
            "text": "\t}",
            "lineNumber": 227
          },
          {
            "text": "\treturn {",
            "lineNumber": 228
          },
          {
            "text": "\t\tconcatenatedPart: concatenatedPart.trim(),",
            "lineNumber": 229
          },
          {
            "text": "\t\ttemplate,",
            "lineNumber": 230
          },
          {
            "text": "\t\tedgeModes,",
            "lineNumber": 231
          },
          {
            "text": "\t};",
            "lineNumber": 232
          },
          {
            "text": "}",
            "lineNumber": 233,
            "isSignature": true
          },
          {
            "lineNumber": 234
          },
          {
            "text": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
            "lineNumber": 235
          }
        ]
      },
      "score": 0.4362497329711914
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/nodes.ts",
        "range": {
          "startPosition": {
            "line": 34,
            "column": 1
          },
          "endPosition": {
            "line": 76,
            "column": 1
          }
        },
        "contents": "/** Get input content for a node: text node content or full file content. */\nexport async function getNodeContent(\n\tnode: AllCanvasNodeData,\n\tvault: Vault\n): Promise&lt;string&gt; {\n\tif (isTextNode(node)) return getTextNodeContent(node as CanvasTextData);\n\tif (isFileNode(node)) {\n\t\tconst path = getFileNodePath(node as CanvasFileData);\n\t\tif (!path) return \"\";\n\t\tconst file = vault.getFileByPath(path);\n\t\tif (file) {\n\t\t\ttry {\n\t\t\t\treturn await vault.cachedRead(file);\n\t\t\t} catch {\n\t\t\t\t//\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n\treturn \"\";\n}\n\n// Re-export for callers\nexport {\n\tEDGE_LABEL_OUTPUT,\n\tEDGE_LABEL_PROMPT,\n;",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get input content for a node: text node content or full file content. */",
            "lineNumber": 37
          },
          {
            "text": "export async function getNodeContent(",
            "lineNumber": 38,
            "isSignature": true
          },
          {
            "text": "\tnode: AllCanvasNodeData,",
            "lineNumber": 39,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault",
            "lineNumber": 40,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 41,
            "isSignature": true
          },
          {
            "text": "\tif (isTextNode(node)) return getTextNodeContent(node as CanvasTextData);",
            "lineNumber": 42
          },
          {
            "text": "\tif (isFileNode(node)) {",
            "lineNumber": 43
          },
          {
            "text": "\t\tconst path = getFileNodePath(node as CanvasFileData);",
            "lineNumber": 44
          },
          {
            "text": "\t\tif (!path) return \"\";",
            "lineNumber": 45
          },
          {
            "text": "\t\tconst file = vault.getFileByPath(path);",
            "lineNumber": 46
          },
          {
            "text": "\t\tif (file) {",
            "lineNumber": 47
          },
          {
            "text": "\t\t\ttry {",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\treturn await vault.cachedRead(file);",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t} catch {",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t\t//",
            "lineNumber": 51
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 52
          },
          {
            "text": "\t\t}",
            "lineNumber": 53
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 54
          },
          {
            "text": "\t}",
            "lineNumber": 55
          },
          {
            "text": "\treturn \"\";",
            "lineNumber": 56
          },
          {
            "text": "}",
            "lineNumber": 57,
            "isSignature": true
          },
          {
            "lineNumber": 58
          },
          {
            "text": "// Re-export for callers",
            "lineNumber": 59
          },
          {
            "text": "export {",
            "lineNumber": 60
          },
          {
            "text": "\tEDGE_LABEL_OUTPUT,",
            "lineNumber": 61
          },
          {
            "text": "\tEDGE_LABEL_PROMPT,",
            "lineNumber": 62
          },
          {
            "text": ";",
            "lineNumber": 77
          }
        ]
      },
      "score": 0.3635503947734833
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 457
          },
          "endPosition": {
            "line": 699,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\nconst { x: px, y: py } = (\n\t\t\tdata,\n\t\t\tsourceNode.id,\n\t\t\tpromptId,\n\t\t\tdefaultX,\n\t\t\tpromptDefaultY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tpromptExclude\n\t\t);\n\t\tconst promptColor = shadeColor(settings.colorGreen, 0.25);\n\n\t\tif (promptId) {\n\t\t\tconst pn = getNodeById(data, promptId);\n\t\t\tif (pn &amp;&amp; isTextNode(pn)) {\n\t\t\t\tconst updated = {\n\t\t\t\t\t...(pn as CanvasTextData),\n\t\t\t\t\ttext: fullPrompt,\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\tcolor: promptColor,\n\t\t\t\t};\n\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === promptId);\n\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t\t}\n\t\t\tconst hasEdge = data.edges.some(\n\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === promptId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT\n\t\t\t);\n\t\t\tif (!hasEdge) {\n\t\t\t\tdata.edges.push({\n\t\t\t\t\tid: randomId(),\n\t\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\t\ttoNode: promptId,\n\t\t\t\t\tlabel: EDGE_LABEL_PROMPT,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst newId = randomId();\n\t\t\tdata.nodes.push({\n\t\t\t\tid: newId,\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: fullPrompt,\n\t\t\t\tx: px,\n\t\t\t\ty: py,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tcolor: promptColor,\n\t\t\t} as CanvasTextData);\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: newId,\n\t\t\t\tlabel: EDGE_LABEL_PROMPT,\n\t\t\t});\n\t\t}\n\t}\n}\n\n/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */\nexport async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return { ok: false, message: \"Node not found.\" };\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 458,
                "column": 1
              },
              "endPosition": {
                "line": 465,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 460,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 461,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 463,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 464,
            "isSignature": true
          },
          {
            "text": "const { x: px, y: py } = (",
            "lineNumber": 611
          },
          {
            "text": "\t\t\tdata,",
            "lineNumber": 612
          },
          {
            "text": "\t\t\tsourceNode.id,",
            "lineNumber": 613
          },
          {
            "text": "\t\t\tpromptId,",
            "lineNumber": 614
          },
          {
            "text": "\t\t\tdefaultX,",
            "lineNumber": 615
          },
          {
            "text": "\t\t\tpromptDefaultY,",
            "lineNumber": 616
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 617
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 618
          },
          {
            "text": "\t\t\tpromptExclude",
            "lineNumber": 619
          },
          {
            "text": "\t\t);",
            "lineNumber": 620
          },
          {
            "text": "\t\tconst promptColor = shadeColor(settings.colorGreen, 0.25);",
            "lineNumber": 621
          },
          {
            "lineNumber": 622
          },
          {
            "text": "\t\tif (promptId) {",
            "lineNumber": 623
          },
          {
            "text": "\t\t\tconst pn = getNodeById(data, promptId);",
            "lineNumber": 624
          },
          {
            "text": "\t\t\tif (pn &amp;&amp; isTextNode(pn)) {",
            "lineNumber": 625
          },
          {
            "text": "\t\t\t\tconst updated = {",
            "lineNumber": 626
          },
          {
            "text": "\t\t\t\t\t...(pn as CanvasTextData),",
            "lineNumber": 627
          },
          {
            "text": "\t\t\t\t\ttext: fullPrompt,",
            "lineNumber": 628
          },
          {
            "text": "\t\t\t\t\twidth,",
            "lineNumber": 629
          },
          {
            "text": "\t\t\t\t\theight,",
            "lineNumber": 630
          },
          {
            "text": "\t\t\t\t\tcolor: promptColor,",
            "lineNumber": 631
          },
          {
            "text": "\t\t\t\t};",
            "lineNumber": 632
          },
          {
            "text": "\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === promptId);",
            "lineNumber": 633
          },
          {
            "text": "\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 634
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 635
          },
          {
            "text": "\t\t\tconst hasEdge = data.edges.some(",
            "lineNumber": 636
          },
          {
            "text": "\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === promptId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT",
            "lineNumber": 637
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 638
          },
          {
            "text": "\t\t\tif (!hasEdge) {",
            "lineNumber": 639
          },
          {
            "text": "\t\t\t\tdata.edges.push({",
            "lineNumber": 640
          },
          {
            "text": "\t\t\t\t\tid: randomId(),",
            "lineNumber": 641
          },
          {
            "text": "\t\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 642
          },
          {
            "text": "\t\t\t\t\ttoNode: promptId,",
            "lineNumber": 643
          },
          {
            "text": "\t\t\t\t\tlabel: EDGE_LABEL_PROMPT,",
            "lineNumber": 644
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 645
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 646
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 647
          },
          {
            "text": "\t\t\tconst newId = randomId();",
            "lineNumber": 648
          },
          {
            "text": "\t\t\tdata.nodes.push({",
            "lineNumber": 649
          },
          {
            "text": "\t\t\t\tid: newId,",
            "lineNumber": 650
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 651
          },
          {
            "text": "\t\t\t\ttext: fullPrompt,",
            "lineNumber": 652
          },
          {
            "text": "\t\t\t\tx: px,",
            "lineNumber": 653
          },
          {
            "text": "\t\t\t\ty: py,",
            "lineNumber": 654
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 655
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 656
          },
          {
            "text": "\t\t\t\tcolor: promptColor,",
            "lineNumber": 657
          },
          {
            "text": "\t\t\t} as CanvasTextData);",
            "lineNumber": 658
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 659
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 660
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 661
          },
          {
            "text": "\t\t\t\ttoNode: newId,",
            "lineNumber": 662
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_PROMPT,",
            "lineNumber": 663
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 664
          },
          {
            "text": "\t\t}",
            "lineNumber": 665
          },
          {
            "text": "\t}",
            "lineNumber": 666
          },
          {
            "text": "}",
            "lineNumber": 667,
            "isSignature": true
          },
          {
            "lineNumber": 668
          },
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 669
          },
          {
            "text": "export async function runNode(",
            "lineNumber": 670,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 671,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 672,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 673,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 674,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 675,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 676,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 677
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 678
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 679
          },
          {
            "text": "\tif (!node) return { ok: false, message: \"Node not found.\" };",
            "lineNumber": 680
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 681
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 682
          },
          {
            "text": "}",
            "lineNumber": 700,
            "isSignature": true
          }
        ]
      },
      "score": 0.36038631200790405
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 97
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\n\n\tconst nodes: CanvasData[\"nodes\"] = [\n\t\t// Groups first (render behind)\n\t\tgroupWelcome,\n\t\tgroupCol1,\n\t\tgroupCol2,\n\t\tgroupCol3,\n\t\tgroupCol4,\n\t\tgroupCol5,\n\t\tgroupCol6,\n\t\t// Welcome: plain text (no color = no role; not connected, does not add to prompt)\n\t\tn(welcome, \"Welcome to Zettel Thinking Board. Each column is a separate showcase. Nodes run top to bottom. Right-click a card → Run node or Run chain. Uncolored or unused-color cards are not connected to any node and do not add to the prompt.\", TUT_LEFT, welcomeY, \"\", TUT_WELCOME_W, 132),\n\n\t\t// Column 1: label = plain text; nodes in lane have roles\n\t\tn(lab1, \"Primary model: sends prompt to Ollama. Set the model in Zettel Controls.\", commentLeftX(col1), orangeY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(orangeNode, \"What is 2+2? Reply in one sentence.\", laneNodeX(col1, 0), orangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(orangeOut, \"\", laneNodeX(col1, LANE_OFFSET), orangeOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 2\n\t\tn(lab2a, \"Secondary model (same idea, different model).\", commentLeftX(col2), purpleY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(purpleNode, \"Summarize in 5 words: The quick brown fox jumps.\", laneNodeX(col2, 0), purpleY, cPurple, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(purpleOut, \"\", laneNodeX(col2, LANE_OFFSET), purpleOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(lab2b, \"Text: input text; passed to next node as-is (pass-through).\", commentRightX(col2), yellowY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(yellowNode, \"I'm input text. My text is passed to the next node (concatenated).\", laneNodeX(col2, 0), yellowY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(lab2c, \"Python: runs code. Use variable input for parent text.\", commentLeftX(col2), blueY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(blueNode, \"print('Python says:', (input or '')[:80] or '(no input)')\\n# input = text from parent\", laneNodeX(col2, LANE_OFFSET), blueY, cBlue, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 3\n\t\tn\n,\n\t];\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 98,
                "column": 1
              },
              "endPosition": {
                "line": 99,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "lineNumber": 257
          },
          {
            "lineNumber": 258
          },
          {
            "text": "\tconst nodes: CanvasData[\"nodes\"] = [",
            "lineNumber": 259
          },
          {
            "text": "\t\t// Groups first (render behind)",
            "lineNumber": 260
          },
          {
            "text": "\t\tgroupWelcome,",
            "lineNumber": 261
          },
          {
            "text": "\t\tgroupCol1,",
            "lineNumber": 262
          },
          {
            "text": "\t\tgroupCol2,",
            "lineNumber": 263
          },
          {
            "text": "\t\tgroupCol3,",
            "lineNumber": 264
          },
          {
            "text": "\t\tgroupCol4,",
            "lineNumber": 265
          },
          {
            "text": "\t\tgroupCol5,",
            "lineNumber": 266
          },
          {
            "text": "\t\tgroupCol6,",
            "lineNumber": 267
          },
          {
            "text": "\t\t// Welcome: plain text (no color = no role; not connected, does not add to prompt)",
            "lineNumber": 268
          },
          {
            "text": "\t\tn(welcome, \"Welcome to Zettel Thinking Board. Each column is a separate showcase. Nodes run top to bottom. Right-click a card → Run node or Run chain. Uncolored or unused-color cards are not connected to any node and do not add to the prompt.\", TUT_LEFT, welcomeY, \"\", TUT_WELCOME_W, 132),",
            "lineNumber": 269
          },
          {
            "lineNumber": 270
          },
          {
            "text": "\t\t// Column 1: label = plain text; nodes in lane have roles",
            "lineNumber": 271
          },
          {
            "text": "\t\tn(lab1, \"Primary model: sends prompt to Ollama. Set the model in Zettel Controls.\", commentLeftX(col1), orangeY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 272
          },
          {
            "text": "\t\tn(orangeNode, \"What is 2+2? Reply in one sentence.\", laneNodeX(col1, 0), orangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 273
          },
          {
            "text": "\t\tn(orangeOut, \"\", laneNodeX(col1, LANE_OFFSET), orangeOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 274
          },
          {
            "lineNumber": 275
          },
          {
            "text": "\t\t// Column 2",
            "lineNumber": 276
          },
          {
            "text": "\t\tn(lab2a, \"Secondary model (same idea, different model).\", commentLeftX(col2), purpleY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 277
          },
          {
            "text": "\t\tn(purpleNode, \"Summarize in 5 words: The quick brown fox jumps.\", laneNodeX(col2, 0), purpleY, cPurple, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 278
          },
          {
            "text": "\t\tn(purpleOut, \"\", laneNodeX(col2, LANE_OFFSET), purpleOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 279
          },
          {
            "text": "\t\tn(lab2b, \"Text: input text; passed to next node as-is (pass-through).\", commentRightX(col2), yellowY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 280
          },
          {
            "text": "\t\tn(yellowNode, \"I'm input text. My text is passed to the next node (concatenated).\", laneNodeX(col2, 0), yellowY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 281
          },
          {
            "text": "\t\tn(lab2c, \"Python: runs code. Use variable input for parent text.\", commentLeftX(col2), blueY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 282
          },
          {
            "text": "\t\tn(blueNode, \"print('Python says:', (input or '')[:80] or '(no input)')\\n# input = text from parent\", laneNodeX(col2, LANE_OFFSET), blueY, cBlue, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 283
          },
          {
            "text": "\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 284
          },
          {
            "lineNumber": 285
          },
          {
            "text": "\t\t// Column 3",
            "lineNumber": 286
          },
          {
            "text": "\t\tn",
            "lineNumber": 287
          },
          {
            "text": ",",
            "lineNumber": 300
          },
          {
            "text": "\t];",
            "lineNumber": 301
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.31098473072052
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 35,
            "column": 109
          }
        },
        "contents": "import type {App} from \"obsidian\";\nimport {Notice} from \"obsidian\";\nimport {\n\tEDGE_LABEL_OUTPUT,\n\tEDGE_LABEL_PROMPT,\n\tEDGE_LABEL_THINKING,\n\tfindAuxiliaryNodeForSource,\n\tfindOutputNodeForSource,\n\tgetNodeById,\n\tgetNodeContent,\n\tgetNodeRole,\n\tgetIncomingEdgesWithLabels,\n\tgetParentIdsSortedByY,\n\tGREEN_NODE_PADDING,\n\tisAuxiliaryEdge,\n\tloadCanvasData,\n\tsaveCanvasData,\n} from \"../canvas/nodes\";\nimport type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";\nimport { getTextNodeContent, parseEdgeVariableName } from \"../canvas/types\";\nimport {isTextNode} from \"../canvas/types\";\nimport type {LiveCanvas} from \"./canvasApi\";\nimport {getKernelForCanvas} from \"./kernelManager\";\nimport {ollamaGenerate} from \"./ollama\";\nimport {\n\tgetCanvasKey,\n\tgetNodeResult,\n\tsetNodeResult,\n\tsetEdgeModes,\n\tsetRunningNodeId,\n} from \"./state\";\nimport {DEFAULT_SETTINGS, shadeColor, type NodeRole, type ZettelPluginSettings} from \"../settings\";\n\ntype EdgeInputMode = \"inject\" | \"concatenate\";\n\n/** True if the role is non-AI (Python or text pass-through); prefer running these first for early output. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {App} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {Notice} from \"obsidian\";",
            "lineNumber": 2
          },
          {
            "text": "import {",
            "lineNumber": 3
          },
          {
            "text": "\tEDGE_LABEL_OUTPUT,",
            "lineNumber": 4
          },
          {
            "text": "\tEDGE_LABEL_PROMPT,",
            "lineNumber": 5
          },
          {
            "text": "\tEDGE_LABEL_THINKING,",
            "lineNumber": 6
          },
          {
            "text": "\tfindAuxiliaryNodeForSource,",
            "lineNumber": 7
          },
          {
            "text": "\tfindOutputNodeForSource,",
            "lineNumber": 8
          },
          {
            "text": "\tgetNodeById,",
            "lineNumber": 9
          },
          {
            "text": "\tgetNodeContent,",
            "lineNumber": 10
          },
          {
            "text": "\tgetNodeRole,",
            "lineNumber": 11
          },
          {
            "text": "\tgetIncomingEdgesWithLabels,",
            "lineNumber": 12
          },
          {
            "text": "\tgetParentIdsSortedByY,",
            "lineNumber": 13
          },
          {
            "text": "\tGREEN_NODE_PADDING,",
            "lineNumber": 14
          },
          {
            "text": "\tisAuxiliaryEdge,",
            "lineNumber": 15
          },
          {
            "text": "\tloadCanvasData,",
            "lineNumber": 16
          },
          {
            "text": "\tsaveCanvasData,",
            "lineNumber": 17
          },
          {
            "text": "} from \"../canvas/nodes\";",
            "lineNumber": 18
          },
          {
            "text": "import type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";",
            "lineNumber": 19
          },
          {
            "text": "import { getTextNodeContent, parseEdgeVariableName } from \"../canvas/types\";",
            "lineNumber": 20
          },
          {
            "text": "import {isTextNode} from \"../canvas/types\";",
            "lineNumber": 21
          },
          {
            "text": "import type {LiveCanvas} from \"./canvasApi\";",
            "lineNumber": 22
          },
          {
            "text": "import {getKernelForCanvas} from \"./kernelManager\";",
            "lineNumber": 23
          },
          {
            "text": "import {ollamaGenerate} from \"./ollama\";",
            "lineNumber": 24
          },
          {
            "text": "import {",
            "lineNumber": 25
          },
          {
            "text": "\tgetCanvasKey,",
            "lineNumber": 26
          },
          {
            "text": "\tgetNodeResult,",
            "lineNumber": 27
          },
          {
            "text": "\tsetNodeResult,",
            "lineNumber": 28
          },
          {
            "text": "\tsetEdgeModes,",
            "lineNumber": 29
          },
          {
            "text": "\tsetRunningNodeId,",
            "lineNumber": 30
          },
          {
            "text": "} from \"./state\";",
            "lineNumber": 31
          },
          {
            "text": "import {DEFAULT_SETTINGS, shadeColor, type NodeRole, type ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "type EdgeInputMode = \"inject\" | \"concatenate\";",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "lineNumber": 35
          },
          {
            "text": "/** True if the role is non-AI (Python or text pass-through); prefer running these first for early output. */",
            "lineNumber": 36
          }
        ]
      },
      "score": 0.2909756898880005
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 457
          },
          "endPosition": {
            "line": 666,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\n\tif (outId) {\n\t\tresolvedOutputId = outId;\n\t\tconst outNode = getNodeById(data, outId);\n\t\tif (outNode &amp;&amp; isTextNode(outNode)) {\n\t\t\tconst existingX = (outNode as CanvasTextData).x;\n\t\t\tconst existingY = (outNode as CanvasTextData).y;\n\t\t\tconst updated = {\n\t\t\t\t...(outNode as CanvasTextData),\n\t\t\t\ttext,\n\t\t\t\tx: existingX,\n\t\t\t\ty: existingY,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t};\n\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);\n\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t}\n\t\tconst hasOutputEdge = data.edges.some(\n\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t\t);\n\t\tif (!hasOutputEdge) {\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: outId,\n\t\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tconst newNodeId = randomId();\n\t\tresolvedOutputId = newNodeId;\n\t\tconst newTextNode: CanvasTextData = {\n\t\t\tid: newNodeId,\n\t\t\ttype: \"text\",\n\t\t\ttext,\n\t\t\tx: chosenX,\n\t\t\ty: chosenY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tcolor: greenColor,\n\t\t};\n\t\tdata.nodes.push(newTextNode);\n\t\tdata.edges.push({\n\t\t\tid: randomId(),\n\t\t\tfromNode: sourceNode.id,\n\t\t\ttoNode: newNodeId,\n\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t});\n\t}\n\n\tconst outputNode = getNodeById(data, resolvedOutputId);\n\tconst outputY = outputNode &amp;&amp; \"y\" in outputNode ? (outputNode as { y: number }).y : chosenY;\n\n\t// 2. Ensure thinking node (above output) when setting on and thinking present\n\tif (settings.showThinkingNode &amp;&amp; thinking != null &amp;&amp; thinking.length &gt; 0) {\n\t\tconst thinkingDefaultY = outputY - height - GREEN_NODE_PADDING;\n\t\tconst thinkingExclude = [sourceNode.id, resolvedOutputId, promptId].filter((id): id is string =&gt; id != null);\n\t\tconst { x: tx, y: ty } = chooseOutputPositionXY(\n\t\t\tdata,\n\t\t\tsourceNode.id,\n\t\t\tthinkingId,\n\t\t\tdefaultX,\n\t\t\tthinkingDefaultY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tthinkingExclude\n\t\t);\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 458,
                "column": 1
              },
              "endPosition": {
                "line": 465,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 460,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 461,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 463,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 464,
            "isSignature": true
          },
          {
            "lineNumber": 489
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 490
          },
          {
            "text": "\t\tresolvedOutputId = outId;",
            "lineNumber": 491
          },
          {
            "text": "\t\tconst outNode = getNodeById(data, outId);",
            "lineNumber": 492
          },
          {
            "text": "\t\tif (outNode &amp;&amp; isTextNode(outNode)) {",
            "lineNumber": 493
          },
          {
            "text": "\t\t\tconst existingX = (outNode as CanvasTextData).x;",
            "lineNumber": 494
          },
          {
            "text": "\t\t\tconst existingY = (outNode as CanvasTextData).y;",
            "lineNumber": 495
          },
          {
            "text": "\t\t\tconst updated = {",
            "lineNumber": 496
          },
          {
            "text": "\t\t\t\t...(outNode as CanvasTextData),",
            "lineNumber": 497
          },
          {
            "text": "\t\t\t\ttext,",
            "lineNumber": 498
          },
          {
            "text": "\t\t\t\tx: existingX,",
            "lineNumber": 499
          },
          {
            "text": "\t\t\t\ty: existingY,",
            "lineNumber": 500
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 501
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 502
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 503
          },
          {
            "text": "\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);",
            "lineNumber": 504
          },
          {
            "text": "\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 505
          },
          {
            "text": "\t\t}",
            "lineNumber": 506
          },
          {
            "text": "\t\tconst hasOutputEdge = data.edges.some(",
            "lineNumber": 507
          },
          {
            "text": "\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 508
          },
          {
            "text": "\t\t);",
            "lineNumber": 509
          },
          {
            "text": "\t\tif (!hasOutputEdge) {",
            "lineNumber": 510
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 511
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 512
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 513
          },
          {
            "text": "\t\t\t\ttoNode: outId,",
            "lineNumber": 514
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 515
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 516
          },
          {
            "text": "\t\t}",
            "lineNumber": 517
          },
          {
            "text": "\t} else {",
            "lineNumber": 518
          },
          {
            "text": "\t\tconst newNodeId = randomId();",
            "lineNumber": 519
          },
          {
            "text": "\t\tresolvedOutputId = newNodeId;",
            "lineNumber": 520
          },
          {
            "text": "\t\tconst newTextNode: CanvasTextData = {",
            "lineNumber": 521
          },
          {
            "text": "\t\t\tid: newNodeId,",
            "lineNumber": 522
          },
          {
            "text": "\t\t\ttype: \"text\",",
            "lineNumber": 523
          },
          {
            "text": "\t\t\ttext,",
            "lineNumber": 524
          },
          {
            "text": "\t\t\tx: chosenX,",
            "lineNumber": 525
          },
          {
            "text": "\t\t\ty: chosenY,",
            "lineNumber": 526
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 527
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 528
          },
          {
            "text": "\t\t\tcolor: greenColor,",
            "lineNumber": 529
          },
          {
            "text": "\t\t};",
            "lineNumber": 530
          },
          {
            "text": "\t\tdata.nodes.push(newTextNode);",
            "lineNumber": 531
          },
          {
            "text": "\t\tdata.edges.push({",
            "lineNumber": 532
          },
          {
            "text": "\t\t\tid: randomId(),",
            "lineNumber": 533
          },
          {
            "text": "\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 534
          },
          {
            "text": "\t\t\ttoNode: newNodeId,",
            "lineNumber": 535
          },
          {
            "text": "\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 536
          },
          {
            "text": "\t\t});",
            "lineNumber": 537
          },
          {
            "text": "\t}",
            "lineNumber": 538
          },
          {
            "lineNumber": 539
          },
          {
            "text": "\tconst outputNode = getNodeById(data, resolvedOutputId);",
            "lineNumber": 540
          },
          {
            "text": "\tconst outputY = outputNode &amp;&amp; \"y\" in outputNode ? (outputNode as { y: number }).y : chosenY;",
            "lineNumber": 541
          },
          {
            "lineNumber": 542
          },
          {
            "text": "\t// 2. Ensure thinking node (above output) when setting on and thinking present",
            "lineNumber": 543
          },
          {
            "text": "\tif (settings.showThinkingNode &amp;&amp; thinking != null &amp;&amp; thinking.length &gt; 0) {",
            "lineNumber": 544
          },
          {
            "text": "\t\tconst thinkingDefaultY = outputY - height - GREEN_NODE_PADDING;",
            "lineNumber": 545
          },
          {
            "text": "\t\tconst thinkingExclude = [sourceNode.id, resolvedOutputId, promptId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 546
          },
          {
            "text": "\t\tconst { x: tx, y: ty } = chooseOutputPositionXY(",
            "lineNumber": 547
          },
          {
            "text": "\t\t\tdata,",
            "lineNumber": 548
          },
          {
            "text": "\t\t\tsourceNode.id,",
            "lineNumber": 549
          },
          {
            "text": "\t\t\tthinkingId,",
            "lineNumber": 550
          },
          {
            "text": "\t\t\tdefaultX,",
            "lineNumber": 551
          },
          {
            "text": "\t\t\tthinkingDefaultY,",
            "lineNumber": 552
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 553
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 554
          },
          {
            "text": "\t\t\tthinkingExclude",
            "lineNumber": 555
          },
          {
            "text": "\t\t);",
            "lineNumber": 556
          },
          {
            "text": "}",
            "lineNumber": 667,
            "isSignature": true
          }
        ]
      },
      "score": 0.2697211503982544
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/views/ZettelControlsView.ts",
        "range": {
          "startPosition": {
            "line": 25
          },
          "endPosition": {
            "line": 215,
            "column": 1
          }
        },
        "contents": "export class ZettelControlsView extends ItemView {\nasync onOpen(): Promise&lt;void&gt; {\n\n\t\tconst guideDetails = el.createEl(\"details\", { cls: \"ztb-guide-details\" });\n\t\tguideDetails.createEl(\"summary\", { cls: \"ztb-guide-summary\", text: \"How to use the canvas\" });\n\t\tconst guideList = guideDetails.createEl(\"ul\", { cls: \"ztb-guide-list\" });\n\t\tconst tips = [\n\t\t\t\"Each color is a different way to work with text: one color might ask an AI a question, another might run a short Python snippet, and the green card is where the result shows up.\",\n\t\t\t\"Text (yellow) nodes are input pass-through: their content is sent to the next node. Uncolored or unused-color cards are not connected and do not add to any prompt.\",\n\t\t\t\"An arrow from one card to another sends its text as input. You can change how it's combined by clicking the arrow's label.\",\n\t\t\t\"Right-click a card and choose Run node to run just that card, or Run chain to run it and every card that feeds into it.\",\n\t\t\t\"The green card is where answers and results appear. It gets created or updated when you run an AI or Python card.\",\n\t\t\t\"You can plug text from one card into another by using {{var:name}} in the card text and giving the edge that variable name as its label.\",\n\t\t\t\"Python (blue) cards are auto-wrapped in a code block so # comments render as comments; the plugin adds the fence when you run the node if needed.\",\n\t\t\t\"Use the command \\\"Create tutorial canvas\\\" for a full showcase: every node type, concat vs variable injection, Run buttons, and this sidebar.\",\n\t\t];\n\t\tfor (const tip of tips) {\n\t\t\tconst li = guideList.createEl(\"li\");\n\t\t\tli.setText(tip);\n\t\t}\n\t}\n\n\tasync onClose(): Promise&lt;void&gt; {\n\t\tthis.containerEl.removeClass(\"ztb-controls-view\");\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 26,
                "column": 1
              },
              "endPosition": {
                "line": 26,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 26,
                "column": 8
              },
              "endPosition": {
                "line": 27,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 43,
                "column": 2
              },
              "endPosition": {
                "line": 44,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export class ZettelControlsView extends ItemView {",
            "lineNumber": 26,
            "isSignature": true
          },
          {
            "text": "async onOpen(): Promise&lt;void&gt; {",
            "lineNumber": 43
          },
          {
            "lineNumber": 192
          },
          {
            "text": "\t\tconst guideDetails = el.createEl(\"details\", { cls: \"ztb-guide-details\" });",
            "lineNumber": 193
          },
          {
            "text": "\t\tguideDetails.createEl(\"summary\", { cls: \"ztb-guide-summary\", text: \"How to use the canvas\" });",
            "lineNumber": 194
          },
          {
            "text": "\t\tconst guideList = guideDetails.createEl(\"ul\", { cls: \"ztb-guide-list\" });",
            "lineNumber": 195
          },
          {
            "text": "\t\tconst tips = [",
            "lineNumber": 196
          },
          {
            "text": "\t\t\t\"Each color is a different way to work with text: one color might ask an AI a question, another might run a short Python snippet, and the green card is where the result shows up.\",",
            "lineNumber": 197
          },
          {
            "text": "\t\t\t\"Text (yellow) nodes are input pass-through: their content is sent to the next node. Uncolored or unused-color cards are not connected and do not add to any prompt.\",",
            "lineNumber": 198
          },
          {
            "text": "\t\t\t\"An arrow from one card to another sends its text as input. You can change how it's combined by clicking the arrow's label.\",",
            "lineNumber": 199
          },
          {
            "text": "\t\t\t\"Right-click a card and choose Run node to run just that card, or Run chain to run it and every card that feeds into it.\",",
            "lineNumber": 200
          },
          {
            "text": "\t\t\t\"The green card is where answers and results appear. It gets created or updated when you run an AI or Python card.\",",
            "lineNumber": 201
          },
          {
            "text": "\t\t\t\"You can plug text from one card into another by using {{var:name}} in the card text and giving the edge that variable name as its label.\",",
            "lineNumber": 202
          },
          {
            "text": "\t\t\t\"Python (blue) cards are auto-wrapped in a code block so # comments render as comments; the plugin adds the fence when you run the node if needed.\",",
            "lineNumber": 203
          },
          {
            "text": "\t\t\t\"Use the command \\\"Create tutorial canvas\\\" for a full showcase: every node type, concat vs variable injection, Run buttons, and this sidebar.\",",
            "lineNumber": 204
          },
          {
            "text": "\t\t];",
            "lineNumber": 205
          },
          {
            "text": "\t\tfor (const tip of tips) {",
            "lineNumber": 206
          },
          {
            "text": "\t\t\tconst li = guideList.createEl(\"li\");",
            "lineNumber": 207
          },
          {
            "text": "\t\t\tli.setText(tip);",
            "lineNumber": 208
          },
          {
            "text": "\t\t}",
            "lineNumber": 209
          },
          {
            "text": "\t}",
            "lineNumber": 210
          },
          {
            "lineNumber": 211
          },
          {
            "text": "\tasync onClose(): Promise&lt;void&gt; {",
            "lineNumber": 212
          },
          {
            "text": "\t\tthis.containerEl.removeClass(\"ztb-controls-view\");",
            "lineNumber": 213
          },
          {
            "text": "\t}",
            "lineNumber": 215
          },
          {
            "text": "}",
            "lineNumber": 216,
            "isSignature": true
          }
        ]
      },
      "score": 0.26889705657958984
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 267
          },
          "endPosition": {
            "line": 369,
            "column": 1
          }
        },
        "contents": "async function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n\t\tconst temperature = settings.ollamaOrangeTemperature ?? DEFAULT_SETTINGS.ollamaOrangeTemperature;\n\t\tconst result = await ollamaGenerate({\n\t\t\tmodel,\n\t\t\tprompt: fullPrompt,\n\t\t\tstream: false,\n\t\t\toptions: { temperature },\n\t\t});\n\t\tsetNodeResult(canvasKey, nodeId, result.response);\n\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {\n\t\t\tfullPrompt,\n\t\t\tthinking: result.thinking,\n\t\t});\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result.response;\n\t}\n\tif (role === \"purple\") {\n\t\tconst model = settings.ollamaPurpleModel || \"llama2\";\n\t\tconst temperature = settings.ollamaPurpleTemperature ?? DEFAULT_SETTINGS.ollamaPurpleTemperature;\n\t\tconst result = await ollamaGenerate({\n\t\t\tmodel,\n\t\t\tprompt: fullPrompt,\n\t\t\tstream: false,\n\t\t\toptions: { temperature },\n\t\t});\n\t\tsetNodeResult(canvasKey, nodeId, result.response);\n\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {\n\t\t\tfullPrompt,\n\t\t\tthinking: result.thinking,\n\t\t});\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result.response;\n\t}\n\tif (role === \"red\") {\n\t\tconst model = settings.ollamaRedModel || \"llama2\";\n\t\tconst temperature = settings.ollamaRedTemperature ?? DEFAULT_SETTINGS.ollamaRedTemperature;\n\t\tconst result = await ollamaGenerate({\n\t\t\tmodel,\n\t\t\tprompt: fullPrompt,\n\t\t\tstream: false,\n\t\t\toptions: { temperature },\n\t\t});\n\t\tsetNodeResult(canvasKey, nodeId, result.response);\n\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {\n\t\t\tfullPrompt,\n\t\t\tthinking: result.thinking,\n\t\t});\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result.response;\n\t}\n\tif (role === \"blue\") {\n\t\tconst kernel = getKernelForCanvas;\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 268,
                "column": 1
              },
              "endPosition": {
                "line": 277,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "async function runSingleNode(",
            "lineNumber": 268,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 269,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 270,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 271,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 272,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 273,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 274,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 275,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 276,
            "isSignature": true
          },
          {
            "lineNumber": 307
          },
          {
            "lineNumber": 308
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 309
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 310
          },
          {
            "text": "\t\tconst temperature = settings.ollamaOrangeTemperature ?? DEFAULT_SETTINGS.ollamaOrangeTemperature;",
            "lineNumber": 311
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({",
            "lineNumber": 312
          },
          {
            "text": "\t\t\tmodel,",
            "lineNumber": 313
          },
          {
            "text": "\t\t\tprompt: fullPrompt,",
            "lineNumber": 314
          },
          {
            "text": "\t\t\tstream: false,",
            "lineNumber": 315
          },
          {
            "text": "\t\t\toptions: { temperature },",
            "lineNumber": 316
          },
          {
            "text": "\t\t});",
            "lineNumber": 317
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result.response);",
            "lineNumber": 318
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {",
            "lineNumber": 319
          },
          {
            "text": "\t\t\tfullPrompt,",
            "lineNumber": 320
          },
          {
            "text": "\t\t\tthinking: result.thinking,",
            "lineNumber": 321
          },
          {
            "text": "\t\t});",
            "lineNumber": 322
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 323
          },
          {
            "text": "\t\treturn result.response;",
            "lineNumber": 324
          },
          {
            "text": "\t}",
            "lineNumber": 325
          },
          {
            "text": "\tif (role === \"purple\") {",
            "lineNumber": 326
          },
          {
            "text": "\t\tconst model = settings.ollamaPurpleModel || \"llama2\";",
            "lineNumber": 327
          },
          {
            "text": "\t\tconst temperature = settings.ollamaPurpleTemperature ?? DEFAULT_SETTINGS.ollamaPurpleTemperature;",
            "lineNumber": 328
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({",
            "lineNumber": 329
          },
          {
            "text": "\t\t\tmodel,",
            "lineNumber": 330
          },
          {
            "text": "\t\t\tprompt: fullPrompt,",
            "lineNumber": 331
          },
          {
            "text": "\t\t\tstream: false,",
            "lineNumber": 332
          },
          {
            "text": "\t\t\toptions: { temperature },",
            "lineNumber": 333
          },
          {
            "text": "\t\t});",
            "lineNumber": 334
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result.response);",
            "lineNumber": 335
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {",
            "lineNumber": 336
          },
          {
            "text": "\t\t\tfullPrompt,",
            "lineNumber": 337
          },
          {
            "text": "\t\t\tthinking: result.thinking,",
            "lineNumber": 338
          },
          {
            "text": "\t\t});",
            "lineNumber": 339
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 340
          },
          {
            "text": "\t\treturn result.response;",
            "lineNumber": 341
          },
          {
            "text": "\t}",
            "lineNumber": 342
          },
          {
            "text": "\tif (role === \"red\") {",
            "lineNumber": 343
          },
          {
            "text": "\t\tconst model = settings.ollamaRedModel || \"llama2\";",
            "lineNumber": 344
          },
          {
            "text": "\t\tconst temperature = settings.ollamaRedTemperature ?? DEFAULT_SETTINGS.ollamaRedTemperature;",
            "lineNumber": 345
          },
          {
            "text": "\t\tconst result = await ollamaGenerate({",
            "lineNumber": 346
          },
          {
            "text": "\t\t\tmodel,",
            "lineNumber": 347
          },
          {
            "text": "\t\t\tprompt: fullPrompt,",
            "lineNumber": 348
          },
          {
            "text": "\t\t\tstream: false,",
            "lineNumber": 349
          },
          {
            "text": "\t\t\toptions: { temperature },",
            "lineNumber": 350
          },
          {
            "text": "\t\t});",
            "lineNumber": 351
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result.response);",
            "lineNumber": 352
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result.response, settings, {",
            "lineNumber": 353
          },
          {
            "text": "\t\t\tfullPrompt,",
            "lineNumber": 354
          },
          {
            "text": "\t\t\tthinking: result.thinking,",
            "lineNumber": 355
          },
          {
            "text": "\t\t});",
            "lineNumber": 356
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 357
          },
          {
            "text": "\t\treturn result.response;",
            "lineNumber": 358
          },
          {
            "text": "\t}",
            "lineNumber": 359
          },
          {
            "text": "\tif (role === \"blue\") {",
            "lineNumber": 360
          },
          {
            "text": "\t\tconst kernel = getKernelForCanvas;",
            "lineNumber": 361
          },
          {
            "text": "}",
            "lineNumber": 370,
            "isSignature": true
          }
        ]
      },
      "score": 0.265122652053833
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 454,
            "column": 1
          },
          "endPosition": {
            "line": 666,
            "column": 1
          }
        },
        "contents": "/** Create or replace the Green output node (and optional prompt/thinking nodes) and ensure edges from source. Mutates data only. */\nfunction ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\tconst { fullPrompt, thinking } = options;\n\tconst promptId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_PROMPT);\n\tconst thinkingId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING);\n\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);\n\n\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;\n\tconst width = Math.max(320, sourceNode.width);\n\tconst height = 180;\n\tconst defaultX = sourceNode.x;\n\tconst extraExclude = [promptId, thinkingId].filter((id): id is string =&gt; id != null);\n\n\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(\n\t\tdata,\n\t\tsourceNode.id,\n\t\toutId,\n\t\tdefaultX,\n\t\tdefaultY,\n\t\twidth,\n\t\theight,\n\t\textraExclude\n\t);\n\tconst greenColor = settings.colorGreen;\n\n\t// 1. Ensure output node\n\tlet resolvedOutputId: string;\n\tif (outId) {\n\t\tresolvedOutputId = outId;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Create or replace the Green output node (and optional prompt/thinking nodes) and ensure edges from source. Mutates data only. */",
            "lineNumber": 457
          },
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 460,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 461,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 463,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 464,
            "isSignature": true
          },
          {
            "text": "\tconst { fullPrompt, thinking } = options;",
            "lineNumber": 465
          },
          {
            "text": "\tconst promptId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_PROMPT);",
            "lineNumber": 466
          },
          {
            "text": "\tconst thinkingId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING);",
            "lineNumber": 467
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);",
            "lineNumber": 468
          },
          {
            "lineNumber": 469
          },
          {
            "text": "\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;",
            "lineNumber": 470
          },
          {
            "text": "\tconst width = Math.max(320, sourceNode.width);",
            "lineNumber": 471
          },
          {
            "text": "\tconst height = 180;",
            "lineNumber": 472
          },
          {
            "text": "\tconst defaultX = sourceNode.x;",
            "lineNumber": 473
          },
          {
            "text": "\tconst extraExclude = [promptId, thinkingId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 474
          },
          {
            "lineNumber": 475
          },
          {
            "text": "\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(",
            "lineNumber": 476
          },
          {
            "text": "\t\tdata,",
            "lineNumber": 477
          },
          {
            "text": "\t\tsourceNode.id,",
            "lineNumber": 478
          },
          {
            "text": "\t\toutId,",
            "lineNumber": 479
          },
          {
            "text": "\t\tdefaultX,",
            "lineNumber": 480
          },
          {
            "text": "\t\tdefaultY,",
            "lineNumber": 481
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 482
          },
          {
            "text": "\t\theight,",
            "lineNumber": 483
          },
          {
            "text": "\t\textraExclude",
            "lineNumber": 484
          },
          {
            "text": "\t);",
            "lineNumber": 485
          },
          {
            "text": "\tconst greenColor = settings.colorGreen;",
            "lineNumber": 486
          },
          {
            "lineNumber": 487
          },
          {
            "text": "\t// 1. Ensure output node",
            "lineNumber": 488
          },
          {
            "text": "\tlet resolvedOutputId: string;",
            "lineNumber": 489
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 490
          },
          {
            "text": "\t\tresolvedOutputId = outId;",
            "lineNumber": 491
          },
          {
            "text": "}",
            "lineNumber": 667,
            "isSignature": true
          }
        ]
      },
      "score": 0.25853851437568665
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 669
          },
          "endPosition": {
            "line": 729,
            "column": 1
          }
        },
        "contents": "export async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };\n\tconst parentIds = getParentIdsSortedByY(nodeId, data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tfor (const pid of parentIds) {\n\t\tif (getNodeResult(canvasKey, pid) == null) {\n\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);\n\t\t}\n\t}\n\ttry {\n\t\tsetRunningNodeId(canvasKey, nodeId);\n\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t} finally {\n\t\tsetRunningNodeId(canvasKey, null);\n\t}\n}\n\nconst CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";\n\n/** Run all nodes reachable from any root, in topological order. */\nexport async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst topo = topologicalOrderFull(data, settings);\n\tif (\"cycle\" in topo) return { ok: false, message: CYCLE_ERROR_MESSAGE };\n\tconst order = topo.order;\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export async function runNode(",
            "lineNumber": 670,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 671,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 672,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 673,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 674,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 675,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 676,
            "isSignature": true
          },
          {
            "lineNumber": 680
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 681
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 682
          },
          {
            "text": "\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };",
            "lineNumber": 683
          },
          {
            "text": "\tconst parentIds = getParentIdsSortedByY(nodeId, data);",
            "lineNumber": 684
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 685
          },
          {
            "text": "\tfor (const pid of parentIds) {",
            "lineNumber": 686
          },
          {
            "text": "\t\tif (getNodeResult(canvasKey, pid) == null) {",
            "lineNumber": 687
          },
          {
            "text": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);",
            "lineNumber": 688
          },
          {
            "text": "\t\t}",
            "lineNumber": 689
          },
          {
            "text": "\t}",
            "lineNumber": 690
          },
          {
            "text": "\ttry {",
            "lineNumber": 691
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, nodeId);",
            "lineNumber": 692
          },
          {
            "text": "\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);",
            "lineNumber": 693
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 694
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 695
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 696
          },
          {
            "text": "\t} finally {",
            "lineNumber": 697
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 698
          },
          {
            "text": "\t}",
            "lineNumber": 699
          },
          {
            "text": "}",
            "lineNumber": 700,
            "isSignature": true
          },
          {
            "lineNumber": 701
          },
          {
            "text": "const CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";",
            "lineNumber": 702
          },
          {
            "lineNumber": 703
          },
          {
            "text": "/** Run all nodes reachable from any root, in topological order. */",
            "lineNumber": 704
          },
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 705,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 706,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 707,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 708,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 709,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 710,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 711
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 712
          },
          {
            "text": "\tconst topo = topologicalOrderFull(data, settings);",
            "lineNumber": 713
          },
          {
            "text": "\tif (\"cycle\" in topo) return { ok: false, message: CYCLE_ERROR_MESSAGE };",
            "lineNumber": 714
          },
          {
            "text": "\tconst order = topo.order;",
            "lineNumber": 715
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 716
          },
          {
            "text": "}",
            "lineNumber": 730,
            "isSignature": true
          }
        ]
      },
      "score": 0.2581140995025635
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 115
          },
          "endPosition": {
            "line": 127,
            "column": 1
          }
        },
        "contents": "export function isFileNode(node: AllCanvasNodeData): node is CanvasFileData {\n\n}\n\n/** Get raw text content from a text node. */\nexport function getTextNodeContent(node: CanvasTextData): string {\n\treturn node.text ?? \"\";\n}\n\n/** Get file path from a file node (relative to vault). */\nexport function getFileNodePath(node: CanvasFileData): string {\n\treturn node.file ?? \"\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export function isFileNode(node: AllCanvasNodeData): node is CanvasFileData {",
            "lineNumber": 116,
            "isSignature": true
          },
          {
            "lineNumber": 117
          },
          {
            "text": "}",
            "lineNumber": 118,
            "isSignature": true
          },
          {
            "lineNumber": 119
          },
          {
            "text": "/** Get raw text content from a text node. */",
            "lineNumber": 120
          },
          {
            "text": "export function getTextNodeContent(node: CanvasTextData): string {",
            "lineNumber": 121,
            "isSignature": true
          },
          {
            "text": "\treturn node.text ?? \"\";",
            "lineNumber": 122
          },
          {
            "text": "}",
            "lineNumber": 123,
            "isSignature": true
          },
          {
            "lineNumber": 124
          },
          {
            "text": "/** Get file path from a file node (relative to vault). */",
            "lineNumber": 125
          },
          {
            "text": "export function getFileNodePath(node: CanvasFileData): string {",
            "lineNumber": 126,
            "isSignature": true
          },
          {
            "text": "\treturn node.file ?? \"\";",
            "lineNumber": 127
          },
          {
            "text": "}",
            "lineNumber": 128,
            "isSignature": true
          }
        ]
      },
      "score": 0.25556549429893494
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/state.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 25,
            "column": 1
          }
        },
        "contents": "/** Per-canvas state: NodeID -&gt; last output result string. */\nconst canvasState = new Map&lt;string, Map&lt;string, string&gt;&gt;();\n\n/** Per-canvas edge mode: EdgeID -&gt; \"inject\" | \"concatenate\" (shown in floating label under edge). */\nconst edgeModeState = new Map&lt;string, Map&lt;string, \"inject\" | \"concatenate\"&gt;&gt;();\n\n/** Node currently running (waiting for AI/kernel) per canvas; used to show \"running\" on incoming edges. */\nconst runningNodeState = new Map&lt;string, string | null&gt;();\n\nfunction getCanvasState(canvasKey: string): Map&lt;string, string&gt; {\n\tlet map = canvasState.get(canvasKey);\n\tif (!map) {\n\t\tmap = new Map();\n\t\tcanvasState.set(canvasKey, map);\n\t}\n\treturn map;\n}\n\nfunction getEdgeModeState(canvasKey: string): Map&lt;string, \"inject\" | \"concatenate\"&gt; {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Per-canvas state: NodeID -&gt; last output result string. */",
            "lineNumber": 1
          },
          {
            "text": "const canvasState = new Map&lt;string, Map&lt;string, string&gt;&gt;();",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "/** Per-canvas edge mode: EdgeID -&gt; \"inject\" | \"concatenate\" (shown in floating label under edge). */",
            "lineNumber": 4
          },
          {
            "text": "const edgeModeState = new Map&lt;string, Map&lt;string, \"inject\" | \"concatenate\"&gt;&gt;();",
            "lineNumber": 5
          },
          {
            "lineNumber": 6
          },
          {
            "text": "/** Node currently running (waiting for AI/kernel) per canvas; used to show \"running\" on incoming edges. */",
            "lineNumber": 7
          },
          {
            "text": "const runningNodeState = new Map&lt;string, string | null&gt;();",
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "function getCanvasState(canvasKey: string): Map&lt;string, string&gt; {",
            "lineNumber": 10,
            "isSignature": true
          },
          {
            "text": "\tlet map = canvasState.get(canvasKey);",
            "lineNumber": 11
          },
          {
            "text": "\tif (!map) {",
            "lineNumber": 12
          },
          {
            "text": "\t\tmap = new Map();",
            "lineNumber": 13
          },
          {
            "text": "\t\tcanvasState.set(canvasKey, map);",
            "lineNumber": 14
          },
          {
            "text": "\t}",
            "lineNumber": 15
          },
          {
            "text": "\treturn map;",
            "lineNumber": 16
          },
          {
            "text": "}",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "lineNumber": 18
          },
          {
            "text": "function getEdgeModeState(canvasKey: string): Map&lt;string, \"inject\" | \"concatenate\"&gt; {",
            "lineNumber": 19,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 20
          },
          {
            "text": "}",
            "lineNumber": 26,
            "isSignature": true
          }
        ]
      },
      "score": 0.25383150577545166
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 97
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\nconst nodes: CanvasData[\"nodes\"] = [\n TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 3\n\t\tn(lab3, \"Concatenation: no edge label → parent output appended before your prompt (then \\\"---\\\", then this card).\", commentLeftX(col3), concatCommentY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),\n\t\tn(concatComment, \"I'm input text. My full text is added to the next node's prompt.\", laneNodeX(col3, 0), concatCommentY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(concatOrange, \"Reply in one word: what did the previous card say?\", laneNodeX(col3, LANE_OFFSET), concatOrangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(concatOut, \"\", laneNodeX(col3, 0), concatOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 4\n\t\tn(lab4, \"Variable injection: put a name on the edge and use {{var:name}} in the prompt; that parent is injected there.\", commentLeftX(col4), injectFirstY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),\n\t\tn(injectFirst, \"Say exactly: Hello world.\", laneNodeX(col4, 0), injectFirstY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(injectSecond, \"They said: {{var:reply}}. Confirm in 2 words.\", laneNodeX(col4, LANE_OFFSET), injectSecondY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(injectOut, \"\", laneNodeX(col4, 0), injectOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 5 &amp; 6: plain text labels only\n\t\tn(lab5, \"How to run: Right-click a node → Run node or Run chain. Right-click empty canvas → Run entire canvas or Dismiss all output. Title bar: ▶ Run entire canvas, 🗑 Dismiss all. Commands: Open Zettel Controls; Create tutorial canvas.\", commentLeftX(col5), y5, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 195),\n\t\tn(lab6, \"Sidebar: Open Zettel Controls. There: pick Ollama models and Temperature; restart Python kernel; env vars; Console (obsidian_log in Python cards).\", commentLeftX(col6), y6, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 145),\n\t];\n\n\tconst edges: CanvasData[\"edges\"] = [\n\t\te(\"e-orange-out\", orangeNode, orangeOut, EDGE_LABEL_OUTPUT)\n,\n\t];\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 98,
                "column": 1
              },
              "endPosition": {
                "line": 99,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 259,
                "column": 2
              },
              "endPosition": {
                "line": 259,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 259,
                "column": 8
              },
              "endPosition": {
                "line": 260,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "text": "const nodes: CanvasData[\"nodes\"] = [",
            "lineNumber": 259
          },
          {
            "text": " TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 283
          },
          {
            "text": "\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 284
          },
          {
            "lineNumber": 285
          },
          {
            "text": "\t\t// Column 3",
            "lineNumber": 286
          },
          {
            "text": "\t\tn(lab3, \"Concatenation: no edge label → parent output appended before your prompt (then \\\"---\\\", then this card).\", commentLeftX(col3), concatCommentY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),",
            "lineNumber": 287
          },
          {
            "text": "\t\tn(concatComment, \"I'm input text. My full text is added to the next node's prompt.\", laneNodeX(col3, 0), concatCommentY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 288
          },
          {
            "text": "\t\tn(concatOrange, \"Reply in one word: what did the previous card say?\", laneNodeX(col3, LANE_OFFSET), concatOrangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 289
          },
          {
            "text": "\t\tn(concatOut, \"\", laneNodeX(col3, 0), concatOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 290
          },
          {
            "lineNumber": 291
          },
          {
            "text": "\t\t// Column 4",
            "lineNumber": 292
          },
          {
            "text": "\t\tn(lab4, \"Variable injection: put a name on the edge and use {{var:name}} in the prompt; that parent is injected there.\", commentLeftX(col4), injectFirstY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),",
            "lineNumber": 293
          },
          {
            "text": "\t\tn(injectFirst, \"Say exactly: Hello world.\", laneNodeX(col4, 0), injectFirstY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 294
          },
          {
            "text": "\t\tn(injectSecond, \"They said: {{var:reply}}. Confirm in 2 words.\", laneNodeX(col4, LANE_OFFSET), injectSecondY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 295
          },
          {
            "text": "\t\tn(injectOut, \"\", laneNodeX(col4, 0), injectOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 296
          },
          {
            "lineNumber": 297
          },
          {
            "text": "\t\t// Column 5 &amp; 6: plain text labels only",
            "lineNumber": 298
          },
          {
            "text": "\t\tn(lab5, \"How to run: Right-click a node → Run node or Run chain. Right-click empty canvas → Run entire canvas or Dismiss all output. Title bar: ▶ Run entire canvas, 🗑 Dismiss all. Commands: Open Zettel Controls; Create tutorial canvas.\", commentLeftX(col5), y5, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 195),",
            "lineNumber": 299
          },
          {
            "text": "\t\tn(lab6, \"Sidebar: Open Zettel Controls. There: pick Ollama models and Temperature; restart Python kernel; env vars; Console (obsidian_log in Python cards).\", commentLeftX(col6), y6, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 145),",
            "lineNumber": 300
          },
          {
            "text": "\t];",
            "lineNumber": 301
          },
          {
            "lineNumber": 302
          },
          {
            "text": "\tconst edges: CanvasData[\"edges\"] = [",
            "lineNumber": 303
          },
          {
            "text": "\t\te(\"e-orange-out\", orangeNode, orangeOut, EDGE_LABEL_OUTPUT)",
            "lineNumber": 304
          },
          {
            "text": ",",
            "lineNumber": 310
          },
          {
            "text": "\t];",
            "lineNumber": 311
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.25187090039253235
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 267
          },
          "endPosition": {
            "line": 371,
            "column": 99
          }
        },
        "contents": "async function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\n\tif (role === \"blue\") {\n\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);\n\t\tconst code = stripPythonCodeFence(template);\n\t\tconst result = await kernel.run(code, concatenatedPart);\n\t\tsetNodeResult(canvasKey, nodeId, result);\n\t\tensureOutputNodeAndEdge(data, node, result, settings);\n\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);\n\t\treturn result;\n\t}\n\treturn \"\";\n}\n\n/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 268,
                "column": 1
              },
              "endPosition": {
                "line": 277,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "async function runSingleNode(",
            "lineNumber": 268,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 269,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 270,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 271,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 272,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 273,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 274,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 275,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 276,
            "isSignature": true
          },
          {
            "lineNumber": 359
          },
          {
            "text": "\tif (role === \"blue\") {",
            "lineNumber": 360
          },
          {
            "text": "\t\tconst kernel = getKernelForCanvas(canvasKey, settings.pythonPath);",
            "lineNumber": 361
          },
          {
            "text": "\t\tconst code = stripPythonCodeFence(template);",
            "lineNumber": 362
          },
          {
            "text": "\t\tconst result = await kernel.run(code, concatenatedPart);",
            "lineNumber": 363
          },
          {
            "text": "\t\tsetNodeResult(canvasKey, nodeId, result);",
            "lineNumber": 364
          },
          {
            "text": "\t\tensureOutputNodeAndEdge(data, node, result, settings);",
            "lineNumber": 365
          },
          {
            "text": "\t\tawait updateEdgeLabelsAndSave(app.vault, canvasFilePath, data, nodeId, edgeModes, liveCanvas);",
            "lineNumber": 366
          },
          {
            "text": "\t\treturn result;",
            "lineNumber": 367
          },
          {
            "text": "\t}",
            "lineNumber": 368
          },
          {
            "text": "\treturn \"\";",
            "lineNumber": 369
          },
          {
            "text": "}",
            "lineNumber": 370,
            "isSignature": true
          },
          {
            "lineNumber": 371
          },
          {
            "text": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
            "lineNumber": 372
          }
        ]
      },
      "score": 0.2512739300727844
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/tutorials/example1Data.ts",
        "range": {
          "startPosition": {
            "column": 48
          },
          "endPosition": {
            "line": 61,
            "column": 1
          }
        },
        "contents": "/** Example 1: Basic Concatenation — Multiple inputs automatically combine. */\nexport function getExample1CanvasData(): CanvasData {\n\treturn {\n\t\tnodes: [\n\t\t\t{\n\t\t\t\tid: \"group-concat\",\n\t\t\t\ttype: \"group\",\n\t\t\t\tx: 30,\n\t\t\t\ty: 30,\n\t\t\t\twidth: 720,\n\t\t\t\theight: 520,\n\t\t\t\tlabel: \"Workflow 1: Concatenation (default)\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"yellow-observation\",\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: \"Observation: Users struggle to find related notes in large vaults.\",\n\t\t\t\tx: 50,\n\t\t\t\ty: 100,\n\t\t\t\twidth: 300,\n\t\t\t\theight: 80,\n\t\t\t\tcolor: \"3\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"yellow-constraint\",\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: \"Constraint: Must work without external plugins or APIs.\",\n\t\t\t\tx: 400,\n\t\t\t\ty: 100,\n\t\t\t\twidth: 300,\n\t\t\t\theight: 80,\n\t\t\t\tcolor: \"3\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"orange-5whys\",\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: \"Apply the 5 Whys framework to analyze the root cause of the problem described above.\",\n\t\t\t\tx: 200,\n\t\t\t\ty: 240,\n\t\t\t\twidth: 350,\n\t\t\t\theight: 120,\n\t\t\t\tcolor: \"1\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"note-concat-explanation\",\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: \"💡 How it works:\\n\\nBoth Yellow nodes are automatically CONCATENATED (joined with \\\\n\\\\n) before being passed to the Orange node.\\n\\nNo edge labels needed — this is the default behavior.\",\n\t\t\t\tx: 50,\n\t\t\t\ty: 400,\n\t\t\t\twidth: 650,\n\t\t\t\theight: 130,\n\t\t\t\tcolor: \"\",\n\t\t\t},\n\t\t],\n\t\tedges: [\n\t\t\t{ id: \"edge-obs-5whys\", fromNode: \"yellow-observation\", toNode: \"orange-5whys\" },\n\t\t\t{ id: \"edge-constraint-5whys\", fromNode: \"yellow-constraint\", toNode: \"orange-5whys\" },\n\t\t],\n\t};\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Example 1: Basic Concatenation — Multiple inputs automatically combine. */",
            "lineNumber": 3
          },
          {
            "text": "export function getExample1CanvasData(): CanvasData {",
            "lineNumber": 4,
            "isSignature": true
          },
          {
            "text": "\treturn {",
            "lineNumber": 5
          },
          {
            "text": "\t\tnodes: [",
            "lineNumber": 6
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 7
          },
          {
            "text": "\t\t\t\tid: \"group-concat\",",
            "lineNumber": 8
          },
          {
            "text": "\t\t\t\ttype: \"group\",",
            "lineNumber": 9
          },
          {
            "text": "\t\t\t\tx: 30,",
            "lineNumber": 10
          },
          {
            "text": "\t\t\t\ty: 30,",
            "lineNumber": 11
          },
          {
            "text": "\t\t\t\twidth: 720,",
            "lineNumber": 12
          },
          {
            "text": "\t\t\t\theight: 520,",
            "lineNumber": 13
          },
          {
            "text": "\t\t\t\tlabel: \"Workflow 1: Concatenation (default)\",",
            "lineNumber": 14
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 15
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 16
          },
          {
            "text": "\t\t\t\tid: \"yellow-observation\",",
            "lineNumber": 17
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 18
          },
          {
            "text": "\t\t\t\ttext: \"Observation: Users struggle to find related notes in large vaults.\",",
            "lineNumber": 19
          },
          {
            "text": "\t\t\t\tx: 50,",
            "lineNumber": 20
          },
          {
            "text": "\t\t\t\ty: 100,",
            "lineNumber": 21
          },
          {
            "text": "\t\t\t\twidth: 300,",
            "lineNumber": 22
          },
          {
            "text": "\t\t\t\theight: 80,",
            "lineNumber": 23
          },
          {
            "text": "\t\t\t\tcolor: \"3\",",
            "lineNumber": 24
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 25
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 26
          },
          {
            "text": "\t\t\t\tid: \"yellow-constraint\",",
            "lineNumber": 27
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 28
          },
          {
            "text": "\t\t\t\ttext: \"Constraint: Must work without external plugins or APIs.\",",
            "lineNumber": 29
          },
          {
            "text": "\t\t\t\tx: 400,",
            "lineNumber": 30
          },
          {
            "text": "\t\t\t\ty: 100,",
            "lineNumber": 31
          },
          {
            "text": "\t\t\t\twidth: 300,",
            "lineNumber": 32
          },
          {
            "text": "\t\t\t\theight: 80,",
            "lineNumber": 33
          },
          {
            "text": "\t\t\t\tcolor: \"3\",",
            "lineNumber": 34
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 35
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 36
          },
          {
            "text": "\t\t\t\tid: \"orange-5whys\",",
            "lineNumber": 37
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 38
          },
          {
            "text": "\t\t\t\ttext: \"Apply the 5 Whys framework to analyze the root cause of the problem described above.\",",
            "lineNumber": 39
          },
          {
            "text": "\t\t\t\tx: 200,",
            "lineNumber": 40
          },
          {
            "text": "\t\t\t\ty: 240,",
            "lineNumber": 41
          },
          {
            "text": "\t\t\t\twidth: 350,",
            "lineNumber": 42
          },
          {
            "text": "\t\t\t\theight: 120,",
            "lineNumber": 43
          },
          {
            "text": "\t\t\t\tcolor: \"1\",",
            "lineNumber": 44
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 45
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 46
          },
          {
            "text": "\t\t\t\tid: \"note-concat-explanation\",",
            "lineNumber": 47
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\ttext: \"💡 How it works:\\n\\nBoth Yellow nodes are automatically CONCATENATED (joined with \\\\n\\\\n) before being passed to the Orange node.\\n\\nNo edge labels needed — this is the default behavior.\",",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t\tx: 50,",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t\ty: 400,",
            "lineNumber": 51
          },
          {
            "text": "\t\t\t\twidth: 650,",
            "lineNumber": 52
          },
          {
            "text": "\t\t\t\theight: 130,",
            "lineNumber": 53
          },
          {
            "text": "\t\t\t\tcolor: \"\",",
            "lineNumber": 54
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 55
          },
          {
            "text": "\t\t],",
            "lineNumber": 56
          },
          {
            "text": "\t\tedges: [",
            "lineNumber": 57
          },
          {
            "text": "\t\t\t{ id: \"edge-obs-5whys\", fromNode: \"yellow-observation\", toNode: \"orange-5whys\" },",
            "lineNumber": 58
          },
          {
            "text": "\t\t\t{ id: \"edge-constraint-5whys\", fromNode: \"yellow-constraint\", toNode: \"orange-5whys\" },",
            "lineNumber": 59
          },
          {
            "text": "\t\t],",
            "lineNumber": 60
          },
          {
            "text": "\t};",
            "lineNumber": 61
          },
          {
            "text": "}",
            "lineNumber": 62,
            "isSignature": true
          }
        ]
      },
      "score": 0.24649196863174438
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 457
          },
          "endPosition": {
            "line": 666,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\nconst { x: tx, y: ty } = \n\n\t\t\twidth,\n\t\t\theight,\n\t\t\tthinkingExclude\n\t\t);\n\t\tconst thinkingColor = shadeColor(settings.colorGreen, 0.15);\n\n\t\tif (thinkingId) {\n\t\t\tconst tn = getNodeById(data, thinkingId);\n\t\t\tif (tn &amp;&amp; isTextNode(tn)) {\n\t\t\t\tconst updated = {\n\t\t\t\t\t...(tn as CanvasTextData),\n\t\t\t\t\ttext: thinking,\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\tcolor: thinkingColor,\n\t\t\t\t};\n\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === thinkingId);\n\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t\t}\n\t\t\tconst hasEdge = data.edges.some(\n\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === thinkingId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING\n\t\t\t);\n\t\t\tif (!hasEdge) {\n\t\t\t\tdata.edges.push({\n\t\t\t\t\tid: randomId(),\n\t\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\t\ttoNode: thinkingId,\n\t\t\t\t\tlabel: EDGE_LABEL_THINKING,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst newId = randomId();\n\t\t\tdata.nodes.push({\n\t\t\t\tid: newId,\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: thinking,\n\t\t\t\tx: tx,\n\t\t\t\ty: ty,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tcolor: thinkingColor,\n\t\t\t} as CanvasTextData);\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: newId,\n\t\t\t\tlabel: EDGE_LABEL_THINKING,\n\t\t\t});\n\t\t}\n\t}\n\n\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present\n\tif (settings.showPromptInOutput &amp;&amp; fullPrompt != null &amp;&amp; fullPrompt.length &gt; 0) {\n\t\tconst thinkingNodeId = settings.showThinkingNode &amp;&amp; thinking ? findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING) : null;\n\t\tconst anchorNode = thinkingNodeId ? getNodeById(data, thinkingNodeId) : outputNode;\n\t\tconst anchorY = anchorNode &amp;&amp; \"y\" in anchorNode ? (anchorNode as { y: number }).y : outputY;\n\t\tconst promptDefaultY = anchorY - height - GREEN_NODE_PADDING;\n\t\tconst promptExclude = [sourceNode.id, resolvedOutputId, thinkingId, promptId].filter((id): id is string =&gt; id != null);\n\t\tconst { x: px, y: py } = chooseOutputPositionXY(\n\t\t\tdata,\n\t\t\tsourceNode.id,\n\t\t\tpromptId,\n\t\t\tdefaultX,\n\t\t\tpromptDefaultY,\n\t\t\twidth\n;\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 458,
                "column": 1
              },
              "endPosition": {
                "line": 465,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 460,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 461,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 463,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 464,
            "isSignature": true
          },
          {
            "text": "const { x: tx, y: ty } = ",
            "lineNumber": 547
          },
          {
            "lineNumber": 552
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 553
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 554
          },
          {
            "text": "\t\t\tthinkingExclude",
            "lineNumber": 555
          },
          {
            "text": "\t\t);",
            "lineNumber": 556
          },
          {
            "text": "\t\tconst thinkingColor = shadeColor(settings.colorGreen, 0.15);",
            "lineNumber": 557
          },
          {
            "lineNumber": 558
          },
          {
            "text": "\t\tif (thinkingId) {",
            "lineNumber": 559
          },
          {
            "text": "\t\t\tconst tn = getNodeById(data, thinkingId);",
            "lineNumber": 560
          },
          {
            "text": "\t\t\tif (tn &amp;&amp; isTextNode(tn)) {",
            "lineNumber": 561
          },
          {
            "text": "\t\t\t\tconst updated = {",
            "lineNumber": 562
          },
          {
            "text": "\t\t\t\t\t...(tn as CanvasTextData),",
            "lineNumber": 563
          },
          {
            "text": "\t\t\t\t\ttext: thinking,",
            "lineNumber": 564
          },
          {
            "text": "\t\t\t\t\twidth,",
            "lineNumber": 565
          },
          {
            "text": "\t\t\t\t\theight,",
            "lineNumber": 566
          },
          {
            "text": "\t\t\t\t\tcolor: thinkingColor,",
            "lineNumber": 567
          },
          {
            "text": "\t\t\t\t};",
            "lineNumber": 568
          },
          {
            "text": "\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === thinkingId);",
            "lineNumber": 569
          },
          {
            "text": "\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 570
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 571
          },
          {
            "text": "\t\t\tconst hasEdge = data.edges.some(",
            "lineNumber": 572
          },
          {
            "text": "\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === thinkingId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING",
            "lineNumber": 573
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 574
          },
          {
            "text": "\t\t\tif (!hasEdge) {",
            "lineNumber": 575
          },
          {
            "text": "\t\t\t\tdata.edges.push({",
            "lineNumber": 576
          },
          {
            "text": "\t\t\t\t\tid: randomId(),",
            "lineNumber": 577
          },
          {
            "text": "\t\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 578
          },
          {
            "text": "\t\t\t\t\ttoNode: thinkingId,",
            "lineNumber": 579
          },
          {
            "text": "\t\t\t\t\tlabel: EDGE_LABEL_THINKING,",
            "lineNumber": 580
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 581
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 582
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 583
          },
          {
            "text": "\t\t\tconst newId = randomId();",
            "lineNumber": 584
          },
          {
            "text": "\t\t\tdata.nodes.push({",
            "lineNumber": 585
          },
          {
            "text": "\t\t\t\tid: newId,",
            "lineNumber": 586
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 587
          },
          {
            "text": "\t\t\t\ttext: thinking,",
            "lineNumber": 588
          },
          {
            "text": "\t\t\t\tx: tx,",
            "lineNumber": 589
          },
          {
            "text": "\t\t\t\ty: ty,",
            "lineNumber": 590
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 591
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 592
          },
          {
            "text": "\t\t\t\tcolor: thinkingColor,",
            "lineNumber": 593
          },
          {
            "text": "\t\t\t} as CanvasTextData);",
            "lineNumber": 594
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 595
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 596
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 597
          },
          {
            "text": "\t\t\t\ttoNode: newId,",
            "lineNumber": 598
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_THINKING,",
            "lineNumber": 599
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 600
          },
          {
            "text": "\t\t}",
            "lineNumber": 601
          },
          {
            "text": "\t}",
            "lineNumber": 602
          },
          {
            "lineNumber": 603
          },
          {
            "text": "\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present",
            "lineNumber": 604
          },
          {
            "text": "\tif (settings.showPromptInOutput &amp;&amp; fullPrompt != null &amp;&amp; fullPrompt.length &gt; 0) {",
            "lineNumber": 605
          },
          {
            "text": "\t\tconst thinkingNodeId = settings.showThinkingNode &amp;&amp; thinking ? findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING) : null;",
            "lineNumber": 606
          },
          {
            "text": "\t\tconst anchorNode = thinkingNodeId ? getNodeById(data, thinkingNodeId) : outputNode;",
            "lineNumber": 607
          },
          {
            "text": "\t\tconst anchorY = anchorNode &amp;&amp; \"y\" in anchorNode ? (anchorNode as { y: number }).y : outputY;",
            "lineNumber": 608
          },
          {
            "text": "\t\tconst promptDefaultY = anchorY - height - GREEN_NODE_PADDING;",
            "lineNumber": 609
          },
          {
            "text": "\t\tconst promptExclude = [sourceNode.id, resolvedOutputId, thinkingId, promptId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 610
          },
          {
            "text": "\t\tconst { x: px, y: py } = chooseOutputPositionXY(",
            "lineNumber": 611
          },
          {
            "text": "\t\t\tdata,",
            "lineNumber": 612
          },
          {
            "text": "\t\t\tsourceNode.id,",
            "lineNumber": 613
          },
          {
            "text": "\t\t\tpromptId,",
            "lineNumber": 614
          },
          {
            "text": "\t\t\tdefaultX,",
            "lineNumber": 615
          },
          {
            "text": "\t\t\tpromptDefaultY,",
            "lineNumber": 616
          },
          {
            "text": "\t\t\twidth",
            "lineNumber": 617
          },
          {
            "text": ";",
            "lineNumber": 620
          },
          {
            "text": "}",
            "lineNumber": 667,
            "isSignature": true
          }
        ]
      },
      "score": 0.24601256847381592
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/settings.ts",
        "range": {
          "startPosition": {
            "line": 279
          },
          "endPosition": {
            "line": 374,
            "column": 1
          }
        },
        "contents": "function addModelBlock(\n\tcontainerEl: HTMLElement,\n\trole: \"orange\" | \"purple\" | \"red\",\n\tmodels: string[] | null,\n\tplugin: Plugin &amp; { settings: ZettelPluginSettings; saveSettings(): Promise&lt;void&gt; },\n\twarningCallback?: (message: string | null) =&gt; void\n): void {\n\n\n\tfunction updateSummaryText(): void {\n\t\tconst name = (plugin.settings[modelKey] as string)?.trim() || \"\";\n\t\tconst label = (plugin.settings[labelKey] as string)?.trim() || \"\";\n\t\tconst part = label ? &#96;${label}: ${name || \"(no model)\"}&#96; : name || \"(no model selected)\";\n\t\tsummary.setText(&#96;${title} — ${part}&#96;);\n\t}\n\n\tif (models &amp;&amp; models.length &gt; 0) {\n\t\tnew Setting(content)\n\t\t\t.setName(\"Model\")\n\t\t\t.setDesc(\"Ollama model used when you run this model node\")\n\t\t\t.addDropdown((dropdown) =&gt; {\n\t\t\t\tdropdown.addOption(\"\", \"— Select model —\");\n\t\t\t\tfor (const name of models) dropdown.addOption(name, name);\n\t\t\t\tconst current = (s[modelKey] as string) || \"\";\n\t\t\t\tdropdown.setValue(current &amp;&amp; models.includes(current) ? current : \"\");\n\t\t\t\tdropdown.onChange(async (value) =&gt; {\n\t\t\t\t\t(plugin.settings as unknown as Record&lt;string, string&gt;)[modelKey] = value;\n\t\t\t\t\tupdateSummaryText();\n\t\t\t\t\tawait plugin.saveSettings();\n\t\t\t\t});\n\t\t\t});\n\t} else {\n\t\tnew Setting(content)\n\t\t\t.setName(\"Model\")\n\t\t\t.setDesc(\"Ollama model name (e.g. llama2, mistral). Enter manually if Ollama is not reachable.\")\n\t\t\t.addText((text) =&gt; text\n\t\t\t\t.setPlaceholder(\"e.g. llama2\")\n\t\t\t\t.setValue((s[modelKey] as string) || \"\")\n\t\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t\t(plugin.settings as unknown as Record&lt;string, string&gt;)[modelKey] = value;\n\t\t\t\t\tupdateSummaryText();\n\t\t\t\t\tawait plugin.saveSettings();\n\t\t\t\t}));\n\t}\n\n\tnew Setting(content)\n\t\t.setName(\"Label\")\n\t\t.setDesc(\"Optional label on the canvas (e.g. quick, big); model name is shown after it\")\n\t\t.addText((text) =&gt; text\n\t\t\t.setPlaceholder(\"e.g. quick\")\n\t\t\t.setValue((s[labelKey] as string) || \"\")\n\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t(plugin.settings as unknown as Record&lt;string, string&gt;)[labelKey] = value;\n\t\t\t\tupdateSummaryText();\n\t\t\t\tawait plugin.saveSettings();\n\t\t\t}));\n\n\tconst initialTemp = Number(s[temperatureKey]) ?? (DEFAULT_SETTINGS[temperatureKey] as number);\n\tlet tempValueEl: HTMLSpanElement;\n\tconst tempSetting = new Setting(content)\n\t\t.setName(\"Temperature\")\n\t\t.setDesc\n;\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 280,
                "column": 1
              },
              "endPosition": {
                "line": 287,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function addModelBlock(",
            "lineNumber": 280,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 281,
            "isSignature": true
          },
          {
            "text": "\trole: \"orange\" | \"purple\" | \"red\",",
            "lineNumber": 282,
            "isSignature": true
          },
          {
            "text": "\tmodels: string[] | null,",
            "lineNumber": 283,
            "isSignature": true
          },
          {
            "text": "\tplugin: Plugin &amp; { settings: ZettelPluginSettings; saveSettings(): Promise&lt;void&gt; },",
            "lineNumber": 284,
            "isSignature": true
          },
          {
            "text": "\twarningCallback?: (message: string | null) =&gt; void",
            "lineNumber": 285,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 286,
            "isSignature": true
          },
          {
            "lineNumber": 298
          },
          {
            "lineNumber": 299
          },
          {
            "text": "\tfunction updateSummaryText(): void {",
            "lineNumber": 300,
            "isSignature": true
          },
          {
            "text": "\t\tconst name = (plugin.settings[modelKey] as string)?.trim() || \"\";",
            "lineNumber": 301
          },
          {
            "text": "\t\tconst label = (plugin.settings[labelKey] as string)?.trim() || \"\";",
            "lineNumber": 302
          },
          {
            "text": "\t\tconst part = label ? &#96;${label}: ${name || \"(no model)\"}&#96; : name || \"(no model selected)\";",
            "lineNumber": 303
          },
          {
            "text": "\t\tsummary.setText(&#96;${title} — ${part}&#96;);",
            "lineNumber": 304
          },
          {
            "text": "\t}",
            "lineNumber": 305,
            "isSignature": true
          },
          {
            "lineNumber": 306
          },
          {
            "text": "\tif (models &amp;&amp; models.length &gt; 0) {",
            "lineNumber": 307
          },
          {
            "text": "\t\tnew Setting(content)",
            "lineNumber": 308
          },
          {
            "text": "\t\t\t.setName(\"Model\")",
            "lineNumber": 309
          },
          {
            "text": "\t\t\t.setDesc(\"Ollama model used when you run this model node\")",
            "lineNumber": 310
          },
          {
            "text": "\t\t\t.addDropdown((dropdown) =&gt; {",
            "lineNumber": 311
          },
          {
            "text": "\t\t\t\tdropdown.addOption(\"\", \"— Select model —\");",
            "lineNumber": 312
          },
          {
            "text": "\t\t\t\tfor (const name of models) dropdown.addOption(name, name);",
            "lineNumber": 313
          },
          {
            "text": "\t\t\t\tconst current = (s[modelKey] as string) || \"\";",
            "lineNumber": 314
          },
          {
            "text": "\t\t\t\tdropdown.setValue(current &amp;&amp; models.includes(current) ? current : \"\");",
            "lineNumber": 315
          },
          {
            "text": "\t\t\t\tdropdown.onChange(async (value) =&gt; {",
            "lineNumber": 316
          },
          {
            "text": "\t\t\t\t\t(plugin.settings as unknown as Record&lt;string, string&gt;)[modelKey] = value;",
            "lineNumber": 317
          },
          {
            "text": "\t\t\t\t\tupdateSummaryText();",
            "lineNumber": 318
          },
          {
            "text": "\t\t\t\t\tawait plugin.saveSettings();",
            "lineNumber": 319
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 320
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 321
          },
          {
            "text": "\t} else {",
            "lineNumber": 322
          },
          {
            "text": "\t\tnew Setting(content)",
            "lineNumber": 323
          },
          {
            "text": "\t\t\t.setName(\"Model\")",
            "lineNumber": 324
          },
          {
            "text": "\t\t\t.setDesc(\"Ollama model name (e.g. llama2, mistral). Enter manually if Ollama is not reachable.\")",
            "lineNumber": 325
          },
          {
            "text": "\t\t\t.addText((text) =&gt; text",
            "lineNumber": 326
          },
          {
            "text": "\t\t\t\t.setPlaceholder(\"e.g. llama2\")",
            "lineNumber": 327
          },
          {
            "text": "\t\t\t\t.setValue((s[modelKey] as string) || \"\")",
            "lineNumber": 328
          },
          {
            "text": "\t\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 329
          },
          {
            "text": "\t\t\t\t\t(plugin.settings as unknown as Record&lt;string, string&gt;)[modelKey] = value;",
            "lineNumber": 330
          },
          {
            "text": "\t\t\t\t\tupdateSummaryText();",
            "lineNumber": 331
          },
          {
            "text": "\t\t\t\t\tawait plugin.saveSettings();",
            "lineNumber": 332
          },
          {
            "text": "\t\t\t\t}));",
            "lineNumber": 333
          },
          {
            "text": "\t}",
            "lineNumber": 334
          },
          {
            "lineNumber": 335
          },
          {
            "text": "\tnew Setting(content)",
            "lineNumber": 336
          },
          {
            "text": "\t\t.setName(\"Label\")",
            "lineNumber": 337
          },
          {
            "text": "\t\t.setDesc(\"Optional label on the canvas (e.g. quick, big); model name is shown after it\")",
            "lineNumber": 338
          },
          {
            "text": "\t\t.addText((text) =&gt; text",
            "lineNumber": 339
          },
          {
            "text": "\t\t\t.setPlaceholder(\"e.g. quick\")",
            "lineNumber": 340
          },
          {
            "text": "\t\t\t.setValue((s[labelKey] as string) || \"\")",
            "lineNumber": 341
          },
          {
            "text": "\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 342
          },
          {
            "text": "\t\t\t\t(plugin.settings as unknown as Record&lt;string, string&gt;)[labelKey] = value;",
            "lineNumber": 343
          },
          {
            "text": "\t\t\t\tupdateSummaryText();",
            "lineNumber": 344
          },
          {
            "text": "\t\t\t\tawait plugin.saveSettings();",
            "lineNumber": 345
          },
          {
            "text": "\t\t\t}));",
            "lineNumber": 346
          },
          {
            "lineNumber": 347
          },
          {
            "text": "\tconst initialTemp = Number(s[temperatureKey]) ?? (DEFAULT_SETTINGS[temperatureKey] as number);",
            "lineNumber": 348
          },
          {
            "text": "\tlet tempValueEl: HTMLSpanElement;",
            "lineNumber": 349
          },
          {
            "text": "\tconst tempSetting = new Setting(content)",
            "lineNumber": 350
          },
          {
            "text": "\t\t.setName(\"Temperature\")",
            "lineNumber": 351
          },
          {
            "text": "\t\t.setDesc",
            "lineNumber": 352
          },
          {
            "text": ";",
            "lineNumber": 362
          },
          {
            "text": "}",
            "lineNumber": 375,
            "isSignature": true
          }
        ]
      },
      "score": 0.2411821037530899
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/pythonKernel.ts",
        "range": {
          "startPosition": {
            "line": 16
          },
          "endPosition": {
            "line": 128,
            "column": 1
          }
        },
        "contents": "export function createPythonKernel(pythonPath: string): PythonKernel {\nfunction spawnProcess(): Promise&lt;void&gt; {\n(resolve, reject) =&gt; {\n catch (e) {\n\t\t\t\treject(e);\n\t\t\t}\n\t\t});\n\t}\n\n\tasync function run(code: string, inputText: string): Promise&lt;string&gt; {\n\t\tawait spawnProcess();\n\t\tif (!child?.stdin) throw new Error(\"Python process not running\");\n\t\tconst fullCode =\n\t\t\tOBSIDIAN_LOG_STUB +\n\t\t\t\"\\ninput = \" +\n\t\t\tJSON.stringify(inputText) +\n\t\t\t\"\\n\\n\" +\n\t\t\tcode +\n\t\t\t\"\\nprint(\" +\n\t\t\tJSON.stringify(END_MARKER) +\n\t\t\t\")\\n\";\n\t\t// Encode as base64 so we can send without escaping issues\n\t\tconst b64 = Buffer.from(fullCode, \"utf-8\").toString(\"base64\");\n\t\tconst payload = &#96;exec(__import__('base64').b64decode(\"${b64}\").decode())\\n&#96;;\n\t\tstdoutBuf = \"\";\n\t\treturn new Promise((resolve, reject) =&gt; {\n\t\t\tpendingResolve = resolve;\n\t\t\tpendingReject = reject;\n\t\t\tchild!.stdin!.write(payload, (err) =&gt; {\n\t\t\t\tif (err) {\n\t\t\t\t\tpendingReject?.(err);\n\t\t\t\t\tpendingResolve = null;\n\t\t\t\t\tpendingReject = null;\n\t\t\t\t}\n\t\t\t});\n\t\t\tsetTimeout(() =&gt; {\n\t\t\t\tif (pendingReject) {\n\t\t\t\t\tpendingReject(new Error(\"Python execution timeout (60s)\"));\n\t\t\t\t\tpendingResolve = null;\n\t\t\t\t\tpendingReject = null;\n\t\t\t\t}\n\t\t\t}, 60_000);\n\t\t});\n\t}\n\n\treturn {\n\t\tget onLog() {\n\t\t\treturn onLogCb;\n\t\t},\n\t\tset onLog(cb: ((line: string) =&gt; void) | undefined) {\n\t\t\tonLogCb = cb;\n\t\t},\n\t\trun,\n\t\tterminate() {\n\t\t\tif (child) {\n\t\t\t\tchild.kill();\n\t\t\t\tchild = null;\n\t\t\t}\n\t\t\tif (pendingReject) {\n\t\t\t\tpendingReject(new Error(\"Kernel terminated\"));\n\t\t\t\tpendingResolve = null;\n\t\t\t\tpendingReject = null;\n\t\t\t}\n\t\t},\n\t};\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 17,
                "column": 1
              },
              "endPosition": {
                "line": 17,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 17,
                "column": 8
              },
              "endPosition": {
                "line": 18,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export function createPythonKernel(pythonPath: string): PythonKernel {",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "text": "function spawnProcess(): Promise&lt;void&gt; {",
            "lineNumber": 24
          },
          {
            "text": "(resolve, reject) =&gt; {",
            "lineNumber": 26
          },
          {
            "text": " catch (e) {",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t\treject(e);",
            "lineNumber": 68
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 69
          },
          {
            "text": "\t\t});",
            "lineNumber": 70
          },
          {
            "text": "\t}",
            "lineNumber": 71
          },
          {
            "lineNumber": 72
          },
          {
            "text": "\tasync function run(code: string, inputText: string): Promise&lt;string&gt; {",
            "lineNumber": 73
          },
          {
            "text": "\t\tawait spawnProcess();",
            "lineNumber": 74
          },
          {
            "text": "\t\tif (!child?.stdin) throw new Error(\"Python process not running\");",
            "lineNumber": 75
          },
          {
            "text": "\t\tconst fullCode =",
            "lineNumber": 76
          },
          {
            "text": "\t\t\tOBSIDIAN_LOG_STUB +",
            "lineNumber": 77
          },
          {
            "text": "\t\t\t\"\\ninput = \" +",
            "lineNumber": 78
          },
          {
            "text": "\t\t\tJSON.stringify(inputText) +",
            "lineNumber": 79
          },
          {
            "text": "\t\t\t\"\\n\\n\" +",
            "lineNumber": 80
          },
          {
            "text": "\t\t\tcode +",
            "lineNumber": 81
          },
          {
            "text": "\t\t\t\"\\nprint(\" +",
            "lineNumber": 82
          },
          {
            "text": "\t\t\tJSON.stringify(END_MARKER) +",
            "lineNumber": 83
          },
          {
            "text": "\t\t\t\")\\n\";",
            "lineNumber": 84
          },
          {
            "text": "\t\t// Encode as base64 so we can send without escaping issues",
            "lineNumber": 85
          },
          {
            "text": "\t\tconst b64 = Buffer.from(fullCode, \"utf-8\").toString(\"base64\");",
            "lineNumber": 86
          },
          {
            "text": "\t\tconst payload = &#96;exec(__import__('base64').b64decode(\"${b64}\").decode())\\n&#96;;",
            "lineNumber": 87
          },
          {
            "text": "\t\tstdoutBuf = \"\";",
            "lineNumber": 88
          },
          {
            "text": "\t\treturn new Promise((resolve, reject) =&gt; {",
            "lineNumber": 89
          },
          {
            "text": "\t\t\tpendingResolve = resolve;",
            "lineNumber": 90
          },
          {
            "text": "\t\t\tpendingReject = reject;",
            "lineNumber": 91
          },
          {
            "text": "\t\t\tchild!.stdin!.write(payload, (err) =&gt; {",
            "lineNumber": 92
          },
          {
            "text": "\t\t\t\tif (err) {",
            "lineNumber": 93
          },
          {
            "text": "\t\t\t\t\tpendingReject?.(err);",
            "lineNumber": 94
          },
          {
            "text": "\t\t\t\t\tpendingResolve = null;",
            "lineNumber": 95
          },
          {
            "text": "\t\t\t\t\tpendingReject = null;",
            "lineNumber": 96
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 97
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 98
          },
          {
            "text": "\t\t\tsetTimeout(() =&gt; {",
            "lineNumber": 99
          },
          {
            "text": "\t\t\t\tif (pendingReject) {",
            "lineNumber": 100
          },
          {
            "text": "\t\t\t\t\tpendingReject(new Error(\"Python execution timeout (60s)\"));",
            "lineNumber": 101
          },
          {
            "text": "\t\t\t\t\tpendingResolve = null;",
            "lineNumber": 102
          },
          {
            "text": "\t\t\t\t\tpendingReject = null;",
            "lineNumber": 103
          },
          {
            "text": "\t\t\t\t}",
            "lineNumber": 104
          },
          {
            "text": "\t\t\t}, 60_000);",
            "lineNumber": 105
          },
          {
            "text": "\t\t});",
            "lineNumber": 106
          },
          {
            "text": "\t}",
            "lineNumber": 107
          },
          {
            "lineNumber": 108
          },
          {
            "text": "\treturn {",
            "lineNumber": 109
          },
          {
            "text": "\t\tget onLog() {",
            "lineNumber": 110
          },
          {
            "text": "\t\t\treturn onLogCb;",
            "lineNumber": 111
          },
          {
            "text": "\t\t},",
            "lineNumber": 112
          },
          {
            "text": "\t\tset onLog(cb: ((line: string) =&gt; void) | undefined) {",
            "lineNumber": 113
          },
          {
            "text": "\t\t\tonLogCb = cb;",
            "lineNumber": 114
          },
          {
            "text": "\t\t},",
            "lineNumber": 115
          },
          {
            "text": "\t\trun,",
            "lineNumber": 116
          },
          {
            "text": "\t\tterminate() {",
            "lineNumber": 117
          },
          {
            "text": "\t\t\tif (child) {",
            "lineNumber": 118
          },
          {
            "text": "\t\t\t\tchild.kill();",
            "lineNumber": 119
          },
          {
            "text": "\t\t\t\tchild = null;",
            "lineNumber": 120
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 121
          },
          {
            "text": "\t\t\tif (pendingReject) {",
            "lineNumber": 122
          },
          {
            "text": "\t\t\t\tpendingReject(new Error(\"Kernel terminated\"));",
            "lineNumber": 123
          },
          {
            "text": "\t\t\t\tpendingResolve = null;",
            "lineNumber": 124
          },
          {
            "text": "\t\t\t\tpendingReject = null;",
            "lineNumber": 125
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 126
          },
          {
            "text": "\t\t},",
            "lineNumber": 127
          },
          {
            "text": "\t};",
            "lineNumber": 128
          },
          {
            "text": "}",
            "lineNumber": 129,
            "isSignature": true
          }
        ]
      },
      "score": 0.22256210446357727
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/tutorials/example4Data.ts",
        "range": {
          "startPosition": {
            "column": 48
          },
          "endPosition": {
            "line": 138,
            "column": 1
          }
        },
        "contents": "/** Example 2 &amp; 3: Variable injection and Python state. */\nexport function getExample4CanvasData(): CanvasData {\n\treturn {\n\t\tnodes: [\n\t\t\t// Workflow 2: Variable Injection\n\t\t\t{\n\t\t\t\tid: \"group-inject\",\n\t\t\t\ttype: \"group\",\n\t\t\t\tx: 30,\n\t\t\t\ty: 30,\n\t\t\t\twidth: 720,\n\t\t\t\theight: 540,\n\t\t\t\tlabel: \"Workflow 2: Variable Injection (precise placement)\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"yellow-concept\",\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: \"Evergreen notes\",\n\t\t\t\tx: 50,\n\t\t\t\ty: 100,\n\t\t\t\twidth: 200,\n\t\t\t\theight: 60,\n\t\t\t\tcolor: \"3\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"orange-define\",\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: \"Define {{var:term}} in one sentence.\",\n\t\t\t\tx: 300,\n\t\t\t\ty: 100,\n\t\t\t\twidth: 250,\n\t\t\t\theight: 100,\n\t\t\t\tcolor: \"1\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"purple-critique\",\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: \"Critique this definition:\\n\\n{{var:def}}\\n\\nProvide 2 improvements.\",\n\t\t\t\tx: 300,\n\t\t\t\ty: 260,\n\t\t\t\twidth: 300,\n\t\t\t\theight: 140,\n\t\t\t\tcolor: \"2\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"note-inject-explanation\",\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: \"💡 How it works:\\n\\n1. Label the edge: 'term' (not concatenated)\\n2. In Orange: {{var:term}} inserts 'Evergreen notes'\\n3. Label next edge: 'def' \\n4. In Purple: {{var:def}} inserts the definition\\n\\nWithout {{var:name}}, the input would be concatenated at the top instead.\",\n\t\t\t\tx: 50,\n\t\t\t\ty: 430,\n\t\t\t\twidth: 650,\n\t\t\t\theight: 120,\n\t\t\t\tcolor: \"\",\n\t\t\t},\n\t\t\t// Workflow 3: Python State\n\t\t\t{\n\t\t\t\tid: \"group-python\",\n\t\t\t\ttype: \"group\",\n\t\t\t\tx: 30,\n\t\t\t\ty: 610,\n\t\t\t\twidth: 720,\n\t\t\t\theight: 520,\n\t\t\t\tlabel: \"Workflow 3: Python Persistent State\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"yellow-note1\",\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: \"Topic: Atomic notes\",\n\t\t\t\tx: 50,\n\t\t\t\ty: 680,\n\t\t\t\twidth: 200,\n\t\t\t\theight: 60,\n\t\t\t\tcolor: \"3\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"blue-store1\",\n\t\t\t\ttype: \"text\",\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Example 2 &amp; 3: Variable injection and Python state. */",
            "lineNumber": 3
          },
          {
            "text": "export function getExample4CanvasData(): CanvasData {",
            "lineNumber": 4,
            "isSignature": true
          },
          {
            "text": "\treturn {",
            "lineNumber": 5
          },
          {
            "text": "\t\tnodes: [",
            "lineNumber": 6
          },
          {
            "text": "\t\t\t// Workflow 2: Variable Injection",
            "lineNumber": 7
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 8
          },
          {
            "text": "\t\t\t\tid: \"group-inject\",",
            "lineNumber": 9
          },
          {
            "text": "\t\t\t\ttype: \"group\",",
            "lineNumber": 10
          },
          {
            "text": "\t\t\t\tx: 30,",
            "lineNumber": 11
          },
          {
            "text": "\t\t\t\ty: 30,",
            "lineNumber": 12
          },
          {
            "text": "\t\t\t\twidth: 720,",
            "lineNumber": 13
          },
          {
            "text": "\t\t\t\theight: 540,",
            "lineNumber": 14
          },
          {
            "text": "\t\t\t\tlabel: \"Workflow 2: Variable Injection (precise placement)\",",
            "lineNumber": 15
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 16
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 17
          },
          {
            "text": "\t\t\t\tid: \"yellow-concept\",",
            "lineNumber": 18
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 19
          },
          {
            "text": "\t\t\t\ttext: \"Evergreen notes\",",
            "lineNumber": 20
          },
          {
            "text": "\t\t\t\tx: 50,",
            "lineNumber": 21
          },
          {
            "text": "\t\t\t\ty: 100,",
            "lineNumber": 22
          },
          {
            "text": "\t\t\t\twidth: 200,",
            "lineNumber": 23
          },
          {
            "text": "\t\t\t\theight: 60,",
            "lineNumber": 24
          },
          {
            "text": "\t\t\t\tcolor: \"3\",",
            "lineNumber": 25
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 26
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 27
          },
          {
            "text": "\t\t\t\tid: \"orange-define\",",
            "lineNumber": 28
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 29
          },
          {
            "text": "\t\t\t\ttext: \"Define {{var:term}} in one sentence.\",",
            "lineNumber": 30
          },
          {
            "text": "\t\t\t\tx: 300,",
            "lineNumber": 31
          },
          {
            "text": "\t\t\t\ty: 100,",
            "lineNumber": 32
          },
          {
            "text": "\t\t\t\twidth: 250,",
            "lineNumber": 33
          },
          {
            "text": "\t\t\t\theight: 100,",
            "lineNumber": 34
          },
          {
            "text": "\t\t\t\tcolor: \"1\",",
            "lineNumber": 35
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 36
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 37
          },
          {
            "text": "\t\t\t\tid: \"purple-critique\",",
            "lineNumber": 38
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 39
          },
          {
            "text": "\t\t\t\ttext: \"Critique this definition:\\n\\n{{var:def}}\\n\\nProvide 2 improvements.\",",
            "lineNumber": 40
          },
          {
            "text": "\t\t\t\tx: 300,",
            "lineNumber": 41
          },
          {
            "text": "\t\t\t\ty: 260,",
            "lineNumber": 42
          },
          {
            "text": "\t\t\t\twidth: 300,",
            "lineNumber": 43
          },
          {
            "text": "\t\t\t\theight: 140,",
            "lineNumber": 44
          },
          {
            "text": "\t\t\t\tcolor: \"2\",",
            "lineNumber": 45
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 46
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 47
          },
          {
            "text": "\t\t\t\tid: \"note-inject-explanation\",",
            "lineNumber": 48
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 49
          },
          {
            "text": "\t\t\t\ttext: \"💡 How it works:\\n\\n1. Label the edge: 'term' (not concatenated)\\n2. In Orange: {{var:term}} inserts 'Evergreen notes'\\n3. Label next edge: 'def' \\n4. In Purple: {{var:def}} inserts the definition\\n\\nWithout {{var:name}}, the input would be concatenated at the top instead.\",",
            "lineNumber": 50
          },
          {
            "text": "\t\t\t\tx: 50,",
            "lineNumber": 51
          },
          {
            "text": "\t\t\t\ty: 430,",
            "lineNumber": 52
          },
          {
            "text": "\t\t\t\twidth: 650,",
            "lineNumber": 53
          },
          {
            "text": "\t\t\t\theight: 120,",
            "lineNumber": 54
          },
          {
            "text": "\t\t\t\tcolor: \"\",",
            "lineNumber": 55
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 56
          },
          {
            "text": "\t\t\t// Workflow 3: Python State",
            "lineNumber": 57
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 58
          },
          {
            "text": "\t\t\t\tid: \"group-python\",",
            "lineNumber": 59
          },
          {
            "text": "\t\t\t\ttype: \"group\",",
            "lineNumber": 60
          },
          {
            "text": "\t\t\t\tx: 30,",
            "lineNumber": 61
          },
          {
            "text": "\t\t\t\ty: 610,",
            "lineNumber": 62
          },
          {
            "text": "\t\t\t\twidth: 720,",
            "lineNumber": 63
          },
          {
            "text": "\t\t\t\theight: 520,",
            "lineNumber": 64
          },
          {
            "text": "\t\t\t\tlabel: \"Workflow 3: Python Persistent State\",",
            "lineNumber": 65
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 66
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 67
          },
          {
            "text": "\t\t\t\tid: \"yellow-note1\",",
            "lineNumber": 68
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 69
          },
          {
            "text": "\t\t\t\ttext: \"Topic: Atomic notes\",",
            "lineNumber": 70
          },
          {
            "text": "\t\t\t\tx: 50,",
            "lineNumber": 71
          },
          {
            "text": "\t\t\t\ty: 680,",
            "lineNumber": 72
          },
          {
            "text": "\t\t\t\twidth: 200,",
            "lineNumber": 73
          },
          {
            "text": "\t\t\t\theight: 60,",
            "lineNumber": 74
          },
          {
            "text": "\t\t\t\tcolor: \"3\",",
            "lineNumber": 75
          },
          {
            "text": "\t\t\t},",
            "lineNumber": 76
          },
          {
            "text": "\t\t\t{",
            "lineNumber": 77
          },
          {
            "text": "\t\t\t\tid: \"blue-store1\",",
            "lineNumber": 78
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 79
          },
          {
            "text": "}",
            "lineNumber": 139,
            "isSignature": true
          }
        ]
      },
      "score": 0.21403133869171143
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 67,
            "column": 1
          },
          "endPosition": {
            "line": 89,
            "column": 106
          }
        },
        "contents": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y then x (higher, then left-most). Excludes output/prompt/thinking edges. */\nexport function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withPos = edges.map((e) =&gt; {\n\t\tconst parent = nodeMap.get(e.fromNode);\n\t\tconst y = parent?.y ?? 0;\n\t\tconst x = parent?.x ?? 0;\n\t\treturn {\n\t\t\tparentId: e.fromNode,\n\t\t\tedge: e,\n\t\t\tvariableName: parseEdgeVariableName(e.label),\n\t\t\ty,\n\t\t\tx,\n\t\t};\n\t});\n\twithPos.sort((a, b) =&gt; (a.y !== b.y ? a.y - b.y : a.x - b.x));\n\treturn withPos.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));\n}\n\n/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y then x (higher, then left-most). Excludes output/prompt/thinking edges. */",
            "lineNumber": 70
          },
          {
            "text": "export function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {",
            "lineNumber": 71,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));",
            "lineNumber": 72
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 73
          },
          {
            "text": "\tconst withPos = edges.map((e) =&gt; {",
            "lineNumber": 74
          },
          {
            "text": "\t\tconst parent = nodeMap.get(e.fromNode);",
            "lineNumber": 75
          },
          {
            "text": "\t\tconst y = parent?.y ?? 0;",
            "lineNumber": 76
          },
          {
            "text": "\t\tconst x = parent?.x ?? 0;",
            "lineNumber": 77
          },
          {
            "text": "\t\treturn {",
            "lineNumber": 78
          },
          {
            "text": "\t\t\tparentId: e.fromNode,",
            "lineNumber": 79
          },
          {
            "text": "\t\t\tedge: e,",
            "lineNumber": 80
          },
          {
            "text": "\t\t\tvariableName: parseEdgeVariableName(e.label),",
            "lineNumber": 81
          },
          {
            "text": "\t\t\ty,",
            "lineNumber": 82
          },
          {
            "text": "\t\t\tx,",
            "lineNumber": 83
          },
          {
            "text": "\t\t};",
            "lineNumber": 84
          },
          {
            "text": "\t});",
            "lineNumber": 85
          },
          {
            "text": "\twithPos.sort((a, b) =&gt; (a.y !== b.y ? a.y - b.y : a.x - b.x));",
            "lineNumber": 86
          },
          {
            "text": "\treturn withPos.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));",
            "lineNumber": 87
          },
          {
            "text": "}",
            "lineNumber": 88,
            "isSignature": true
          },
          {
            "lineNumber": 89
          },
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */",
            "lineNumber": 90
          }
        ]
      },
      "score": 0.21045449376106262
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 147,
            "column": 1
          },
          "endPosition": {
            "line": 175,
            "column": 1
          }
        },
        "contents": "/** Sort ready queue: non-AI (Python, text) first for early output, then by y. */\nfunction sortQueueByNonAIFirst(\n\tqueue: string[],\n\tdata: CanvasData,\n\tsettings: ZettelPluginSettings\n): void {\n\tqueue.sort((a, b) =&gt; {\n\t\tconst na = getNodeById(data, a);\n\t\tconst nb = getNodeById(data, b);\n\t\tconst roleA = getNodeRole(na ?? { color: undefined }, settings);\n\t\tconst roleB = getNodeRole(nb ?? { color: undefined }, settings);\n\t\tconst nonA = isNonAIRole(roleA) ? 0 : 1;\n\t\tconst nonB = isNonAIRole(roleB) ? 0 : 1;\n\t\tif (nonA !== nonB) return nonA - nonB;\n\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);\n\t});\n}\n\n/** True if text is already wrapped in &#96;&#96;&#96;python or &#96;&#96;&#96; ... &#96;&#96;&#96;. */\nfunction isPythonCodeFenced(text: string): boolean {\n\tconst lines = text.trim().split(/\\r?\\n/);\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Sort ready queue: non-AI (Python, text) first for early output, then by y. */",
            "lineNumber": 150
          },
          {
            "text": "function sortQueueByNonAIFirst(",
            "lineNumber": 151,
            "isSignature": true
          },
          {
            "text": "\tqueue: string[],",
            "lineNumber": 152,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 153,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 154,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 155,
            "isSignature": true
          },
          {
            "text": "\tqueue.sort((a, b) =&gt; {",
            "lineNumber": 156
          },
          {
            "text": "\t\tconst na = getNodeById(data, a);",
            "lineNumber": 157
          },
          {
            "text": "\t\tconst nb = getNodeById(data, b);",
            "lineNumber": 158
          },
          {
            "text": "\t\tconst roleA = getNodeRole(na ?? { color: undefined }, settings);",
            "lineNumber": 159
          },
          {
            "text": "\t\tconst roleB = getNodeRole(nb ?? { color: undefined }, settings);",
            "lineNumber": 160
          },
          {
            "text": "\t\tconst nonA = isNonAIRole(roleA) ? 0 : 1;",
            "lineNumber": 161
          },
          {
            "text": "\t\tconst nonB = isNonAIRole(roleB) ? 0 : 1;",
            "lineNumber": 162
          },
          {
            "text": "\t\tif (nonA !== nonB) return nonA - nonB;",
            "lineNumber": 163
          },
          {
            "text": "\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);",
            "lineNumber": 164
          },
          {
            "text": "\t});",
            "lineNumber": 165
          },
          {
            "text": "}",
            "lineNumber": 166,
            "isSignature": true
          },
          {
            "lineNumber": 167
          },
          {
            "text": "/** True if text is already wrapped in &#96;&#96;&#96;python or &#96;&#96;&#96; ... &#96;&#96;&#96;. */",
            "lineNumber": 168
          },
          {
            "text": "function isPythonCodeFenced(text: string): boolean {",
            "lineNumber": 169,
            "isSignature": true
          },
          {
            "text": "\tconst lines = text.trim().split(/\\r?\\n/);",
            "lineNumber": 170
          },
          {
            "text": "}",
            "lineNumber": 176,
            "isSignature": true
          }
        ]
      },
      "score": 0.21023374795913696
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 232,
            "column": 1
          },
          "endPosition": {
            "line": 266,
            "column": 117
          }
        },
        "contents": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */\nasync function updateEdgeLabelsAndSave(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tedgeModes: Map&lt;string, EdgeInputMode&gt;,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tsetEdgeModes(canvasKey, edgeModes);\n\tlet changed = false;\n\tfor (const edge of data.edges) {\n\t\tif (edge.toNode !== nodeId) continue;\n\t\tif (isAuxiliaryEdge(edge)) continue;\n\t\tconst mode = edgeModes.get(edge.id);\n\t\tif (mode == null) continue;\n\t\tconst baseName = parseEdgeVariableName(edge.label);\n\t\tif (baseName.length === 0) continue;\n\t\t// Keep only the variable name in the stored label so the user can edit it without touching (injected)/(concatenated)\n\t\tif (edge.label !== baseName) {\n\t\t\tedge.label = baseName;\n\t\t\tchanged = true;\n\t\t}\n\t}\n\t// Always persist so output node/edge mutations from ensureOutputNodeAndEdge are saved\n\tliveCanvas?.setData?.(data);\n\tif (liveCanvas?.requestSave) liveCanvas.requestSave(); // so Obsidian marks canvas dirty and won't overwrite on tab switch\n\tconst saved = await saveCanvasData(vault, canvasFilePath, data);\n\tif (!saved) new Notice(\"Failed to save canvas.\");\n}\n\n/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Persist only base variable name in edge.label; store inject/concatenate in state for floating label. */",
            "lineNumber": 235
          },
          {
            "text": "async function updateEdgeLabelsAndSave(",
            "lineNumber": 236,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 237,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 238,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 239,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 240,
            "isSignature": true
          },
          {
            "text": "\tedgeModes: Map&lt;string, EdgeInputMode&gt;,",
            "lineNumber": 241,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 242,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 243,
            "isSignature": true
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 244
          },
          {
            "text": "\tsetEdgeModes(canvasKey, edgeModes);",
            "lineNumber": 245
          },
          {
            "text": "\tlet changed = false;",
            "lineNumber": 246
          },
          {
            "text": "\tfor (const edge of data.edges) {",
            "lineNumber": 247
          },
          {
            "text": "\t\tif (edge.toNode !== nodeId) continue;",
            "lineNumber": 248
          },
          {
            "text": "\t\tif (isAuxiliaryEdge(edge)) continue;",
            "lineNumber": 249
          },
          {
            "text": "\t\tconst mode = edgeModes.get(edge.id);",
            "lineNumber": 250
          },
          {
            "text": "\t\tif (mode == null) continue;",
            "lineNumber": 251
          },
          {
            "text": "\t\tconst baseName = parseEdgeVariableName(edge.label);",
            "lineNumber": 252
          },
          {
            "text": "\t\tif (baseName.length === 0) continue;",
            "lineNumber": 253
          },
          {
            "text": "\t\t// Keep only the variable name in the stored label so the user can edit it without touching (injected)/(concatenated)",
            "lineNumber": 254
          },
          {
            "text": "\t\tif (edge.label !== baseName) {",
            "lineNumber": 255
          },
          {
            "text": "\t\t\tedge.label = baseName;",
            "lineNumber": 256
          },
          {
            "text": "\t\t\tchanged = true;",
            "lineNumber": 257
          },
          {
            "text": "\t\t}",
            "lineNumber": 258
          },
          {
            "text": "\t}",
            "lineNumber": 259
          },
          {
            "text": "\t// Always persist so output node/edge mutations from ensureOutputNodeAndEdge are saved",
            "lineNumber": 260
          },
          {
            "text": "\tliveCanvas?.setData?.(data);",
            "lineNumber": 261
          },
          {
            "text": "\tif (liveCanvas?.requestSave) liveCanvas.requestSave(); // so Obsidian marks canvas dirty and won't overwrite on tab switch",
            "lineNumber": 262
          },
          {
            "text": "\tconst saved = await saveCanvasData(vault, canvasFilePath, data);",
            "lineNumber": 263
          },
          {
            "text": "\tif (!saved) new Notice(\"Failed to save canvas.\");",
            "lineNumber": 264
          },
          {
            "text": "}",
            "lineNumber": 265,
            "isSignature": true
          },
          {
            "lineNumber": 266
          },
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 267
          }
        ]
      },
      "score": 0.20828795433044434
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/ollama.ts",
        "range": {
          "startPosition": {
            "line": 37,
            "column": 1
          },
          "endPosition": {
            "line": 65,
            "column": 1
          }
        },
        "contents": "/** Call Ollama /api/generate and return the response and optional thinking. */\nexport async function ollamaGenerate(options: OllamaGenerateOptions): Promise&lt;OllamaGenerateResult&gt; {\n\tconst {model, prompt, stream = false, options: requestOptions} = options;\n\tconst url = &#96;${OLLAMA_BASE}/api/generate&#96;;\n\tconst payload: { model: string; prompt: string; stream: boolean; options?: OllamaGenerateRequestOptions } = {\n\t\tmodel,\n\t\tprompt,\n\t\tstream,\n\t};\n\tif (requestOptions &amp;&amp; Object.keys(requestOptions).length &gt; 0) {\n\t\tpayload.options = requestOptions;\n\t}\n\tconst body = JSON.stringify(payload);\n\tconst res = await fetch(url, {\n\t\tmethod: \"POST\",\n\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\tbody,\n\t});\n\tif (!res.ok) {\n\t\tconst text = await res.text();\n\t\tthrow new Error(&#96;Ollama error ${res.status}: ${text}&#96;);\n\t}\n\tconst data = (await res.json()) as { response?: string; thinking?: string };\n\tconst response = data.response ?? \"\";\n\tconst thinking = typeof data.thinking === \"string\" &amp;&amp; data.thinking.length &gt; 0 ? data.thinking : undefined;\n\treturn { response, thinking };\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Call Ollama /api/generate and return the response and optional thinking. */",
            "lineNumber": 40
          },
          {
            "text": "export async function ollamaGenerate(options: OllamaGenerateOptions): Promise&lt;OllamaGenerateResult&gt; {",
            "lineNumber": 41,
            "isSignature": true
          },
          {
            "text": "\tconst {model, prompt, stream = false, options: requestOptions} = options;",
            "lineNumber": 42
          },
          {
            "text": "\tconst url = &#96;${OLLAMA_BASE}/api/generate&#96;;",
            "lineNumber": 43
          },
          {
            "text": "\tconst payload: { model: string; prompt: string; stream: boolean; options?: OllamaGenerateRequestOptions } = {",
            "lineNumber": 44
          },
          {
            "text": "\t\tmodel,",
            "lineNumber": 45
          },
          {
            "text": "\t\tprompt,",
            "lineNumber": 46
          },
          {
            "text": "\t\tstream,",
            "lineNumber": 47
          },
          {
            "text": "\t};",
            "lineNumber": 48
          },
          {
            "text": "\tif (requestOptions &amp;&amp; Object.keys(requestOptions).length &gt; 0) {",
            "lineNumber": 49
          },
          {
            "text": "\t\tpayload.options = requestOptions;",
            "lineNumber": 50
          },
          {
            "text": "\t}",
            "lineNumber": 51
          },
          {
            "text": "\tconst body = JSON.stringify(payload);",
            "lineNumber": 52
          },
          {
            "text": "\tconst res = await fetch(url, {",
            "lineNumber": 53
          },
          {
            "text": "\t\tmethod: \"POST\",",
            "lineNumber": 54
          },
          {
            "text": "\t\theaders: { \"Content-Type\": \"application/json\" },",
            "lineNumber": 55
          },
          {
            "text": "\t\tbody,",
            "lineNumber": 56
          },
          {
            "text": "\t});",
            "lineNumber": 57
          },
          {
            "text": "\tif (!res.ok) {",
            "lineNumber": 58
          },
          {
            "text": "\t\tconst text = await res.text();",
            "lineNumber": 59
          },
          {
            "text": "\t\tthrow new Error(&#96;Ollama error ${res.status}: ${text}&#96;);",
            "lineNumber": 60
          },
          {
            "text": "\t}",
            "lineNumber": 61
          },
          {
            "text": "\tconst data = (await res.json()) as { response?: string; thinking?: string };",
            "lineNumber": 62
          },
          {
            "text": "\tconst response = data.response ?? \"\";",
            "lineNumber": 63
          },
          {
            "text": "\tconst thinking = typeof data.thinking === \"string\" &amp;&amp; data.thinking.length &gt; 0 ? data.thinking : undefined;",
            "lineNumber": 64
          },
          {
            "text": "\treturn { response, thinking };",
            "lineNumber": 65
          },
          {
            "text": "}",
            "lineNumber": 66,
            "isSignature": true
          }
        ]
      },
      "score": 0.2078177034854889
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 764
          },
          "endPosition": {
            "line": 809,
            "column": 1
          }
        },
        "contents": "export async function dismissOutput(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tsourceNodeId: string,\n\tsettings: ZettelPluginSettings,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\nconst ;\n\tconst thinkingId = findAuxiliaryNodeForSource(data, sourceNodeId, EDGE_LABEL_THINKING);\n\tconst toRemove = new Set&lt;string&gt;([outId, promptId, thinkingId].filter((id): id is string =&gt; id != null));\n\tif (toRemove.size === 0) return;\n\tdata.nodes = data.nodes.filter((n) =&gt; !toRemove.has(n.id));\n\tdata.edges = data.edges.filter(\n\t\t(e) =&gt;\n\t\t\t!(e.fromNode === sourceNodeId &amp;&amp; toRemove.has(e.toNode) &amp;&amp; [EDGE_LABEL_OUTPUT, EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING].includes(parseEdgeVariableName(e.label)))\n\t);\n\tliveCanvas?.setData?.(data);\n\tif (liveCanvas?.requestSave) liveCanvas.requestSave();\n\tconst saved = await saveCanvasData(vault, canvasFilePath, data);\n\tif (!saved) new Notice(\"Failed to save canvas.\");\n}\n\n/** Remove all Green output, prompt, and thinking nodes and their edges on the canvas; mutates data and saves. */\nexport async function dismissAllOutput(\n\tvault: App[\"vault\"],\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;void&gt; {\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (!data) return;\n\tconst auxiliaryLabels = [EDGE_LABEL_OUTPUT, EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING];\n\tconst auxiliaryNodeIds = new Set(\n\t\tdata.edges\n\t\t\t.filter((e) =&gt; auxiliaryLabels.includes(parseEdgeVariableName(e.label)))\n\t\t\t.map((e) =&gt; e.toNode)\n\t);\n\tdata.nodes = data.nodes.filter\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export async function dismissOutput(",
            "lineNumber": 765,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 766,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 767,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 768,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 769,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 770,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 771,
            "isSignature": true
          },
          {
            "text": "const ;",
            "lineNumber": 775
          },
          {
            "text": "\tconst thinkingId = findAuxiliaryNodeForSource(data, sourceNodeId, EDGE_LABEL_THINKING);",
            "lineNumber": 776
          },
          {
            "text": "\tconst toRemove = new Set&lt;string&gt;([outId, promptId, thinkingId].filter((id): id is string =&gt; id != null));",
            "lineNumber": 777
          },
          {
            "text": "\tif (toRemove.size === 0) return;",
            "lineNumber": 778
          },
          {
            "text": "\tdata.nodes = data.nodes.filter((n) =&gt; !toRemove.has(n.id));",
            "lineNumber": 779
          },
          {
            "text": "\tdata.edges = data.edges.filter(",
            "lineNumber": 780
          },
          {
            "text": "\t\t(e) =&gt;",
            "lineNumber": 781
          },
          {
            "text": "\t\t\t!(e.fromNode === sourceNodeId &amp;&amp; toRemove.has(e.toNode) &amp;&amp; [EDGE_LABEL_OUTPUT, EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING].includes(parseEdgeVariableName(e.label)))",
            "lineNumber": 782
          },
          {
            "text": "\t);",
            "lineNumber": 783
          },
          {
            "text": "\tliveCanvas?.setData?.(data);",
            "lineNumber": 784
          },
          {
            "text": "\tif (liveCanvas?.requestSave) liveCanvas.requestSave();",
            "lineNumber": 785
          },
          {
            "text": "\tconst saved = await saveCanvasData(vault, canvasFilePath, data);",
            "lineNumber": 786
          },
          {
            "text": "\tif (!saved) new Notice(\"Failed to save canvas.\");",
            "lineNumber": 787
          },
          {
            "text": "}",
            "lineNumber": 788,
            "isSignature": true
          },
          {
            "lineNumber": 789
          },
          {
            "text": "/** Remove all Green output, prompt, and thinking nodes and their edges on the canvas; mutates data and saves. */",
            "lineNumber": 790
          },
          {
            "text": "export async function dismissAllOutput(",
            "lineNumber": 791,
            "isSignature": true
          },
          {
            "text": "\tvault: App[\"vault\"],",
            "lineNumber": 792,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 793,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 794,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 795,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 796
          },
          {
            "text": "\tif (!data) return;",
            "lineNumber": 797
          },
          {
            "text": "\tconst auxiliaryLabels = [EDGE_LABEL_OUTPUT, EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING];",
            "lineNumber": 798
          },
          {
            "text": "\tconst auxiliaryNodeIds = new Set(",
            "lineNumber": 799
          },
          {
            "text": "\t\tdata.edges",
            "lineNumber": 800
          },
          {
            "text": "\t\t\t.filter((e) =&gt; auxiliaryLabels.includes(parseEdgeVariableName(e.label)))",
            "lineNumber": 801
          },
          {
            "text": "\t\t\t.map((e) =&gt; e.toNode)",
            "lineNumber": 802
          },
          {
            "text": "\t);",
            "lineNumber": 803
          },
          {
            "text": "\tdata.nodes = data.nodes.filter",
            "lineNumber": 804
          },
          {
            "text": "}",
            "lineNumber": 810,
            "isSignature": true
          }
        ]
      },
      "score": 0.20376209914684296
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Prompt view node position, collision avoidance, or placement",
  "includePattern": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 392,
            "column": 1
          },
          "endPosition": {
            "line": 440,
            "column": 1
          }
        },
        "contents": "/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */\nfunction chooseOutputPositionXY(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\toutNodeId: string | null,\n\tdefaultX: number,\n\tdefaultY: number,\n\twidth: number,\n\theight: number,\n\textraExcludeIds: string[] = []\n): { x: number; y: number } {\n\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);\n\tif (outNodeId) excludeIds.add(outNodeId);\n\tfor (const id of extraExcludeIds) excludeIds.add(id);\n\tconst box = { x: 0, y: 0, width, height };\n\tfunction tryPosition(x: number, y: number): boolean {\n\t\tbox.x = x;\n\t\tbox.y = y;\n\t\tfor (const node of data.nodes) {\n\t\t\tif (excludeIds.has(node.id)) continue;\n\t\t\t// Expand other node by buffer so we keep at least OUTPUT_COLLISION_BUFFER gap\n\t\t\tconst expanded = {\n\t\t\t\tx: node.x - OUTPUT_COLLISION_BUFFER,\n\t\t\t\ty: node.y - OUTPUT_COLLISION_BUFFER,\n\t\t\t\twidth: node.width + 2 * OUTPUT_COLLISION_BUFFER,\n\t\t\t\theight: node.height + 2 * OUTPUT_COLLISION_BUFFER,\n\t\t\t};\n\t\t\tif (rectanglesOverlap(box, expanded)) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {\n\t\tconst candidateY = defaultY + dy;\n\t\tfor (const dx of xOffsets()) {\n\t\t\tif (tryPosition(defaultX + dx, candidateY)) return { x: defaultX + dx, y: candidateY };\n\t\t}\n\t}\n\treturn { x: defaultX, y: defaultY };\n}\n\nfunction* xOffsets(): Generator&lt;number&gt; {\n\tyield 0;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */",
            "lineNumber": 395
          },
          {
            "text": "function chooseOutputPositionXY(",
            "lineNumber": 396,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 397,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 398,
            "isSignature": true
          },
          {
            "text": "\toutNodeId: string | null,",
            "lineNumber": 399,
            "isSignature": true
          },
          {
            "text": "\tdefaultX: number,",
            "lineNumber": 400,
            "isSignature": true
          },
          {
            "text": "\tdefaultY: number,",
            "lineNumber": 401,
            "isSignature": true
          },
          {
            "text": "\twidth: number,",
            "lineNumber": 402,
            "isSignature": true
          },
          {
            "text": "\theight: number,",
            "lineNumber": 403,
            "isSignature": true
          },
          {
            "text": "\textraExcludeIds: string[] = []",
            "lineNumber": 404,
            "isSignature": true
          },
          {
            "text": "): { x: number; y: number } {",
            "lineNumber": 405,
            "isSignature": true
          },
          {
            "text": "\tconst excludeIds = new Set&lt;string&gt;([sourceNodeId]);",
            "lineNumber": 406
          },
          {
            "text": "\tif (outNodeId) excludeIds.add(outNodeId);",
            "lineNumber": 407
          },
          {
            "text": "\tfor (const id of extraExcludeIds) excludeIds.add(id);",
            "lineNumber": 408
          },
          {
            "text": "\tconst box = { x: 0, y: 0, width, height };",
            "lineNumber": 409
          },
          {
            "text": "\tfunction tryPosition(x: number, y: number): boolean {",
            "lineNumber": 410,
            "isSignature": true
          },
          {
            "text": "\t\tbox.x = x;",
            "lineNumber": 411
          },
          {
            "text": "\t\tbox.y = y;",
            "lineNumber": 412
          },
          {
            "text": "\t\tfor (const node of data.nodes) {",
            "lineNumber": 413
          },
          {
            "text": "\t\t\tif (excludeIds.has(node.id)) continue;",
            "lineNumber": 414
          },
          {
            "text": "\t\t\t// Expand other node by buffer so we keep at least OUTPUT_COLLISION_BUFFER gap",
            "lineNumber": 415
          },
          {
            "text": "\t\t\tconst expanded = {",
            "lineNumber": 416
          },
          {
            "text": "\t\t\t\tx: node.x - OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 417
          },
          {
            "text": "\t\t\t\ty: node.y - OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 418
          },
          {
            "text": "\t\t\t\twidth: node.width + 2 * OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 419
          },
          {
            "text": "\t\t\t\theight: node.height + 2 * OUTPUT_COLLISION_BUFFER,",
            "lineNumber": 420
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 421
          },
          {
            "text": "\t\t\tif (rectanglesOverlap(box, expanded)) return false;",
            "lineNumber": 422
          },
          {
            "text": "\t\t}",
            "lineNumber": 423
          },
          {
            "text": "\t\treturn true;",
            "lineNumber": 424
          },
          {
            "text": "\t}",
            "lineNumber": 425,
            "isSignature": true
          },
          {
            "text": "\tfor (let dy = 0; dy &lt;= OUTPUT_COLLISION_MAX_VERTICAL; dy += OUTPUT_COLLISION_VERTICAL_STEP) {",
            "lineNumber": 426
          },
          {
            "text": "\t\tconst candidateY = defaultY + dy;",
            "lineNumber": 427
          },
          {
            "text": "\t\tfor (const dx of xOffsets()) {",
            "lineNumber": 428
          },
          {
            "text": "\t\t\tif (tryPosition(defaultX + dx, candidateY)) return { x: defaultX + dx, y: candidateY };",
            "lineNumber": 429
          },
          {
            "text": "\t\t}",
            "lineNumber": 430
          },
          {
            "text": "\t}",
            "lineNumber": 431
          },
          {
            "text": "\treturn { x: defaultX, y: defaultY };",
            "lineNumber": 432
          },
          {
            "text": "}",
            "lineNumber": 433,
            "isSignature": true
          },
          {
            "lineNumber": 434
          },
          {
            "text": "function* xOffsets(): Generator&lt;number&gt; {",
            "lineNumber": 435,
            "isSignature": true
          },
          {
            "text": "\tyield 0;",
            "lineNumber": 436
          },
          {
            "text": "}",
            "lineNumber": 441,
            "isSignature": true
          }
        ]
      },
      "score": 0.4020805358886719
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 457
          },
          "endPosition": {
            "line": 699,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\nconst { x: px, y: py } = (\n\t\t\tdata,\n\t\t\tsourceNode.id,\n\t\t\tpromptId,\n\t\t\tdefaultX,\n\t\t\tpromptDefaultY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tpromptExclude\n\t\t);\n\t\tconst promptColor = shadeColor(settings.colorGreen, 0.25);\n\n\t\tif (promptId) {\n\t\t\tconst pn = getNodeById(data, promptId);\n\t\t\tif (pn &amp;&amp; isTextNode(pn)) {\n\t\t\t\tconst updated = {\n\t\t\t\t\t...(pn as CanvasTextData),\n\t\t\t\t\ttext: fullPrompt,\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\tcolor: promptColor,\n\t\t\t\t};\n\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === promptId);\n\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t\t}\n\t\t\tconst hasEdge = data.edges.some(\n\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === promptId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT\n\t\t\t);\n\t\t\tif (!hasEdge) {\n\t\t\t\tdata.edges.push({\n\t\t\t\t\tid: randomId(),\n\t\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\t\ttoNode: promptId,\n\t\t\t\t\tlabel: EDGE_LABEL_PROMPT,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst newId = randomId();\n\t\t\tdata.nodes.push({\n\t\t\t\tid: newId,\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: fullPrompt,\n\t\t\t\tx: px,\n\t\t\t\ty: py,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tcolor: promptColor,\n\t\t\t} as CanvasTextData);\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: newId,\n\t\t\t\tlabel: EDGE_LABEL_PROMPT,\n\t\t\t});\n\t\t}\n\t}\n}\n\n/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */\nexport async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return { ok: false, message: \"Node not found.\" };\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 458,
                "column": 1
              },
              "endPosition": {
                "line": 465,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 460,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 461,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 463,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 464,
            "isSignature": true
          },
          {
            "text": "const { x: px, y: py } = (",
            "lineNumber": 611
          },
          {
            "text": "\t\t\tdata,",
            "lineNumber": 612
          },
          {
            "text": "\t\t\tsourceNode.id,",
            "lineNumber": 613
          },
          {
            "text": "\t\t\tpromptId,",
            "lineNumber": 614
          },
          {
            "text": "\t\t\tdefaultX,",
            "lineNumber": 615
          },
          {
            "text": "\t\t\tpromptDefaultY,",
            "lineNumber": 616
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 617
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 618
          },
          {
            "text": "\t\t\tpromptExclude",
            "lineNumber": 619
          },
          {
            "text": "\t\t);",
            "lineNumber": 620
          },
          {
            "text": "\t\tconst promptColor = shadeColor(settings.colorGreen, 0.25);",
            "lineNumber": 621
          },
          {
            "lineNumber": 622
          },
          {
            "text": "\t\tif (promptId) {",
            "lineNumber": 623
          },
          {
            "text": "\t\t\tconst pn = getNodeById(data, promptId);",
            "lineNumber": 624
          },
          {
            "text": "\t\t\tif (pn &amp;&amp; isTextNode(pn)) {",
            "lineNumber": 625
          },
          {
            "text": "\t\t\t\tconst updated = {",
            "lineNumber": 626
          },
          {
            "text": "\t\t\t\t\t...(pn as CanvasTextData),",
            "lineNumber": 627
          },
          {
            "text": "\t\t\t\t\ttext: fullPrompt,",
            "lineNumber": 628
          },
          {
            "text": "\t\t\t\t\twidth,",
            "lineNumber": 629
          },
          {
            "text": "\t\t\t\t\theight,",
            "lineNumber": 630
          },
          {
            "text": "\t\t\t\t\tcolor: promptColor,",
            "lineNumber": 631
          },
          {
            "text": "\t\t\t\t};",
            "lineNumber": 632
          },
          {
            "text": "\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === promptId);",
            "lineNumber": 633
          },
          {
            "text": "\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 634
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 635
          },
          {
            "text": "\t\t\tconst hasEdge = data.edges.some(",
            "lineNumber": 636
          },
          {
            "text": "\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === promptId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_PROMPT",
            "lineNumber": 637
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 638
          },
          {
            "text": "\t\t\tif (!hasEdge) {",
            "lineNumber": 639
          },
          {
            "text": "\t\t\t\tdata.edges.push({",
            "lineNumber": 640
          },
          {
            "text": "\t\t\t\t\tid: randomId(),",
            "lineNumber": 641
          },
          {
            "text": "\t\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 642
          },
          {
            "text": "\t\t\t\t\ttoNode: promptId,",
            "lineNumber": 643
          },
          {
            "text": "\t\t\t\t\tlabel: EDGE_LABEL_PROMPT,",
            "lineNumber": 644
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 645
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 646
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 647
          },
          {
            "text": "\t\t\tconst newId = randomId();",
            "lineNumber": 648
          },
          {
            "text": "\t\t\tdata.nodes.push({",
            "lineNumber": 649
          },
          {
            "text": "\t\t\t\tid: newId,",
            "lineNumber": 650
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 651
          },
          {
            "text": "\t\t\t\ttext: fullPrompt,",
            "lineNumber": 652
          },
          {
            "text": "\t\t\t\tx: px,",
            "lineNumber": 653
          },
          {
            "text": "\t\t\t\ty: py,",
            "lineNumber": 654
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 655
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 656
          },
          {
            "text": "\t\t\t\tcolor: promptColor,",
            "lineNumber": 657
          },
          {
            "text": "\t\t\t} as CanvasTextData);",
            "lineNumber": 658
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 659
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 660
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 661
          },
          {
            "text": "\t\t\t\ttoNode: newId,",
            "lineNumber": 662
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_PROMPT,",
            "lineNumber": 663
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 664
          },
          {
            "text": "\t\t}",
            "lineNumber": 665
          },
          {
            "text": "\t}",
            "lineNumber": 666
          },
          {
            "text": "}",
            "lineNumber": 667,
            "isSignature": true
          },
          {
            "lineNumber": 668
          },
          {
            "text": "/** Run a single node (for \"Run Node\" command). If parents are not run, runs chain to this node instead. */",
            "lineNumber": 669
          },
          {
            "text": "export async function runNode(",
            "lineNumber": 670,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 671,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 672,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 673,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 674,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 675,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 676,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 677
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 678
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 679
          },
          {
            "text": "\tif (!node) return { ok: false, message: \"Node not found.\" };",
            "lineNumber": 680
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 681
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 682
          },
          {
            "text": "}",
            "lineNumber": 700,
            "isSignature": true
          }
        ]
      },
      "score": 0.3958328068256378
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 369,
            "column": 1
          },
          "endPosition": {
            "line": 394,
            "column": 138
          }
        },
        "contents": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */\nconst OUTPUT_COLLISION_MAX_RADIUS = 500;\n/** Step (px) between candidate x positions when avoiding collisions. */\nconst OUTPUT_COLLISION_STEP = 80;\n/** Max vertical offset (px) below default placement when avoiding collisions. */\nconst OUTPUT_COLLISION_MAX_VERTICAL = 400;\n/** Step (px) between candidate y positions when avoiding vertical collisions. */\nconst OUTPUT_COLLISION_VERTICAL_STEP = 60;\n/** Min gap (px) between output box and other nodes; placement avoids coming within this distance. */\nconst OUTPUT_COLLISION_BUFFER = 24;\n\nfunction rectanglesOverlap(\n\ta: { x: number; y: number; width: number; height: number },\n\tb: { x: number; y: number; width: number; height: number }\n): boolean {\n\treturn !(\n\t\ta.x + a.width &lt;= b.x ||\n\t\tb.x + b.width &lt;= a.x ||\n\t\ta.y + a.height &lt;= b.y ||\n\t\tb.y + b.height &lt;= a.y\n\t);\n}\n\n/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Max horizontal offset (px) for output box collision avoidance; beyond this we allow overlap. */",
            "lineNumber": 372
          },
          {
            "text": "const OUTPUT_COLLISION_MAX_RADIUS = 500;",
            "lineNumber": 373
          },
          {
            "text": "/** Step (px) between candidate x positions when avoiding collisions. */",
            "lineNumber": 374
          },
          {
            "text": "const OUTPUT_COLLISION_STEP = 80;",
            "lineNumber": 375
          },
          {
            "text": "/** Max vertical offset (px) below default placement when avoiding collisions. */",
            "lineNumber": 376
          },
          {
            "text": "const OUTPUT_COLLISION_MAX_VERTICAL = 400;",
            "lineNumber": 377
          },
          {
            "text": "/** Step (px) between candidate y positions when avoiding vertical collisions. */",
            "lineNumber": 378
          },
          {
            "text": "const OUTPUT_COLLISION_VERTICAL_STEP = 60;",
            "lineNumber": 379
          },
          {
            "text": "/** Min gap (px) between output box and other nodes; placement avoids coming within this distance. */",
            "lineNumber": 380
          },
          {
            "text": "const OUTPUT_COLLISION_BUFFER = 24;",
            "lineNumber": 381
          },
          {
            "lineNumber": 382
          },
          {
            "text": "function rectanglesOverlap(",
            "lineNumber": 383,
            "isSignature": true
          },
          {
            "text": "\ta: { x: number; y: number; width: number; height: number },",
            "lineNumber": 384,
            "isSignature": true
          },
          {
            "text": "\tb: { x: number; y: number; width: number; height: number }",
            "lineNumber": 385,
            "isSignature": true
          },
          {
            "text": "): boolean {",
            "lineNumber": 386,
            "isSignature": true
          },
          {
            "text": "\treturn !(",
            "lineNumber": 387
          },
          {
            "text": "\t\ta.x + a.width &lt;= b.x ||",
            "lineNumber": 388
          },
          {
            "text": "\t\tb.x + b.width &lt;= a.x ||",
            "lineNumber": 389
          },
          {
            "text": "\t\ta.y + a.height &lt;= b.y ||",
            "lineNumber": 390
          },
          {
            "text": "\t\tb.y + b.height &lt;= a.y",
            "lineNumber": 391
          },
          {
            "text": "\t);",
            "lineNumber": 392
          },
          {
            "text": "}",
            "lineNumber": 393,
            "isSignature": true
          },
          {
            "lineNumber": 394
          },
          {
            "text": "/** Choose (x, y) for the output box to avoid overlapping other nodes. Tries default position, then shifts horizontally, then downward. */",
            "lineNumber": 395
          }
        ]
      },
      "score": 0.3835690915584564
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 454,
            "column": 1
          },
          "endPosition": {
            "line": 666,
            "column": 1
          }
        },
        "contents": "/** Create or replace the Green output node (and optional prompt/thinking nodes) and ensure edges from source. Mutates data only. */\nfunction ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\tconst { fullPrompt, thinking } = options;\n\tconst promptId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_PROMPT);\n\tconst thinkingId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING);\n\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);\n\n\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;\n\tconst width = Math.max(320, sourceNode.width);\n\tconst height = 180;\n\tconst defaultX = sourceNode.x;\n\tconst extraExclude = [promptId, thinkingId].filter((id): id is string =&gt; id != null);\n\n\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(\n\t\tdata,\n\t\tsourceNode.id,\n\t\toutId,\n\t\tdefaultX,\n\t\tdefaultY,\n\t\twidth,\n\t\theight,\n\t\textraExclude\n\t);\n\tconst greenColor = settings.colorGreen;\n\n\t// 1. Ensure output node\n\tlet resolvedOutputId: string;\n\tif (outId) {\n\t\tresolvedOutputId = outId;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Create or replace the Green output node (and optional prompt/thinking nodes) and ensure edges from source. Mutates data only. */",
            "lineNumber": 457
          },
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 460,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 461,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 463,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 464,
            "isSignature": true
          },
          {
            "text": "\tconst { fullPrompt, thinking } = options;",
            "lineNumber": 465
          },
          {
            "text": "\tconst promptId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_PROMPT);",
            "lineNumber": 466
          },
          {
            "text": "\tconst thinkingId = findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING);",
            "lineNumber": 467
          },
          {
            "text": "\tconst outId = findOutputNodeForSource(data, sourceNode.id, settings);",
            "lineNumber": 468
          },
          {
            "lineNumber": 469
          },
          {
            "text": "\tconst defaultY = sourceNode.y + sourceNode.height + GREEN_NODE_PADDING;",
            "lineNumber": 470
          },
          {
            "text": "\tconst width = Math.max(320, sourceNode.width);",
            "lineNumber": 471
          },
          {
            "text": "\tconst height = 180;",
            "lineNumber": 472
          },
          {
            "text": "\tconst defaultX = sourceNode.x;",
            "lineNumber": 473
          },
          {
            "text": "\tconst extraExclude = [promptId, thinkingId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 474
          },
          {
            "lineNumber": 475
          },
          {
            "text": "\tconst { x: chosenX, y: chosenY } = chooseOutputPositionXY(",
            "lineNumber": 476
          },
          {
            "text": "\t\tdata,",
            "lineNumber": 477
          },
          {
            "text": "\t\tsourceNode.id,",
            "lineNumber": 478
          },
          {
            "text": "\t\toutId,",
            "lineNumber": 479
          },
          {
            "text": "\t\tdefaultX,",
            "lineNumber": 480
          },
          {
            "text": "\t\tdefaultY,",
            "lineNumber": 481
          },
          {
            "text": "\t\twidth,",
            "lineNumber": 482
          },
          {
            "text": "\t\theight,",
            "lineNumber": 483
          },
          {
            "text": "\t\textraExclude",
            "lineNumber": 484
          },
          {
            "text": "\t);",
            "lineNumber": 485
          },
          {
            "text": "\tconst greenColor = settings.colorGreen;",
            "lineNumber": 486
          },
          {
            "lineNumber": 487
          },
          {
            "text": "\t// 1. Ensure output node",
            "lineNumber": 488
          },
          {
            "text": "\tlet resolvedOutputId: string;",
            "lineNumber": 489
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 490
          },
          {
            "text": "\t\tresolvedOutputId = outId;",
            "lineNumber": 491
          },
          {
            "text": "}",
            "lineNumber": 667,
            "isSignature": true
          }
        ]
      },
      "score": 0.35190099477767944
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 133,
            "column": 50
          },
          "endPosition": {
            "line": 168,
            "column": 125
          }
        },
        "contents": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */\nexport function findOutputNodeForSource(\n\tdata: CanvasData,\n\tsourceNodeId: string,\n\tsettings: ZettelPluginSettings\n): string | null {\n\tconst outputEdge = data.edges.find(\n\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t);\n\tif (outputEdge) return outputEdge.toNode;\n\tconst source = getNodeById(data, sourceNodeId);\n\tif (!source) return null;\n\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);\n\tif (!greenColor) return null;\n\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;\n\tconst toleranceAbove = 30; // allow small layout drift above default\n\tconst candidates: { id: string; centerY: number }[] = [];\n\tfor (const node of data.nodes) {\n\t\tif (node.id === sourceNodeId) continue;\n\t\tif (normalizeColor(node.color) !== greenColor) continue;\n\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;\n\t\tif (node.y &lt; expectedY - toleranceAbove || node.y &gt; expectedY + OUTPUT_POSITION_FALLBACK_MAX_Y) continue;\n\t\tconst centerY = node.y + (node.height ?? 0) / 2;\n\t\tcandidates.push({ id: node.id, centerY });\n\t}\n\tif (candidates.length === 0) return null;\n\t// Prefer the green whose center is closest to expectedY (avoids wrong match when sources are stacked)\n\tconst best = candidates.reduce((a, b) =&gt;\n\t\tMath.abs(a.centerY - expectedY) &lt;= Math.abs(b.centerY - expectedY) ? a : b\n\t);\n\treturn best.id;\n}\n\n/** Find the node id for an auxiliary edge from source with the given label (e.g. EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
            "lineNumber": 136
          },
          {
            "text": "export function findOutputNodeForSource(",
            "lineNumber": 137,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 138,
            "isSignature": true
          },
          {
            "text": "\tsourceNodeId: string,",
            "lineNumber": 139,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 140,
            "isSignature": true
          },
          {
            "text": "): string | null {",
            "lineNumber": 141,
            "isSignature": true
          },
          {
            "text": "\tconst outputEdge = data.edges.find(",
            "lineNumber": 142
          },
          {
            "text": "\t\t(e) =&gt; e.fromNode === sourceNodeId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 143
          },
          {
            "text": "\t);",
            "lineNumber": 144
          },
          {
            "text": "\tif (outputEdge) return outputEdge.toNode;",
            "lineNumber": 145
          },
          {
            "text": "\tconst source = getNodeById(data, sourceNodeId);",
            "lineNumber": 146
          },
          {
            "text": "\tif (!source) return null;",
            "lineNumber": 147
          },
          {
            "text": "\tconst greenColor = normalizeColor(settings.colorGreen as CanvasColor | undefined);",
            "lineNumber": 148
          },
          {
            "text": "\tif (!greenColor) return null;",
            "lineNumber": 149
          },
          {
            "text": "\tconst expectedY = source.y + source.height + GREEN_NODE_PADDING;",
            "lineNumber": 150
          },
          {
            "text": "\tconst toleranceAbove = 30; // allow small layout drift above default",
            "lineNumber": 151
          },
          {
            "text": "\tconst candidates: { id: string; centerY: number }[] = [];",
            "lineNumber": 152
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 153
          },
          {
            "text": "\t\tif (node.id === sourceNodeId) continue;",
            "lineNumber": 154
          },
          {
            "text": "\t\tif (normalizeColor(node.color) !== greenColor) continue;",
            "lineNumber": 155
          },
          {
            "text": "\t\tif (Math.abs(node.x - source.x) &gt; 50) continue;",
            "lineNumber": 156
          },
          {
            "text": "\t\tif (node.y &lt; expectedY - toleranceAbove || node.y &gt; expectedY + OUTPUT_POSITION_FALLBACK_MAX_Y) continue;",
            "lineNumber": 157
          },
          {
            "text": "\t\tconst centerY = node.y + (node.height ?? 0) / 2;",
            "lineNumber": 158
          },
          {
            "text": "\t\tcandidates.push({ id: node.id, centerY });",
            "lineNumber": 159
          },
          {
            "text": "\t}",
            "lineNumber": 160
          },
          {
            "text": "\tif (candidates.length === 0) return null;",
            "lineNumber": 161
          },
          {
            "text": "\t// Prefer the green whose center is closest to expectedY (avoids wrong match when sources are stacked)",
            "lineNumber": 162
          },
          {
            "text": "\tconst best = candidates.reduce((a, b) =&gt;",
            "lineNumber": 163
          },
          {
            "text": "\t\tMath.abs(a.centerY - expectedY) &lt;= Math.abs(b.centerY - expectedY) ? a : b",
            "lineNumber": 164
          },
          {
            "text": "\t);",
            "lineNumber": 165
          },
          {
            "text": "\treturn best.id;",
            "lineNumber": 166
          },
          {
            "text": "}",
            "lineNumber": 167,
            "isSignature": true
          },
          {
            "lineNumber": 168
          },
          {
            "text": "/** Find the node id for an auxiliary edge from source with the given label (e.g. EDGE_LABEL_PROMPT, EDGE_LABEL_THINKING). */",
            "lineNumber": 169
          }
        ]
      },
      "score": 0.296649694442749
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "column": 76
          },
          "endPosition": {
            "line": 43,
            "column": 99
          }
        },
        "contents": " from \"obsidian\";\nimport {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";\nimport {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";\nimport {CanvasTemplateModal} from \"./views/CanvasTemplateModal\";\nimport {duplicateCanvasTemplate, saveCanvasAsTemplate, isCanvasInTemplateFolder} from \"./canvas/canvasTemplates\";\nimport {\n\tdismissAllOutput as runnerDismissAllOutput,\n\tdismissOutput as runnerDismissOutput,\n\trunChain as runnerRunChain,\n\trunEntireCanvas as runnerRunEntireCanvas,\n\trunNode as runnerRunNode,\n} from \"./engine/runner\";\nimport {\n\tclearCanvasEdgeModeLabels,\n\tclearCanvasLegend,\n\tclearCanvasRoleLabels,\n\tsyncCanvasEdgeModeLabels,\n\tsyncCanvasRoleLabels,\n} from \"./canvas/canvasNodeLabels\";\nimport {hasOutputNodes, loadCanvasData, saveCanvasData} from \"./canvas/nodes\";\nimport type {CanvasData} from \"./canvas/types\";\nimport {EDGE_LABEL_OUTPUT} from \"./canvas/types\";\nimport {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";\nimport {getExample1CanvasData} from \"./tutorials/example1Data\";\nimport {getExample4CanvasData} from \"./tutorials/example4Data\";\n\n/** Layout constants: comment margins left/right, central lane for nodes, no overlap. */\nconst TUT_LEFT = 80;\nconst TUT_TOP = 50;\nconst TUT_WELCOME_W = 420;\nconst TUT_WELCOME_H = 118;\nconst TUT_WELCOME_BOTTOM_GAP = 70;\n/** Per-column: left comment margin | node lane | right comment margin. */\nconst TUT_COMMENT_W = 185;\nconst TUT_LANE_GAP = 22;\nconst TUT_NODE_LANE_W = 260;\nconst TUT_COL_TOTAL_W = TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP + TUT_COMMENT_W;\nconst TUT_COL_GAP = 85;\nconst TUT_NODE_H = 115;\nconst TUT_NODE_GAP = 58;\nconst TUT_LABEL_H = 88;\nconst TUT_GROUP_PAD = 18;\n\n/** Resolve role color from settings (fallback to default so tutorial always has a valid color). */",
        "signatures": {},
        "detailedLines": [
          {
            "text": " from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {DEFAULT_SETTINGS, ZettelPluginSettings, ZettelSettingTab} from \"./settings\";",
            "lineNumber": 2
          },
          {
            "text": "import {ZettelControlsView, ZETTEL_CONTROLS_VIEW_TYPE} from \"./views/ZettelControlsView\";",
            "lineNumber": 3
          },
          {
            "text": "import {CanvasTemplateModal} from \"./views/CanvasTemplateModal\";",
            "lineNumber": 4
          },
          {
            "text": "import {duplicateCanvasTemplate, saveCanvasAsTemplate, isCanvasInTemplateFolder} from \"./canvas/canvasTemplates\";",
            "lineNumber": 5
          },
          {
            "text": "import {",
            "lineNumber": 6
          },
          {
            "text": "\tdismissAllOutput as runnerDismissAllOutput,",
            "lineNumber": 7
          },
          {
            "text": "\tdismissOutput as runnerDismissOutput,",
            "lineNumber": 8
          },
          {
            "text": "\trunChain as runnerRunChain,",
            "lineNumber": 9
          },
          {
            "text": "\trunEntireCanvas as runnerRunEntireCanvas,",
            "lineNumber": 10
          },
          {
            "text": "\trunNode as runnerRunNode,",
            "lineNumber": 11
          },
          {
            "text": "} from \"./engine/runner\";",
            "lineNumber": 12
          },
          {
            "text": "import {",
            "lineNumber": 13
          },
          {
            "text": "\tclearCanvasEdgeModeLabels,",
            "lineNumber": 14
          },
          {
            "text": "\tclearCanvasLegend,",
            "lineNumber": 15
          },
          {
            "text": "\tclearCanvasRoleLabels,",
            "lineNumber": 16
          },
          {
            "text": "\tsyncCanvasEdgeModeLabels,",
            "lineNumber": 17
          },
          {
            "text": "\tsyncCanvasRoleLabels,",
            "lineNumber": 18
          },
          {
            "text": "} from \"./canvas/canvasNodeLabels\";",
            "lineNumber": 19
          },
          {
            "text": "import {hasOutputNodes, loadCanvasData, saveCanvasData} from \"./canvas/nodes\";",
            "lineNumber": 20
          },
          {
            "text": "import type {CanvasData} from \"./canvas/types\";",
            "lineNumber": 21
          },
          {
            "text": "import {EDGE_LABEL_OUTPUT} from \"./canvas/types\";",
            "lineNumber": 22
          },
          {
            "text": "import {getKernelForCanvas, terminateAllKernels, terminateKernel} from \"./engine/kernelManager\";",
            "lineNumber": 23
          },
          {
            "text": "import {getExample1CanvasData} from \"./tutorials/example1Data\";",
            "lineNumber": 24
          },
          {
            "text": "import {getExample4CanvasData} from \"./tutorials/example4Data\";",
            "lineNumber": 25
          },
          {
            "lineNumber": 26
          },
          {
            "text": "/** Layout constants: comment margins left/right, central lane for nodes, no overlap. */",
            "lineNumber": 27
          },
          {
            "text": "const TUT_LEFT = 80;",
            "lineNumber": 28
          },
          {
            "text": "const TUT_TOP = 50;",
            "lineNumber": 29
          },
          {
            "text": "const TUT_WELCOME_W = 420;",
            "lineNumber": 30
          },
          {
            "text": "const TUT_WELCOME_H = 118;",
            "lineNumber": 31
          },
          {
            "text": "const TUT_WELCOME_BOTTOM_GAP = 70;",
            "lineNumber": 32
          },
          {
            "text": "/** Per-column: left comment margin | node lane | right comment margin. */",
            "lineNumber": 33
          },
          {
            "text": "const TUT_COMMENT_W = 185;",
            "lineNumber": 34
          },
          {
            "text": "const TUT_LANE_GAP = 22;",
            "lineNumber": 35
          },
          {
            "text": "const TUT_NODE_LANE_W = 260;",
            "lineNumber": 36
          },
          {
            "text": "const TUT_COL_TOTAL_W = TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP + TUT_COMMENT_W;",
            "lineNumber": 37
          },
          {
            "text": "const TUT_COL_GAP = 85;",
            "lineNumber": 38
          },
          {
            "text": "const TUT_NODE_H = 115;",
            "lineNumber": 39
          },
          {
            "text": "const TUT_NODE_GAP = 58;",
            "lineNumber": 40
          },
          {
            "text": "const TUT_LABEL_H = 88;",
            "lineNumber": 41
          },
          {
            "text": "const TUT_GROUP_PAD = 18;",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "/** Resolve role color from settings (fallback to default so tutorial always has a valid color). */",
            "lineNumber": 44
          }
        ]
      },
      "score": 0.2957209348678589
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 87,
            "column": 1
          },
          "endPosition": {
            "line": 107,
            "column": 1
          }
        },
        "contents": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */\nexport function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));\n\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withY = fromIds\n\t\t.map((id) =&gt; {\n\t\t\tconst node = nodeMap.get(id);\n\t\t\treturn node ? { id, y: node.y } : null;\n\t\t})\n\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);\n\twithY.sort((a, b) =&gt; a.y - b.y);\n\treturn withY.map((x) =&gt; x.id);\n}\n\n/** Get node by id from canvas data. */\nexport function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {\n\t\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */",
            "lineNumber": 90
          },
          {
            "text": "export function getParentIdsSortedByY(nodeId: string, data: CanvasData): string[] {",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));",
            "lineNumber": 92
          },
          {
            "text": "\tconst fromIds = [...new Set(edges.map((e) =&gt; e.fromNode))];",
            "lineNumber": 93
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 94
          },
          {
            "text": "\tconst withY = fromIds",
            "lineNumber": 95
          },
          {
            "text": "\t\t.map((id) =&gt; {",
            "lineNumber": 96
          },
          {
            "text": "\t\t\tconst node = nodeMap.get(id);",
            "lineNumber": 97
          },
          {
            "text": "\t\t\treturn node ? { id, y: node.y } : null;",
            "lineNumber": 98
          },
          {
            "text": "\t\t})",
            "lineNumber": 99
          },
          {
            "text": "\t\t.filter((x): x is { id: string; y: number } =&gt; x != null);",
            "lineNumber": 100
          },
          {
            "text": "\twithY.sort((a, b) =&gt; a.y - b.y);",
            "lineNumber": 101
          },
          {
            "text": "\treturn withY.map((x) =&gt; x.id);",
            "lineNumber": 102
          },
          {
            "text": "}",
            "lineNumber": 103,
            "isSignature": true
          },
          {
            "lineNumber": 104
          },
          {
            "text": "/** Get node by id from canvas data. */",
            "lineNumber": 105
          },
          {
            "text": "export function getNodeById(data: CanvasData, id: string): AllCanvasNodeData | undefined {",
            "lineNumber": 106,
            "isSignature": true
          },
          {
            "text": "\t",
            "lineNumber": 107
          },
          {
            "text": "}",
            "lineNumber": 108,
            "isSignature": true
          }
        ]
      },
      "score": 0.2832637429237366
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 457
          },
          "endPosition": {
            "line": 666,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\n\n\tif (outId) {\n\t\tresolvedOutputId = outId;\n\t\tconst outNode = getNodeById(data, outId);\n\t\tif (outNode &amp;&amp; isTextNode(outNode)) {\n\t\t\tconst existingX = (outNode as CanvasTextData).x;\n\t\t\tconst existingY = (outNode as CanvasTextData).y;\n\t\t\tconst updated = {\n\t\t\t\t...(outNode as CanvasTextData),\n\t\t\t\ttext,\n\t\t\t\tx: existingX,\n\t\t\t\ty: existingY,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t};\n\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);\n\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t}\n\t\tconst hasOutputEdge = data.edges.some(\n\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT\n\t\t);\n\t\tif (!hasOutputEdge) {\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: outId,\n\t\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t\t});\n\t\t}\n\t} else {\n\t\tconst newNodeId = randomId();\n\t\tresolvedOutputId = newNodeId;\n\t\tconst newTextNode: CanvasTextData = {\n\t\t\tid: newNodeId,\n\t\t\ttype: \"text\",\n\t\t\ttext,\n\t\t\tx: chosenX,\n\t\t\ty: chosenY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tcolor: greenColor,\n\t\t};\n\t\tdata.nodes.push(newTextNode);\n\t\tdata.edges.push({\n\t\t\tid: randomId(),\n\t\t\tfromNode: sourceNode.id,\n\t\t\ttoNode: newNodeId,\n\t\t\tlabel: EDGE_LABEL_OUTPUT,\n\t\t});\n\t}\n\n\tconst outputNode = getNodeById(data, resolvedOutputId);\n\tconst outputY = outputNode &amp;&amp; \"y\" in outputNode ? (outputNode as { y: number }).y : chosenY;\n\n\t// 2. Ensure thinking node (above output) when setting on and thinking present\n\tif (settings.showThinkingNode &amp;&amp; thinking != null &amp;&amp; thinking.length &gt; 0) {\n\t\tconst thinkingDefaultY = outputY - height - GREEN_NODE_PADDING;\n\t\tconst thinkingExclude = [sourceNode.id, resolvedOutputId, promptId].filter((id): id is string =&gt; id != null);\n\t\tconst { x: tx, y: ty } = chooseOutputPositionXY(\n\t\t\tdata,\n\t\t\tsourceNode.id,\n\t\t\tthinkingId,\n\t\t\tdefaultX,\n\t\t\tthinkingDefaultY,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tthinkingExclude\n\t\t);\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 458,
                "column": 1
              },
              "endPosition": {
                "line": 465,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 460,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 461,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 463,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 464,
            "isSignature": true
          },
          {
            "lineNumber": 489
          },
          {
            "text": "\tif (outId) {",
            "lineNumber": 490
          },
          {
            "text": "\t\tresolvedOutputId = outId;",
            "lineNumber": 491
          },
          {
            "text": "\t\tconst outNode = getNodeById(data, outId);",
            "lineNumber": 492
          },
          {
            "text": "\t\tif (outNode &amp;&amp; isTextNode(outNode)) {",
            "lineNumber": 493
          },
          {
            "text": "\t\t\tconst existingX = (outNode as CanvasTextData).x;",
            "lineNumber": 494
          },
          {
            "text": "\t\t\tconst existingY = (outNode as CanvasTextData).y;",
            "lineNumber": 495
          },
          {
            "text": "\t\t\tconst updated = {",
            "lineNumber": 496
          },
          {
            "text": "\t\t\t\t...(outNode as CanvasTextData),",
            "lineNumber": 497
          },
          {
            "text": "\t\t\t\ttext,",
            "lineNumber": 498
          },
          {
            "text": "\t\t\t\tx: existingX,",
            "lineNumber": 499
          },
          {
            "text": "\t\t\t\ty: existingY,",
            "lineNumber": 500
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 501
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 502
          },
          {
            "text": "\t\t\t};",
            "lineNumber": 503
          },
          {
            "text": "\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === outId);",
            "lineNumber": 504
          },
          {
            "text": "\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 505
          },
          {
            "text": "\t\t}",
            "lineNumber": 506
          },
          {
            "text": "\t\tconst hasOutputEdge = data.edges.some(",
            "lineNumber": 507
          },
          {
            "text": "\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === outId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_OUTPUT",
            "lineNumber": 508
          },
          {
            "text": "\t\t);",
            "lineNumber": 509
          },
          {
            "text": "\t\tif (!hasOutputEdge) {",
            "lineNumber": 510
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 511
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 512
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 513
          },
          {
            "text": "\t\t\t\ttoNode: outId,",
            "lineNumber": 514
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 515
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 516
          },
          {
            "text": "\t\t}",
            "lineNumber": 517
          },
          {
            "text": "\t} else {",
            "lineNumber": 518
          },
          {
            "text": "\t\tconst newNodeId = randomId();",
            "lineNumber": 519
          },
          {
            "text": "\t\tresolvedOutputId = newNodeId;",
            "lineNumber": 520
          },
          {
            "text": "\t\tconst newTextNode: CanvasTextData = {",
            "lineNumber": 521
          },
          {
            "text": "\t\t\tid: newNodeId,",
            "lineNumber": 522
          },
          {
            "text": "\t\t\ttype: \"text\",",
            "lineNumber": 523
          },
          {
            "text": "\t\t\ttext,",
            "lineNumber": 524
          },
          {
            "text": "\t\t\tx: chosenX,",
            "lineNumber": 525
          },
          {
            "text": "\t\t\ty: chosenY,",
            "lineNumber": 526
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 527
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 528
          },
          {
            "text": "\t\t\tcolor: greenColor,",
            "lineNumber": 529
          },
          {
            "text": "\t\t};",
            "lineNumber": 530
          },
          {
            "text": "\t\tdata.nodes.push(newTextNode);",
            "lineNumber": 531
          },
          {
            "text": "\t\tdata.edges.push({",
            "lineNumber": 532
          },
          {
            "text": "\t\t\tid: randomId(),",
            "lineNumber": 533
          },
          {
            "text": "\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 534
          },
          {
            "text": "\t\t\ttoNode: newNodeId,",
            "lineNumber": 535
          },
          {
            "text": "\t\t\tlabel: EDGE_LABEL_OUTPUT,",
            "lineNumber": 536
          },
          {
            "text": "\t\t});",
            "lineNumber": 537
          },
          {
            "text": "\t}",
            "lineNumber": 538
          },
          {
            "lineNumber": 539
          },
          {
            "text": "\tconst outputNode = getNodeById(data, resolvedOutputId);",
            "lineNumber": 540
          },
          {
            "text": "\tconst outputY = outputNode &amp;&amp; \"y\" in outputNode ? (outputNode as { y: number }).y : chosenY;",
            "lineNumber": 541
          },
          {
            "lineNumber": 542
          },
          {
            "text": "\t// 2. Ensure thinking node (above output) when setting on and thinking present",
            "lineNumber": 543
          },
          {
            "text": "\tif (settings.showThinkingNode &amp;&amp; thinking != null &amp;&amp; thinking.length &gt; 0) {",
            "lineNumber": 544
          },
          {
            "text": "\t\tconst thinkingDefaultY = outputY - height - GREEN_NODE_PADDING;",
            "lineNumber": 545
          },
          {
            "text": "\t\tconst thinkingExclude = [sourceNode.id, resolvedOutputId, promptId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 546
          },
          {
            "text": "\t\tconst { x: tx, y: ty } = chooseOutputPositionXY(",
            "lineNumber": 547
          },
          {
            "text": "\t\t\tdata,",
            "lineNumber": 548
          },
          {
            "text": "\t\t\tsourceNode.id,",
            "lineNumber": 549
          },
          {
            "text": "\t\t\tthinkingId,",
            "lineNumber": 550
          },
          {
            "text": "\t\t\tdefaultX,",
            "lineNumber": 551
          },
          {
            "text": "\t\t\tthinkingDefaultY,",
            "lineNumber": 552
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 553
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 554
          },
          {
            "text": "\t\t\tthinkingExclude",
            "lineNumber": 555
          },
          {
            "text": "\t\t);",
            "lineNumber": 556
          },
          {
            "text": "}",
            "lineNumber": 667,
            "isSignature": true
          }
        ]
      },
      "score": 0.2631695866584778
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 67,
            "column": 1
          },
          "endPosition": {
            "line": 89,
            "column": 106
          }
        },
        "contents": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y then x (higher, then left-most). Excludes output/prompt/thinking edges. */\nexport function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {\n\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));\n\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));\n\tconst withPos = edges.map((e) =&gt; {\n\t\tconst parent = nodeMap.get(e.fromNode);\n\t\tconst y = parent?.y ?? 0;\n\t\tconst x = parent?.x ?? 0;\n\t\treturn {\n\t\t\tparentId: e.fromNode,\n\t\t\tedge: e,\n\t\t\tvariableName: parseEdgeVariableName(e.label),\n\t\t\ty,\n\t\t\tx,\n\t\t};\n\t});\n\twithPos.sort((a, b) =&gt; (a.y !== b.y ? a.y - b.y : a.x - b.x));\n\treturn withPos.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));\n}\n\n/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Get incoming edges for a node with parent id and variable name, sorted by parent y then x (higher, then left-most). Excludes output/prompt/thinking edges. */",
            "lineNumber": 70
          },
          {
            "text": "export function getIncomingEdgesWithLabels(nodeId: string, data: CanvasData): IncomingEdgeInfo[] {",
            "lineNumber": 71,
            "isSignature": true
          },
          {
            "text": "\tconst edges = data.edges.filter((e) =&gt; e.toNode === nodeId &amp;&amp; !isAuxiliaryEdge(e));",
            "lineNumber": 72
          },
          {
            "text": "\tconst nodeMap = new Map(data.nodes.map((n) =&gt; [n.id, n]));",
            "lineNumber": 73
          },
          {
            "text": "\tconst withPos = edges.map((e) =&gt; {",
            "lineNumber": 74
          },
          {
            "text": "\t\tconst parent = nodeMap.get(e.fromNode);",
            "lineNumber": 75
          },
          {
            "text": "\t\tconst y = parent?.y ?? 0;",
            "lineNumber": 76
          },
          {
            "text": "\t\tconst x = parent?.x ?? 0;",
            "lineNumber": 77
          },
          {
            "text": "\t\treturn {",
            "lineNumber": 78
          },
          {
            "text": "\t\t\tparentId: e.fromNode,",
            "lineNumber": 79
          },
          {
            "text": "\t\t\tedge: e,",
            "lineNumber": 80
          },
          {
            "text": "\t\t\tvariableName: parseEdgeVariableName(e.label),",
            "lineNumber": 81
          },
          {
            "text": "\t\t\ty,",
            "lineNumber": 82
          },
          {
            "text": "\t\t\tx,",
            "lineNumber": 83
          },
          {
            "text": "\t\t};",
            "lineNumber": 84
          },
          {
            "text": "\t});",
            "lineNumber": 85
          },
          {
            "text": "\twithPos.sort((a, b) =&gt; (a.y !== b.y ? a.y - b.y : a.x - b.x));",
            "lineNumber": 86
          },
          {
            "text": "\treturn withPos.map(({ parentId, edge, variableName }) =&gt; ({ parentId, edge, variableName }));",
            "lineNumber": 87
          },
          {
            "text": "}",
            "lineNumber": 88,
            "isSignature": true
          },
          {
            "lineNumber": 89
          },
          {
            "text": "/** Get parent node IDs for a node, sorted by y (top to bottom). Excludes output/prompt/thinking edges. */",
            "lineNumber": 90
          }
        ]
      },
      "score": 0.25481000542640686
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 457
          },
          "endPosition": {
            "line": 666,
            "column": 1
          }
        },
        "contents": "function ensureOutputNodeAndEdge(\n\tdata: CanvasData,\n\tsourceNode: AllCanvasNodeData,\n\ttext: string,\n\tsettings: ZettelPluginSettings,\n\toptions: EnsureOutputOptions = {}\n): void {\nconst { x: tx, y: ty } = \n\n\t\t\twidth,\n\t\t\theight,\n\t\t\tthinkingExclude\n\t\t);\n\t\tconst thinkingColor = shadeColor(settings.colorGreen, 0.15);\n\n\t\tif (thinkingId) {\n\t\t\tconst tn = getNodeById(data, thinkingId);\n\t\t\tif (tn &amp;&amp; isTextNode(tn)) {\n\t\t\t\tconst updated = {\n\t\t\t\t\t...(tn as CanvasTextData),\n\t\t\t\t\ttext: thinking,\n\t\t\t\t\twidth,\n\t\t\t\t\theight,\n\t\t\t\t\tcolor: thinkingColor,\n\t\t\t\t};\n\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === thinkingId);\n\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;\n\t\t\t}\n\t\t\tconst hasEdge = data.edges.some(\n\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === thinkingId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING\n\t\t\t);\n\t\t\tif (!hasEdge) {\n\t\t\t\tdata.edges.push({\n\t\t\t\t\tid: randomId(),\n\t\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\t\ttoNode: thinkingId,\n\t\t\t\t\tlabel: EDGE_LABEL_THINKING,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst newId = randomId();\n\t\t\tdata.nodes.push({\n\t\t\t\tid: newId,\n\t\t\t\ttype: \"text\",\n\t\t\t\ttext: thinking,\n\t\t\t\tx: tx,\n\t\t\t\ty: ty,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tcolor: thinkingColor,\n\t\t\t} as CanvasTextData);\n\t\t\tdata.edges.push({\n\t\t\t\tid: randomId(),\n\t\t\t\tfromNode: sourceNode.id,\n\t\t\t\ttoNode: newId,\n\t\t\t\tlabel: EDGE_LABEL_THINKING,\n\t\t\t});\n\t\t}\n\t}\n\n\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present\n\tif (settings.showPromptInOutput &amp;&amp; fullPrompt != null &amp;&amp; fullPrompt.length &gt; 0) {\n\t\tconst thinkingNodeId = settings.showThinkingNode &amp;&amp; thinking ? findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING) : null;\n\t\tconst anchorNode = thinkingNodeId ? getNodeById(data, thinkingNodeId) : outputNode;\n\t\tconst anchorY = anchorNode &amp;&amp; \"y\" in anchorNode ? (anchorNode as { y: number }).y : outputY;\n\t\tconst promptDefaultY = anchorY - height - GREEN_NODE_PADDING;\n\t\tconst promptExclude = [sourceNode.id, resolvedOutputId, thinkingId, promptId].filter((id): id is string =&gt; id != null);\n\t\tconst { x: px, y: py } = chooseOutputPositionXY(\n\t\t\tdata,\n\t\t\tsourceNode.id,\n\t\t\tpromptId,\n\t\t\tdefaultX,\n\t\t\tpromptDefaultY,\n\t\t\twidth\n;\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 458,
                "column": 1
              },
              "endPosition": {
                "line": 465,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function ensureOutputNodeAndEdge(",
            "lineNumber": 458,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 459,
            "isSignature": true
          },
          {
            "text": "\tsourceNode: AllCanvasNodeData,",
            "lineNumber": 460,
            "isSignature": true
          },
          {
            "text": "\ttext: string,",
            "lineNumber": 461,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 462,
            "isSignature": true
          },
          {
            "text": "\toptions: EnsureOutputOptions = {}",
            "lineNumber": 463,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 464,
            "isSignature": true
          },
          {
            "text": "const { x: tx, y: ty } = ",
            "lineNumber": 547
          },
          {
            "lineNumber": 552
          },
          {
            "text": "\t\t\twidth,",
            "lineNumber": 553
          },
          {
            "text": "\t\t\theight,",
            "lineNumber": 554
          },
          {
            "text": "\t\t\tthinkingExclude",
            "lineNumber": 555
          },
          {
            "text": "\t\t);",
            "lineNumber": 556
          },
          {
            "text": "\t\tconst thinkingColor = shadeColor(settings.colorGreen, 0.15);",
            "lineNumber": 557
          },
          {
            "lineNumber": 558
          },
          {
            "text": "\t\tif (thinkingId) {",
            "lineNumber": 559
          },
          {
            "text": "\t\t\tconst tn = getNodeById(data, thinkingId);",
            "lineNumber": 560
          },
          {
            "text": "\t\t\tif (tn &amp;&amp; isTextNode(tn)) {",
            "lineNumber": 561
          },
          {
            "text": "\t\t\t\tconst updated = {",
            "lineNumber": 562
          },
          {
            "text": "\t\t\t\t\t...(tn as CanvasTextData),",
            "lineNumber": 563
          },
          {
            "text": "\t\t\t\t\ttext: thinking,",
            "lineNumber": 564
          },
          {
            "text": "\t\t\t\t\twidth,",
            "lineNumber": 565
          },
          {
            "text": "\t\t\t\t\theight,",
            "lineNumber": 566
          },
          {
            "text": "\t\t\t\t\tcolor: thinkingColor,",
            "lineNumber": 567
          },
          {
            "text": "\t\t\t\t};",
            "lineNumber": 568
          },
          {
            "text": "\t\t\t\tconst idx = data.nodes.findIndex((n) =&gt; n.id === thinkingId);",
            "lineNumber": 569
          },
          {
            "text": "\t\t\t\tif (idx &gt;= 0) data.nodes[idx] = updated;",
            "lineNumber": 570
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 571
          },
          {
            "text": "\t\t\tconst hasEdge = data.edges.some(",
            "lineNumber": 572
          },
          {
            "text": "\t\t\t\t(e) =&gt; e.fromNode === sourceNode.id &amp;&amp; e.toNode === thinkingId &amp;&amp; parseEdgeVariableName(e.label) === EDGE_LABEL_THINKING",
            "lineNumber": 573
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 574
          },
          {
            "text": "\t\t\tif (!hasEdge) {",
            "lineNumber": 575
          },
          {
            "text": "\t\t\t\tdata.edges.push({",
            "lineNumber": 576
          },
          {
            "text": "\t\t\t\t\tid: randomId(),",
            "lineNumber": 577
          },
          {
            "text": "\t\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 578
          },
          {
            "text": "\t\t\t\t\ttoNode: thinkingId,",
            "lineNumber": 579
          },
          {
            "text": "\t\t\t\t\tlabel: EDGE_LABEL_THINKING,",
            "lineNumber": 580
          },
          {
            "text": "\t\t\t\t});",
            "lineNumber": 581
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 582
          },
          {
            "text": "\t\t} else {",
            "lineNumber": 583
          },
          {
            "text": "\t\t\tconst newId = randomId();",
            "lineNumber": 584
          },
          {
            "text": "\t\t\tdata.nodes.push({",
            "lineNumber": 585
          },
          {
            "text": "\t\t\t\tid: newId,",
            "lineNumber": 586
          },
          {
            "text": "\t\t\t\ttype: \"text\",",
            "lineNumber": 587
          },
          {
            "text": "\t\t\t\ttext: thinking,",
            "lineNumber": 588
          },
          {
            "text": "\t\t\t\tx: tx,",
            "lineNumber": 589
          },
          {
            "text": "\t\t\t\ty: ty,",
            "lineNumber": 590
          },
          {
            "text": "\t\t\t\twidth,",
            "lineNumber": 591
          },
          {
            "text": "\t\t\t\theight,",
            "lineNumber": 592
          },
          {
            "text": "\t\t\t\tcolor: thinkingColor,",
            "lineNumber": 593
          },
          {
            "text": "\t\t\t} as CanvasTextData);",
            "lineNumber": 594
          },
          {
            "text": "\t\t\tdata.edges.push({",
            "lineNumber": 595
          },
          {
            "text": "\t\t\t\tid: randomId(),",
            "lineNumber": 596
          },
          {
            "text": "\t\t\t\tfromNode: sourceNode.id,",
            "lineNumber": 597
          },
          {
            "text": "\t\t\t\ttoNode: newId,",
            "lineNumber": 598
          },
          {
            "text": "\t\t\t\tlabel: EDGE_LABEL_THINKING,",
            "lineNumber": 599
          },
          {
            "text": "\t\t\t});",
            "lineNumber": 600
          },
          {
            "text": "\t\t}",
            "lineNumber": 601
          },
          {
            "text": "\t}",
            "lineNumber": 602
          },
          {
            "lineNumber": 603
          },
          {
            "text": "\t// 3. Ensure prompt node (above thinking or output) when setting on and fullPrompt present",
            "lineNumber": 604
          },
          {
            "text": "\tif (settings.showPromptInOutput &amp;&amp; fullPrompt != null &amp;&amp; fullPrompt.length &gt; 0) {",
            "lineNumber": 605
          },
          {
            "text": "\t\tconst thinkingNodeId = settings.showThinkingNode &amp;&amp; thinking ? findAuxiliaryNodeForSource(data, sourceNode.id, EDGE_LABEL_THINKING) : null;",
            "lineNumber": 606
          },
          {
            "text": "\t\tconst anchorNode = thinkingNodeId ? getNodeById(data, thinkingNodeId) : outputNode;",
            "lineNumber": 607
          },
          {
            "text": "\t\tconst anchorY = anchorNode &amp;&amp; \"y\" in anchorNode ? (anchorNode as { y: number }).y : outputY;",
            "lineNumber": 608
          },
          {
            "text": "\t\tconst promptDefaultY = anchorY - height - GREEN_NODE_PADDING;",
            "lineNumber": 609
          },
          {
            "text": "\t\tconst promptExclude = [sourceNode.id, resolvedOutputId, thinkingId, promptId].filter((id): id is string =&gt; id != null);",
            "lineNumber": 610
          },
          {
            "text": "\t\tconst { x: px, y: py } = chooseOutputPositionXY(",
            "lineNumber": 611
          },
          {
            "text": "\t\t\tdata,",
            "lineNumber": 612
          },
          {
            "text": "\t\t\tsourceNode.id,",
            "lineNumber": 613
          },
          {
            "text": "\t\t\tpromptId,",
            "lineNumber": 614
          },
          {
            "text": "\t\t\tdefaultX,",
            "lineNumber": 615
          },
          {
            "text": "\t\t\tpromptDefaultY,",
            "lineNumber": 616
          },
          {
            "text": "\t\t\twidth",
            "lineNumber": 617
          },
          {
            "text": ";",
            "lineNumber": 620
          },
          {
            "text": "}",
            "lineNumber": 667,
            "isSignature": true
          }
        ]
      },
      "score": 0.2501274049282074
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 264,
            "column": 1
          },
          "endPosition": {
            "line": 369,
            "column": 1
          }
        },
        "contents": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */\nasync function runSingleNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasKey: string,\n\tcanvasFilePath: string,\n\tdata: CanvasData,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;string&gt; {\n\tconst node = getNodeById(data, nodeId);\n\tif (!node) return \"\";\n\tconst role = getNodeRole(node, settings);\n\tif (!role || role === \"yellow\" || role === \"green\") {\n\t\t// Yellow = text (input pass-through): use node content as result\n\t\tif (role === \"yellow\") {\n\t\t\tconst content = await getNodeContent(node, app.vault);\n\t\t\tsetNodeResult(canvasKey, nodeId, content);\n\t\t\treturn content;\n\t\t}\n\t\treturn \"\";\n\t}\n\t// For Python (blue) text nodes, auto-wrap content in &#96;&#96;&#96;python ... &#96;&#96;&#96; so # comments render correctly\n\tif (role === \"blue\" &amp;&amp; isTextNode(node)) {\n\t\tconst raw = getTextNodeContent(node as CanvasTextData);\n\t\tif (!isPythonCodeFenced(raw)) {\n\t\t\t(node as CanvasTextData).text = ensurePythonCodeFence(raw);\n\t\t\tliveCanvas?.setData?.(data);\n\t\t\tif (liveCanvas?.requestSave) liveCanvas.requestSave();\n\t\t\tawait saveCanvasData(app.vault, canvasFilePath, data);\n\t\t}\n\t}\n\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);\n\tconst nodeInput = await getNodeContent(node, app.vault);\n\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(\n\t\tcanvasKey,\n\t\tnodeInput,\n\t\tincoming\n\t);\n\tconst fullPrompt =\n\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;\n\n\tif (role === \"orange\") {\n\t\tconst model = settings.ollamaOrangeModel || \"llama2\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Run a single node: get input + parent context (concatenate or {{var:name}}), call LLM or Python, store result. */",
            "lineNumber": 267
          },
          {
            "text": "async function runSingleNode(",
            "lineNumber": 268,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 269,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 270,
            "isSignature": true
          },
          {
            "text": "\tcanvasKey: string,",
            "lineNumber": 271,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 272,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 273,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 274,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 275,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;string&gt; {",
            "lineNumber": 276,
            "isSignature": true
          },
          {
            "text": "\tconst node = getNodeById(data, nodeId);",
            "lineNumber": 277
          },
          {
            "text": "\tif (!node) return \"\";",
            "lineNumber": 278
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 279
          },
          {
            "text": "\tif (!role || role === \"yellow\" || role === \"green\") {",
            "lineNumber": 280
          },
          {
            "text": "\t\t// Yellow = text (input pass-through): use node content as result",
            "lineNumber": 281
          },
          {
            "text": "\t\tif (role === \"yellow\") {",
            "lineNumber": 282
          },
          {
            "text": "\t\t\tconst content = await getNodeContent(node, app.vault);",
            "lineNumber": 283
          },
          {
            "text": "\t\t\tsetNodeResult(canvasKey, nodeId, content);",
            "lineNumber": 284
          },
          {
            "text": "\t\t\treturn content;",
            "lineNumber": 285
          },
          {
            "text": "\t\t}",
            "lineNumber": 286
          },
          {
            "text": "\t\treturn \"\";",
            "lineNumber": 287
          },
          {
            "text": "\t}",
            "lineNumber": 288
          },
          {
            "text": "\t// For Python (blue) text nodes, auto-wrap content in &#96;&#96;&#96;python ... &#96;&#96;&#96; so # comments render correctly",
            "lineNumber": 289
          },
          {
            "text": "\tif (role === \"blue\" &amp;&amp; isTextNode(node)) {",
            "lineNumber": 290
          },
          {
            "text": "\t\tconst raw = getTextNodeContent(node as CanvasTextData);",
            "lineNumber": 291
          },
          {
            "text": "\t\tif (!isPythonCodeFenced(raw)) {",
            "lineNumber": 292
          },
          {
            "text": "\t\t\t(node as CanvasTextData).text = ensurePythonCodeFence(raw);",
            "lineNumber": 293
          },
          {
            "text": "\t\t\tliveCanvas?.setData?.(data);",
            "lineNumber": 294
          },
          {
            "text": "\t\t\tif (liveCanvas?.requestSave) liveCanvas.requestSave();",
            "lineNumber": 295
          },
          {
            "text": "\t\t\tawait saveCanvasData(app.vault, canvasFilePath, data);",
            "lineNumber": 296
          },
          {
            "text": "\t\t}",
            "lineNumber": 297
          },
          {
            "text": "\t}",
            "lineNumber": 298
          },
          {
            "text": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);",
            "lineNumber": 299
          },
          {
            "text": "\tconst nodeInput = await getNodeContent(node, app.vault);",
            "lineNumber": 300
          },
          {
            "text": "\tconst { concatenatedPart, template, edgeModes } = buildInputWithVariables(",
            "lineNumber": 301
          },
          {
            "text": "\t\tcanvasKey,",
            "lineNumber": 302
          },
          {
            "text": "\t\tnodeInput,",
            "lineNumber": 303
          },
          {
            "text": "\t\tincoming",
            "lineNumber": 304
          },
          {
            "text": "\t);",
            "lineNumber": 305
          },
          {
            "text": "\tconst fullPrompt =",
            "lineNumber": 306
          },
          {
            "text": "\t\tconcatenatedPart.length &gt; 0 ? &#96;${concatenatedPart}\\n\\n---\\n\\n${template}&#96; : template;",
            "lineNumber": 307
          },
          {
            "lineNumber": 308
          },
          {
            "text": "\tif (role === \"orange\") {",
            "lineNumber": 309
          },
          {
            "text": "\t\tconst model = settings.ollamaOrangeModel || \"llama2\";",
            "lineNumber": 310
          },
          {
            "text": "}",
            "lineNumber": 370,
            "isSignature": true
          }
        ]
      },
      "score": 0.23896260559558868
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 97
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\n\n\tconst nodes: CanvasData[\"nodes\"] = [\n\t\t// Groups first (render behind)\n\t\tgroupWelcome,\n\t\tgroupCol1,\n\t\tgroupCol2,\n\t\tgroupCol3,\n\t\tgroupCol4,\n\t\tgroupCol5,\n\t\tgroupCol6,\n\t\t// Welcome: plain text (no color = no role; not connected, does not add to prompt)\n\t\tn(welcome, \"Welcome to Zettel Thinking Board. Each column is a separate showcase. Nodes run top to bottom. Right-click a card → Run node or Run chain. Uncolored or unused-color cards are not connected to any node and do not add to the prompt.\", TUT_LEFT, welcomeY, \"\", TUT_WELCOME_W, 132),\n\n\t\t// Column 1: label = plain text; nodes in lane have roles\n\t\tn(lab1, \"Primary model: sends prompt to Ollama. Set the model in Zettel Controls.\", commentLeftX(col1), orangeY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(orangeNode, \"What is 2+2? Reply in one sentence.\", laneNodeX(col1, 0), orangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(orangeOut, \"\", laneNodeX(col1, LANE_OFFSET), orangeOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 2\n\t\tn(lab2a, \"Secondary model (same idea, different model).\", commentLeftX(col2), purpleY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(purpleNode, \"Summarize in 5 words: The quick brown fox jumps.\", laneNodeX(col2, 0), purpleY, cPurple, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(purpleOut, \"\", laneNodeX(col2, LANE_OFFSET), purpleOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(lab2b, \"Text: input text; passed to next node as-is (pass-through).\", commentRightX(col2), yellowY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(yellowNode, \"I'm input text. My text is passed to the next node (concatenated).\", laneNodeX(col2, 0), yellowY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(lab2c, \"Python: runs code. Use variable input for parent text.\", commentLeftX(col2), blueY, \"\", TUT_COMMENT_W, TUT_LABEL_H),\n\t\tn(blueNode, \"print('Python says:', (input or '')[:80] or '(no input)')\\n# input = text from parent\", laneNodeX(col2, LANE_OFFSET), blueY, cBlue, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 3\n\t\tn\n,\n\t];\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 98,
                "column": 1
              },
              "endPosition": {
                "line": 99,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "lineNumber": 257
          },
          {
            "lineNumber": 258
          },
          {
            "text": "\tconst nodes: CanvasData[\"nodes\"] = [",
            "lineNumber": 259
          },
          {
            "text": "\t\t// Groups first (render behind)",
            "lineNumber": 260
          },
          {
            "text": "\t\tgroupWelcome,",
            "lineNumber": 261
          },
          {
            "text": "\t\tgroupCol1,",
            "lineNumber": 262
          },
          {
            "text": "\t\tgroupCol2,",
            "lineNumber": 263
          },
          {
            "text": "\t\tgroupCol3,",
            "lineNumber": 264
          },
          {
            "text": "\t\tgroupCol4,",
            "lineNumber": 265
          },
          {
            "text": "\t\tgroupCol5,",
            "lineNumber": 266
          },
          {
            "text": "\t\tgroupCol6,",
            "lineNumber": 267
          },
          {
            "text": "\t\t// Welcome: plain text (no color = no role; not connected, does not add to prompt)",
            "lineNumber": 268
          },
          {
            "text": "\t\tn(welcome, \"Welcome to Zettel Thinking Board. Each column is a separate showcase. Nodes run top to bottom. Right-click a card → Run node or Run chain. Uncolored or unused-color cards are not connected to any node and do not add to the prompt.\", TUT_LEFT, welcomeY, \"\", TUT_WELCOME_W, 132),",
            "lineNumber": 269
          },
          {
            "lineNumber": 270
          },
          {
            "text": "\t\t// Column 1: label = plain text; nodes in lane have roles",
            "lineNumber": 271
          },
          {
            "text": "\t\tn(lab1, \"Primary model: sends prompt to Ollama. Set the model in Zettel Controls.\", commentLeftX(col1), orangeY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 272
          },
          {
            "text": "\t\tn(orangeNode, \"What is 2+2? Reply in one sentence.\", laneNodeX(col1, 0), orangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 273
          },
          {
            "text": "\t\tn(orangeOut, \"\", laneNodeX(col1, LANE_OFFSET), orangeOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 274
          },
          {
            "lineNumber": 275
          },
          {
            "text": "\t\t// Column 2",
            "lineNumber": 276
          },
          {
            "text": "\t\tn(lab2a, \"Secondary model (same idea, different model).\", commentLeftX(col2), purpleY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 277
          },
          {
            "text": "\t\tn(purpleNode, \"Summarize in 5 words: The quick brown fox jumps.\", laneNodeX(col2, 0), purpleY, cPurple, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 278
          },
          {
            "text": "\t\tn(purpleOut, \"\", laneNodeX(col2, LANE_OFFSET), purpleOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 279
          },
          {
            "text": "\t\tn(lab2b, \"Text: input text; passed to next node as-is (pass-through).\", commentRightX(col2), yellowY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 280
          },
          {
            "text": "\t\tn(yellowNode, \"I'm input text. My text is passed to the next node (concatenated).\", laneNodeX(col2, 0), yellowY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 281
          },
          {
            "text": "\t\tn(lab2c, \"Python: runs code. Use variable input for parent text.\", commentLeftX(col2), blueY, \"\", TUT_COMMENT_W, TUT_LABEL_H),",
            "lineNumber": 282
          },
          {
            "text": "\t\tn(blueNode, \"print('Python says:', (input or '')[:80] or '(no input)')\\n# input = text from parent\", laneNodeX(col2, LANE_OFFSET), blueY, cBlue, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 283
          },
          {
            "text": "\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 284
          },
          {
            "lineNumber": 285
          },
          {
            "text": "\t\t// Column 3",
            "lineNumber": 286
          },
          {
            "text": "\t\tn",
            "lineNumber": 287
          },
          {
            "text": ",",
            "lineNumber": 300
          },
          {
            "text": "\t];",
            "lineNumber": 301
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.23502220213413239
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 147,
            "column": 1
          },
          "endPosition": {
            "line": 175,
            "column": 1
          }
        },
        "contents": "/** Sort ready queue: non-AI (Python, text) first for early output, then by y. */\nfunction sortQueueByNonAIFirst(\n\tqueue: string[],\n\tdata: CanvasData,\n\tsettings: ZettelPluginSettings\n): void {\n\tqueue.sort((a, b) =&gt; {\n\t\tconst na = getNodeById(data, a);\n\t\tconst nb = getNodeById(data, b);\n\t\tconst roleA = getNodeRole(na ?? { color: undefined }, settings);\n\t\tconst roleB = getNodeRole(nb ?? { color: undefined }, settings);\n\t\tconst nonA = isNonAIRole(roleA) ? 0 : 1;\n\t\tconst nonB = isNonAIRole(roleB) ? 0 : 1;\n\t\tif (nonA !== nonB) return nonA - nonB;\n\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);\n\t});\n}\n\n/** True if text is already wrapped in &#96;&#96;&#96;python or &#96;&#96;&#96; ... &#96;&#96;&#96;. */\nfunction isPythonCodeFenced(text: string): boolean {\n\tconst lines = text.trim().split(/\\r?\\n/);\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Sort ready queue: non-AI (Python, text) first for early output, then by y. */",
            "lineNumber": 150
          },
          {
            "text": "function sortQueueByNonAIFirst(",
            "lineNumber": 151,
            "isSignature": true
          },
          {
            "text": "\tqueue: string[],",
            "lineNumber": 152,
            "isSignature": true
          },
          {
            "text": "\tdata: CanvasData,",
            "lineNumber": 153,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings",
            "lineNumber": 154,
            "isSignature": true
          },
          {
            "text": "): void {",
            "lineNumber": 155,
            "isSignature": true
          },
          {
            "text": "\tqueue.sort((a, b) =&gt; {",
            "lineNumber": 156
          },
          {
            "text": "\t\tconst na = getNodeById(data, a);",
            "lineNumber": 157
          },
          {
            "text": "\t\tconst nb = getNodeById(data, b);",
            "lineNumber": 158
          },
          {
            "text": "\t\tconst roleA = getNodeRole(na ?? { color: undefined }, settings);",
            "lineNumber": 159
          },
          {
            "text": "\t\tconst roleB = getNodeRole(nb ?? { color: undefined }, settings);",
            "lineNumber": 160
          },
          {
            "text": "\t\tconst nonA = isNonAIRole(roleA) ? 0 : 1;",
            "lineNumber": 161
          },
          {
            "text": "\t\tconst nonB = isNonAIRole(roleB) ? 0 : 1;",
            "lineNumber": 162
          },
          {
            "text": "\t\tif (nonA !== nonB) return nonA - nonB;",
            "lineNumber": 163
          },
          {
            "text": "\t\treturn (na?.y ?? 0) - (nb?.y ?? 0);",
            "lineNumber": 164
          },
          {
            "text": "\t});",
            "lineNumber": 165
          },
          {
            "text": "}",
            "lineNumber": 166,
            "isSignature": true
          },
          {
            "lineNumber": 167
          },
          {
            "text": "/** True if text is already wrapped in &#96;&#96;&#96;python or &#96;&#96;&#96; ... &#96;&#96;&#96;. */",
            "lineNumber": 168
          },
          {
            "text": "function isPythonCodeFenced(text: string): boolean {",
            "lineNumber": 169,
            "isSignature": true
          },
          {
            "text": "\tconst lines = text.trim().split(/\\r?\\n/);",
            "lineNumber": 170
          },
          {
            "text": "}",
            "lineNumber": 176,
            "isSignature": true
          }
        ]
      },
      "score": 0.23493410646915436
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/canvasNodeLabels.ts",
        "range": {
          "startPosition": {
            "line": 144,
            "column": 1
          },
          "endPosition": {
            "line": 207,
            "column": 1
          }
        },
        "contents": "/**\n * Sync floating role labels for the active canvas: for each node whose color maps to a role,\n * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first.\n * Uses the live canvas node map to find each node's DOM element (.canvas-node).\n * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas\n */\nexport async function syncCanvasRoleLabels(\n\tvault: Vault,\n\tcanvasFilePath: string,\n\tcontainerEl: HTMLElement,\n\tsettings: ZettelPluginSettings,\n\tcanvas: LiveCanvas | null,\n\tisStillActive?: () =&gt; boolean\n): Promise&lt;void&gt; {\n\tif (!settings.showNodeRoleLabels) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\tconst data = await loadCanvasData(vault, canvasFilePath);\n\tif (isStillActive &amp;&amp; !isStillActive()) return;\n\tif (!data?.nodes) {\n\t\tclearCanvasRoleLabels(containerEl);\n\t\tclearCanvasLegend(containerEl);\n\t\treturn;\n\t}\n\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).\n\tclearCanvasRoleLabels(containerEl);\n\tsyncCanvasLegend(containerEl, settings);\n\n\tconst order = getTopologicalOrder(data, settings);\n\tconst orderByNodeId = new Map&lt;string, number&gt;();\n\tif (order) {\n\t\torder.forEach((nodeId, index) =&gt; orderByNodeId.set(nodeId, index + 1));\n\t}\n\n\tfor (const node of data.nodes) {\n\t\tconst nodeEl =\n\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||\n\t\t\tfindNodeElementByDataId(containerEl, node.id);\n\t\tif (!nodeEl) continue;\n\n\t\tconst role = getNodeRole(node, settings);\n\t\tif (role) {\n\t\t\tconst labelText = getRoleLabel(role, settings);\n\t\t\tconst label = createLabelEl(labelText);\n\t\t\tnodeEl.append(label);\n\t\t}\n\n\t\tconst orderIndex = orderByNodeId.get(node.id);\n\t\tif (orderIndex != null) {\n\t\t\tconst badge = createOrderBadgeEl(orderIndex);\n\t\t\tnodeEl.append(badge);\n\t\t}\n\t}\n}\n\n/** Get center of an element in viewport coordinates. */\nfunction getElCenter(el: HTMLElement): { x: number; y: number } {\n\tconst r = el.getBoundingClientRect();\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/**",
            "lineNumber": 147
          },
          {
            "text": " * Sync floating role labels for the active canvas: for each node whose color maps to a role,",
            "lineNumber": 148
          },
          {
            "text": " * add a small label above the node (e.g. \"Text\", \"Python\"). Removes existing labels first.",
            "lineNumber": 149
          },
          {
            "text": " * Uses the live canvas node map to find each node's DOM element (.canvas-node).",
            "lineNumber": 150
          },
          {
            "text": " * @param isStillActive - if provided, called after async load; when false we skip applying to avoid stale canvas",
            "lineNumber": 151
          },
          {
            "text": " */",
            "lineNumber": 152
          },
          {
            "text": "export async function syncCanvasRoleLabels(",
            "lineNumber": 153,
            "isSignature": true
          },
          {
            "text": "\tvault: Vault,",
            "lineNumber": 154,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 155,
            "isSignature": true
          },
          {
            "text": "\tcontainerEl: HTMLElement,",
            "lineNumber": 156,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 157,
            "isSignature": true
          },
          {
            "text": "\tcanvas: LiveCanvas | null,",
            "lineNumber": 158,
            "isSignature": true
          },
          {
            "text": "\tisStillActive?: () =&gt; boolean",
            "lineNumber": 159,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;void&gt; {",
            "lineNumber": 160,
            "isSignature": true
          },
          {
            "text": "\tif (!settings.showNodeRoleLabels) {",
            "lineNumber": 161
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 162
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 163
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 164
          },
          {
            "text": "\t}",
            "lineNumber": 165
          },
          {
            "text": "\tconst data = await loadCanvasData(vault, canvasFilePath);",
            "lineNumber": 166
          },
          {
            "text": "\tif (isStillActive &amp;&amp; !isStillActive()) return;",
            "lineNumber": 167
          },
          {
            "text": "\tif (!data?.nodes) {",
            "lineNumber": 168
          },
          {
            "text": "\t\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 169
          },
          {
            "text": "\t\tclearCanvasLegend(containerEl);",
            "lineNumber": 170
          },
          {
            "text": "\t\treturn;",
            "lineNumber": 171
          },
          {
            "text": "\t}",
            "lineNumber": 172
          },
          {
            "text": "\t// Clear only after we have data so we never paint a frame with labels removed and nothing to show (avoids flicker).",
            "lineNumber": 173
          },
          {
            "text": "\tclearCanvasRoleLabels(containerEl);",
            "lineNumber": 174
          },
          {
            "text": "\tsyncCanvasLegend(containerEl, settings);",
            "lineNumber": 175
          },
          {
            "lineNumber": 176
          },
          {
            "text": "\tconst order = getTopologicalOrder(data, settings);",
            "lineNumber": 177
          },
          {
            "text": "\tconst orderByNodeId = new Map&lt;string, number&gt;();",
            "lineNumber": 178
          },
          {
            "text": "\tif (order) {",
            "lineNumber": 179
          },
          {
            "text": "\t\torder.forEach((nodeId, index) =&gt; orderByNodeId.set(nodeId, index + 1));",
            "lineNumber": 180
          },
          {
            "text": "\t}",
            "lineNumber": 181
          },
          {
            "lineNumber": 182
          },
          {
            "text": "\tfor (const node of data.nodes) {",
            "lineNumber": 183
          },
          {
            "text": "\t\tconst nodeEl =",
            "lineNumber": 184
          },
          {
            "text": "\t\t\t(canvas &amp;&amp; getNodeElFromCanvas(canvas, node.id)) ||",
            "lineNumber": 185
          },
          {
            "text": "\t\t\tfindNodeElementByDataId(containerEl, node.id);",
            "lineNumber": 186
          },
          {
            "text": "\t\tif (!nodeEl) continue;",
            "lineNumber": 187
          },
          {
            "lineNumber": 188
          },
          {
            "text": "\t\tconst role = getNodeRole(node, settings);",
            "lineNumber": 189
          },
          {
            "text": "\t\tif (role) {",
            "lineNumber": 190
          },
          {
            "text": "\t\t\tconst labelText = getRoleLabel(role, settings);",
            "lineNumber": 191
          },
          {
            "text": "\t\t\tconst label = createLabelEl(labelText);",
            "lineNumber": 192
          },
          {
            "text": "\t\t\tnodeEl.append(label);",
            "lineNumber": 193
          },
          {
            "text": "\t\t}",
            "lineNumber": 194
          },
          {
            "lineNumber": 195
          },
          {
            "text": "\t\tconst orderIndex = orderByNodeId.get(node.id);",
            "lineNumber": 196
          },
          {
            "text": "\t\tif (orderIndex != null) {",
            "lineNumber": 197
          },
          {
            "text": "\t\t\tconst badge = createOrderBadgeEl(orderIndex);",
            "lineNumber": 198
          },
          {
            "text": "\t\t\tnodeEl.append(badge);",
            "lineNumber": 199
          },
          {
            "text": "\t\t}",
            "lineNumber": 200
          },
          {
            "text": "\t}",
            "lineNumber": 201
          },
          {
            "text": "}",
            "lineNumber": 202,
            "isSignature": true
          },
          {
            "lineNumber": 203
          },
          {
            "text": "/** Get center of an element in viewport coordinates. */",
            "lineNumber": 204
          },
          {
            "text": "function getElCenter(el: HTMLElement): { x: number; y: number } {",
            "lineNumber": 205,
            "isSignature": true
          },
          {
            "text": "\tconst r = el.getBoundingClientRect();",
            "lineNumber": 206
          },
          {
            "text": "}",
            "lineNumber": 208,
            "isSignature": true
          }
        ]
      },
      "score": 0.23417870700359344
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 94,
            "column": 1
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "/** Build tutorial canvas: columns with comment margins, node lane center, edges, groups. */\nfunction getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\tconst cOrange = tutorialColor(settings, \"colorOrange\");\n\tconst cPurple = tutorialColor(settings, \"colorPurple\");\n\tconst cBlue = tutorialColor(settings, \"colorBlue\");\n\tconst cYellow = tutorialColor(settings, \"colorYellow\");\n\tconst cGreen = tutorialColor(settings, \"colorGreen\");\n\n\t/** Plain text node (no role): use for labels/instructions so they are not treated as comment nodes. */\n\tconst n = (id: string, text: string, x: number, y: number, color: string, w: number, h: number) =&gt;\n\t\t({ id, type: \"text\" as const, text, x, y, width: w, height: h, color });\n\tconst e = (id: string, from: string, to: string, label?: string) =&gt; ({\n\t\tid,\n\t\tfromNode: from,\n\t\ttoNode: to,\n\t\tfromSide: \"bottom\" as const,\n\t\ttoSide: \"top\" as const,\n\t\tlabel: label ?? \"\",\n\t});\n\t/** Group node to visually separate a workflow block. */\n\tconst g = (id: string, x: number, y: number, w: number, h: number, label: string) =&gt;\n\t\t({ id, type: \"group\" as const, x, y, width: w, height: h, label });\n\n\t/** Column 1..6: x of left comment margin (column 1 starts right after welcome). */\n\tconst colLeft = (index: number) =&gt;\n\t\tTUT_LEFT + TUT_WELCOME_W + TUT_COL_GAP + (index - 1) * (TUT_COL_TOTAL_W + TUT_COL_GAP);\n\tconst commentLeftX = (colIndex: number) =&gt; colLeft(colIndex);\n\t/** Node lane: center x; offsetPx shifts right so alternating nodes make arrows more visible. */\n\tconst laneNodeX = (colIndex: number, offsetPx: number = 0) =&gt;\n\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + offsetPx;\n\tconst commentRightX = (colIndex: number) =&gt;\n\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP;\n\tconst LANE_OFFSET = 36;\n\n\t// —— Welcome: alone in first block, no overlap with column 1 ——\n\tconst welcome = \"welcome\";\n\tconst welcomeY = TUT_TOP;\n\n\t// —— Column 1: Primary (comment left, node → output in lane) ——\n\tconst col1 = 1;\n\tconst lab1 = \"lab-primary\";\n\tconst orangeNode = \"orange-example\";\n\tconst orangeOut = \"orange-out\";\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Build tutorial canvas: columns with comment margins, node lane center, edges, groups. */",
            "lineNumber": 97
          },
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "text": "\tconst cOrange = tutorialColor(settings, \"colorOrange\");",
            "lineNumber": 99
          },
          {
            "text": "\tconst cPurple = tutorialColor(settings, \"colorPurple\");",
            "lineNumber": 100
          },
          {
            "text": "\tconst cBlue = tutorialColor(settings, \"colorBlue\");",
            "lineNumber": 101
          },
          {
            "text": "\tconst cYellow = tutorialColor(settings, \"colorYellow\");",
            "lineNumber": 102
          },
          {
            "text": "\tconst cGreen = tutorialColor(settings, \"colorGreen\");",
            "lineNumber": 103
          },
          {
            "lineNumber": 104
          },
          {
            "text": "\t/** Plain text node (no role): use for labels/instructions so they are not treated as comment nodes. */",
            "lineNumber": 105
          },
          {
            "text": "\tconst n = (id: string, text: string, x: number, y: number, color: string, w: number, h: number) =&gt;",
            "lineNumber": 106
          },
          {
            "text": "\t\t({ id, type: \"text\" as const, text, x, y, width: w, height: h, color });",
            "lineNumber": 107
          },
          {
            "text": "\tconst e = (id: string, from: string, to: string, label?: string) =&gt; ({",
            "lineNumber": 108
          },
          {
            "text": "\t\tid,",
            "lineNumber": 109
          },
          {
            "text": "\t\tfromNode: from,",
            "lineNumber": 110
          },
          {
            "text": "\t\ttoNode: to,",
            "lineNumber": 111
          },
          {
            "text": "\t\tfromSide: \"bottom\" as const,",
            "lineNumber": 112
          },
          {
            "text": "\t\ttoSide: \"top\" as const,",
            "lineNumber": 113
          },
          {
            "text": "\t\tlabel: label ?? \"\",",
            "lineNumber": 114
          },
          {
            "text": "\t});",
            "lineNumber": 115
          },
          {
            "text": "\t/** Group node to visually separate a workflow block. */",
            "lineNumber": 116
          },
          {
            "text": "\tconst g = (id: string, x: number, y: number, w: number, h: number, label: string) =&gt;",
            "lineNumber": 117
          },
          {
            "text": "\t\t({ id, type: \"group\" as const, x, y, width: w, height: h, label });",
            "lineNumber": 118
          },
          {
            "lineNumber": 119
          },
          {
            "text": "\t/** Column 1..6: x of left comment margin (column 1 starts right after welcome). */",
            "lineNumber": 120
          },
          {
            "text": "\tconst colLeft = (index: number) =&gt;",
            "lineNumber": 121
          },
          {
            "text": "\t\tTUT_LEFT + TUT_WELCOME_W + TUT_COL_GAP + (index - 1) * (TUT_COL_TOTAL_W + TUT_COL_GAP);",
            "lineNumber": 122
          },
          {
            "text": "\tconst commentLeftX = (colIndex: number) =&gt; colLeft(colIndex);",
            "lineNumber": 123
          },
          {
            "text": "\t/** Node lane: center x; offsetPx shifts right so alternating nodes make arrows more visible. */",
            "lineNumber": 124
          },
          {
            "text": "\tconst laneNodeX = (colIndex: number, offsetPx: number = 0) =&gt;",
            "lineNumber": 125
          },
          {
            "text": "\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + offsetPx;",
            "lineNumber": 126
          },
          {
            "text": "\tconst commentRightX = (colIndex: number) =&gt;",
            "lineNumber": 127
          },
          {
            "text": "\t\tcolLeft(colIndex) + TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W + TUT_LANE_GAP;",
            "lineNumber": 128
          },
          {
            "text": "\tconst LANE_OFFSET = 36;",
            "lineNumber": 129
          },
          {
            "lineNumber": 130
          },
          {
            "text": "\t// —— Welcome: alone in first block, no overlap with column 1 ——",
            "lineNumber": 131
          },
          {
            "text": "\tconst welcome = \"welcome\";",
            "lineNumber": 132
          },
          {
            "text": "\tconst welcomeY = TUT_TOP;",
            "lineNumber": 133
          },
          {
            "lineNumber": 134
          },
          {
            "text": "\t// —— Column 1: Primary (comment left, node → output in lane) ——",
            "lineNumber": 135
          },
          {
            "text": "\tconst col1 = 1;",
            "lineNumber": 136
          },
          {
            "text": "\tconst lab1 = \"lab-primary\";",
            "lineNumber": 137
          },
          {
            "text": "\tconst orangeNode = \"orange-example\";",
            "lineNumber": 138
          },
          {
            "text": "\tconst orangeOut = \"orange-out\";",
            "lineNumber": 139
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.22710704803466797
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 97
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\n\n\tconst col1 = 1;\n\tconst lab1 = \"lab-primary\";\n\tconst orangeNode = \"orange-example\";\n\tconst orangeOut = \"orange-out\";\n\tlet y1 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\tconst orangeY = y1;\n\ty1 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst orangeOutY = y1;\n\n\t// —— Column 2: Purple, Yellow, Blue (comments in margins, nodes in lane) ——\n\tconst col2 = 2;\n\tconst lab2a = \"lab-purple\";\n\tconst purpleNode = \"purple-example\";\n\tconst purpleOut = \"purple-out\";\n\tconst lab2b = \"lab-yellow\";\n\tconst yellowNode = \"yellow-example\";\n\tconst lab2c = \"lab-blue\";\n\tconst blueNode = \"blue-example\";\n\tconst blueOut = \"blue-out\";\n\tlet y2 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\tconst purpleY = y2;\n\ty2 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst purpleOutY = y2;\n\ty2 += TUT_NODE_H + TUT_NODE_GAP + 20;\n\tconst yellowY = y2;\n\ty2 += TUT_NODE_H + TUT_NODE_GAP + 20;\n\tconst blueY = y2;\n\ty2 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst blueOutY = y2;\n\n\t// —— Column 3: Concatenation ——\n\tconst col3 = 3;\n\tconst lab3 = \"lab-concat\";\n\tconst concatComment = \"concat-comment\";\n\tconst concatOrange = \"concat-orange\";\n\tconst concatOut = \"concat-out\";\n\tlet y3 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\tconst concatCommentY = y3;\n\ty3 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst concatOrangeY = y3;\n\ty3 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst concatOutY = y3;\n\n\t// —— Column 4: Variable injection ——\n\tconst col4 = 4;\n\tconst lab4 = \"lab-inject\";\n\tconst injectFirst = \"inject-first\";\n\tconst injectSecond = \"inject-second\";\n\tconst injectOut = \"inject-out\";\n\tlet y4 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\tconst injectFirstY = y4;\n\ty4 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst injectSecondY = y4;\n\ty4 += TUT_NODE_H + TUT_NODE_GAP;\n\tconst injectOutY = y4;\n\n\t// —— Column 5 &amp; 6: Comments only (left margin + optional right), no nodes in lane ——\n\tconst col5 = 5;\n\tconst col6 = 6;\n\tconst lab5 = \"lab-commands\";\n\tconst lab6 = \"lab-sidebar\";\n\tconst y5 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\tconst y6 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\n\t// Group bounds (x, y, w, h) for each workflow block\n\tconst TUT_WELCOME_CARD_H = 132;\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 98,
                "column": 1
              },
              "endPosition": {
                "line": 99,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "lineNumber": 135
          },
          {
            "text": "\tconst col1 = 1;",
            "lineNumber": 136
          },
          {
            "text": "\tconst lab1 = \"lab-primary\";",
            "lineNumber": 137
          },
          {
            "text": "\tconst orangeNode = \"orange-example\";",
            "lineNumber": 138
          },
          {
            "text": "\tconst orangeOut = \"orange-out\";",
            "lineNumber": 139
          },
          {
            "text": "\tlet y1 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 140
          },
          {
            "text": "\tconst orangeY = y1;",
            "lineNumber": 141
          },
          {
            "text": "\ty1 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 142
          },
          {
            "text": "\tconst orangeOutY = y1;",
            "lineNumber": 143
          },
          {
            "lineNumber": 144
          },
          {
            "text": "\t// —— Column 2: Purple, Yellow, Blue (comments in margins, nodes in lane) ——",
            "lineNumber": 145
          },
          {
            "text": "\tconst col2 = 2;",
            "lineNumber": 146
          },
          {
            "text": "\tconst lab2a = \"lab-purple\";",
            "lineNumber": 147
          },
          {
            "text": "\tconst purpleNode = \"purple-example\";",
            "lineNumber": 148
          },
          {
            "text": "\tconst purpleOut = \"purple-out\";",
            "lineNumber": 149
          },
          {
            "text": "\tconst lab2b = \"lab-yellow\";",
            "lineNumber": 150
          },
          {
            "text": "\tconst yellowNode = \"yellow-example\";",
            "lineNumber": 151
          },
          {
            "text": "\tconst lab2c = \"lab-blue\";",
            "lineNumber": 152
          },
          {
            "text": "\tconst blueNode = \"blue-example\";",
            "lineNumber": 153
          },
          {
            "text": "\tconst blueOut = \"blue-out\";",
            "lineNumber": 154
          },
          {
            "text": "\tlet y2 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 155
          },
          {
            "text": "\tconst purpleY = y2;",
            "lineNumber": 156
          },
          {
            "text": "\ty2 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 157
          },
          {
            "text": "\tconst purpleOutY = y2;",
            "lineNumber": 158
          },
          {
            "text": "\ty2 += TUT_NODE_H + TUT_NODE_GAP + 20;",
            "lineNumber": 159
          },
          {
            "text": "\tconst yellowY = y2;",
            "lineNumber": 160
          },
          {
            "text": "\ty2 += TUT_NODE_H + TUT_NODE_GAP + 20;",
            "lineNumber": 161
          },
          {
            "text": "\tconst blueY = y2;",
            "lineNumber": 162
          },
          {
            "text": "\ty2 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 163
          },
          {
            "text": "\tconst blueOutY = y2;",
            "lineNumber": 164
          },
          {
            "lineNumber": 165
          },
          {
            "text": "\t// —— Column 3: Concatenation ——",
            "lineNumber": 166
          },
          {
            "text": "\tconst col3 = 3;",
            "lineNumber": 167
          },
          {
            "text": "\tconst lab3 = \"lab-concat\";",
            "lineNumber": 168
          },
          {
            "text": "\tconst concatComment = \"concat-comment\";",
            "lineNumber": 169
          },
          {
            "text": "\tconst concatOrange = \"concat-orange\";",
            "lineNumber": 170
          },
          {
            "text": "\tconst concatOut = \"concat-out\";",
            "lineNumber": 171
          },
          {
            "text": "\tlet y3 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 172
          },
          {
            "text": "\tconst concatCommentY = y3;",
            "lineNumber": 173
          },
          {
            "text": "\ty3 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 174
          },
          {
            "text": "\tconst concatOrangeY = y3;",
            "lineNumber": 175
          },
          {
            "text": "\ty3 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 176
          },
          {
            "text": "\tconst concatOutY = y3;",
            "lineNumber": 177
          },
          {
            "lineNumber": 178
          },
          {
            "text": "\t// —— Column 4: Variable injection ——",
            "lineNumber": 179
          },
          {
            "text": "\tconst col4 = 4;",
            "lineNumber": 180
          },
          {
            "text": "\tconst lab4 = \"lab-inject\";",
            "lineNumber": 181
          },
          {
            "text": "\tconst injectFirst = \"inject-first\";",
            "lineNumber": 182
          },
          {
            "text": "\tconst injectSecond = \"inject-second\";",
            "lineNumber": 183
          },
          {
            "text": "\tconst injectOut = \"inject-out\";",
            "lineNumber": 184
          },
          {
            "text": "\tlet y4 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 185
          },
          {
            "text": "\tconst injectFirstY = y4;",
            "lineNumber": 186
          },
          {
            "text": "\ty4 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 187
          },
          {
            "text": "\tconst injectSecondY = y4;",
            "lineNumber": 188
          },
          {
            "text": "\ty4 += TUT_NODE_H + TUT_NODE_GAP;",
            "lineNumber": 189
          },
          {
            "text": "\tconst injectOutY = y4;",
            "lineNumber": 190
          },
          {
            "lineNumber": 191
          },
          {
            "text": "\t// —— Column 5 &amp; 6: Comments only (left margin + optional right), no nodes in lane ——",
            "lineNumber": 192
          },
          {
            "text": "\tconst col5 = 5;",
            "lineNumber": 193
          },
          {
            "text": "\tconst col6 = 6;",
            "lineNumber": 194
          },
          {
            "text": "\tconst lab5 = \"lab-commands\";",
            "lineNumber": 195
          },
          {
            "text": "\tconst lab6 = \"lab-sidebar\";",
            "lineNumber": 196
          },
          {
            "text": "\tconst y5 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 197
          },
          {
            "text": "\tconst y6 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 198
          },
          {
            "lineNumber": 199
          },
          {
            "text": "\t// Group bounds (x, y, w, h) for each workflow block",
            "lineNumber": 200
          },
          {
            "text": "\tconst TUT_WELCOME_CARD_H = 132;",
            "lineNumber": 201
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.2206030935049057
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/canvas/types.ts",
        "range": {
          "startPosition": {
            "line": 130,
            "column": 37
          },
          "endPosition": {
            "line": 135,
            "column": 113
          }
        },
        "contents": "/** Max vertical offset (px) below default placement when finding output by position; must match runner collision range. */\nexport const OUTPUT_POSITION_FALLBACK_MAX_Y = 450;\n\n/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "/** Max vertical offset (px) below default placement when finding output by position; must match runner collision range. */",
            "lineNumber": 133
          },
          {
            "text": "export const OUTPUT_POSITION_FALLBACK_MAX_Y = 450;",
            "lineNumber": 134
          },
          {
            "lineNumber": 135
          },
          {
            "text": "/** Find the Green (output) node for a given source node. Edge-first (label \"output\"), then position fallback. */",
            "lineNumber": 136
          }
        ]
      },
      "score": 0.21323585510253906
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/canvasApi.ts",
        "range": {
          "startPosition": {
            "column": 86
          },
          "endPosition": {
            "line": 15,
            "column": 1
          }
        },
        "contents": "export interface LiveCanvas {\n\tcreateTextNode(options: {\n\t\ttext: string;\n\t\tpos: { x: number; y: number };\n\t\tsize: { width: number; height: number };\n\t\tsave?: boolean;\n\t\tfocus?: boolean;\n\t}): { id: string; x: number; y: number; width: number; height: number; moveTo: (pos: { x: number; y: number }) =&gt; void; resize: (size: { width: number; height: number }) =&gt; void };\n\taddNode(node: unknown): void;\n\trequestSave?: () =&gt; void;\n\tremoveNode?(node: unknown): void;\n\tnodes?: Map&lt;string, unknown&gt; | Iterable&lt;unknown&gt;;\n\t/** If present, used to refresh canvas after edge label updates (Obsidian canvas view). */\n\tsetData?(data: unknown): void;\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export interface LiveCanvas {",
            "lineNumber": 2,
            "isSignature": true
          },
          {
            "text": "\tcreateTextNode(options: {",
            "lineNumber": 3
          },
          {
            "text": "\t\ttext: string;",
            "lineNumber": 4
          },
          {
            "text": "\t\tpos: { x: number; y: number };",
            "lineNumber": 5
          },
          {
            "text": "\t\tsize: { width: number; height: number };",
            "lineNumber": 6
          },
          {
            "text": "\t\tsave?: boolean;",
            "lineNumber": 7
          },
          {
            "text": "\t\tfocus?: boolean;",
            "lineNumber": 8
          },
          {
            "text": "\t}): { id: string; x: number; y: number; width: number; height: number; moveTo: (pos: { x: number; y: number }) =&gt; void; resize: (size: { width: number; height: number }) =&gt; void };",
            "lineNumber": 9
          },
          {
            "text": "\taddNode(node: unknown): void;",
            "lineNumber": 10
          },
          {
            "text": "\trequestSave?: () =&gt; void;",
            "lineNumber": 11
          },
          {
            "text": "\tremoveNode?(node: unknown): void;",
            "lineNumber": 12
          },
          {
            "text": "\tnodes?: Map&lt;string, unknown&gt; | Iterable&lt;unknown&gt;;",
            "lineNumber": 13
          },
          {
            "text": "\t/** If present, used to refresh canvas after edge label updates (Obsidian canvas view). */",
            "lineNumber": 14
          },
          {
            "text": "\tsetData?(data: unknown): void;",
            "lineNumber": 15,
            "isSignature": true
          },
          {
            "text": "}",
            "lineNumber": 16,
            "isSignature": true
          }
        ]
      },
      "score": 0.20308303833007812
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/settings.ts",
        "range": {
          "startPosition": {
            "line": 541
          },
          "endPosition": {
            "line": 941,
            "column": 1
          }
        },
        "contents": "export class ZettelSettingTab extends PluginSettingTab {\n\n\n\tdisplay(): void {\n\t\tconst {containerEl} = this;\n\t\tcontainerEl.empty();\n\t\tconst s = this.plugin.settings;\n\n\t\t/*\n\t\t * UX philosophy for this tab:\n\t\t * - Logical flow: Setup (dependencies) → Configuration (models, execution) → Display (appearance) → Templates (optional)\n\t\t * - Progressive disclosure: auto-collapse setup when complete, collapsible model blocks\n\t\t * - Clear hierarchy: sections → subsections → settings\n\t\t * - Consistent spacing and grouping\n\t\t */\n\n\t\t// Warning banner for color conflicts (hidden by default)\n\t\tconst warningBanner = containerEl.createDiv({ cls: \"ztb-color-warning-banner\" });\n\t\twarningBanner.style.display = \"none\";\n\t\twarningBanner.style.backgroundColor = \"var(--background-modifier-error)\";\n\t\twarningBanner.style.color = \"var(--text-on-accent)\";\n\t\twarningBanner.style.padding = \"12px 16px\";\n\t\twarningBanner.style.marginBottom = \"16px\";\n\t\twarningBanner.style.borderRadius = \"4px\";\n\t\twarningBanner.style.border = \"1px solid var(--background-modifier-error-border)\";\n\n\t\tconst warningCallback = (message: string | null) =&gt; {\n\t\t\tif (message) {\n\t\t\t\twarningBanner.setText(message);\n\t\t\t\twarningBanner.style.display = \"block\";\n\t\t\t} else {\n\t\t\t\twarningBanner.style.display = \"none\";\n\t\t\t}\n\t\t};\n\n\t\t// Installation &amp; Dependencies section - auto-collapses when everything is installed\n\t\tthis.addInstallationSection(containerEl);\n\n\t\t// Execution section: model configuration\n\t\tconst executionSection = containerEl.createDiv({ cls: \"ztb-settings-section\" });\n\t\texecutionSection.createEl(\"h4\", { text: \"Model Configuration\", cls: \"ztb-section-title\" });\n\t\tconst executionHint = executionSection.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });\n\t\texecutionHint.setText(\"Configure AI models and execution settings. Right-click a node on the canvas and choose Run node or Run chain to execute.\");\n\n\t\tconst ollamaContainer = executionSection.createDiv({ cls: \"ztb-ollama-settings\" });\n\t\tconst loadingEl = ollamaContainer.createDiv({ cls: \"ztb-ollama-loading\" });\n\t\tloadingEl.setText(\"Loading Ollama models…\");\n\t\t(async () =&gt; {\n\t\t\tconst models = await fetchOllamaModels();\n\t\t}\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 542,
                "column": 1
              },
              "endPosition": {
                "line": 542,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 542,
                "column": 8
              },
              "endPosition": {
                "line": 543,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export class ZettelSettingTab extends PluginSettingTab {",
            "lineNumber": 542,
            "isSignature": true
          },
          {
            "lineNumber": 548
          },
          {
            "lineNumber": 549
          },
          {
            "text": "\tdisplay(): void {",
            "lineNumber": 550
          },
          {
            "text": "\t\tconst {containerEl} = this;",
            "lineNumber": 551
          },
          {
            "text": "\t\tcontainerEl.empty();",
            "lineNumber": 552
          },
          {
            "text": "\t\tconst s = this.plugin.settings;",
            "lineNumber": 553
          },
          {
            "lineNumber": 554
          },
          {
            "text": "\t\t/*",
            "lineNumber": 555
          },
          {
            "text": "\t\t * UX philosophy for this tab:",
            "lineNumber": 556
          },
          {
            "text": "\t\t * - Logical flow: Setup (dependencies) → Configuration (models, execution) → Display (appearance) → Templates (optional)",
            "lineNumber": 557
          },
          {
            "text": "\t\t * - Progressive disclosure: auto-collapse setup when complete, collapsible model blocks",
            "lineNumber": 558
          },
          {
            "text": "\t\t * - Clear hierarchy: sections → subsections → settings",
            "lineNumber": 559
          },
          {
            "text": "\t\t * - Consistent spacing and grouping",
            "lineNumber": 560
          },
          {
            "text": "\t\t */",
            "lineNumber": 561
          },
          {
            "lineNumber": 562
          },
          {
            "text": "\t\t// Warning banner for color conflicts (hidden by default)",
            "lineNumber": 563
          },
          {
            "text": "\t\tconst warningBanner = containerEl.createDiv({ cls: \"ztb-color-warning-banner\" });",
            "lineNumber": 564
          },
          {
            "text": "\t\twarningBanner.style.display = \"none\";",
            "lineNumber": 565
          },
          {
            "text": "\t\twarningBanner.style.backgroundColor = \"var(--background-modifier-error)\";",
            "lineNumber": 566
          },
          {
            "text": "\t\twarningBanner.style.color = \"var(--text-on-accent)\";",
            "lineNumber": 567
          },
          {
            "text": "\t\twarningBanner.style.padding = \"12px 16px\";",
            "lineNumber": 568
          },
          {
            "text": "\t\twarningBanner.style.marginBottom = \"16px\";",
            "lineNumber": 569
          },
          {
            "text": "\t\twarningBanner.style.borderRadius = \"4px\";",
            "lineNumber": 570
          },
          {
            "text": "\t\twarningBanner.style.border = \"1px solid var(--background-modifier-error-border)\";",
            "lineNumber": 571
          },
          {
            "lineNumber": 572
          },
          {
            "text": "\t\tconst warningCallback = (message: string | null) =&gt; {",
            "lineNumber": 573
          },
          {
            "text": "\t\t\tif (message) {",
            "lineNumber": 574
          },
          {
            "text": "\t\t\t\twarningBanner.setText(message);",
            "lineNumber": 575
          },
          {
            "text": "\t\t\t\twarningBanner.style.display = \"block\";",
            "lineNumber": 576
          },
          {
            "text": "\t\t\t} else {",
            "lineNumber": 577
          },
          {
            "text": "\t\t\t\twarningBanner.style.display = \"none\";",
            "lineNumber": 578
          },
          {
            "text": "\t\t\t}",
            "lineNumber": 579
          },
          {
            "text": "\t\t};",
            "lineNumber": 580
          },
          {
            "lineNumber": 581
          },
          {
            "text": "\t\t// Installation &amp; Dependencies section - auto-collapses when everything is installed",
            "lineNumber": 582
          },
          {
            "text": "\t\tthis.addInstallationSection(containerEl);",
            "lineNumber": 583
          },
          {
            "lineNumber": 584
          },
          {
            "text": "\t\t// Execution section: model configuration",
            "lineNumber": 585
          },
          {
            "text": "\t\tconst executionSection = containerEl.createDiv({ cls: \"ztb-settings-section\" });",
            "lineNumber": 586
          },
          {
            "text": "\t\texecutionSection.createEl(\"h4\", { text: \"Model Configuration\", cls: \"ztb-section-title\" });",
            "lineNumber": 587
          },
          {
            "text": "\t\tconst executionHint = executionSection.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });",
            "lineNumber": 588
          },
          {
            "text": "\t\texecutionHint.setText(\"Configure AI models and execution settings. Right-click a node on the canvas and choose Run node or Run chain to execute.\");",
            "lineNumber": 589
          },
          {
            "lineNumber": 590
          },
          {
            "text": "\t\tconst ollamaContainer = executionSection.createDiv({ cls: \"ztb-ollama-settings\" });",
            "lineNumber": 591
          },
          {
            "text": "\t\tconst loadingEl = ollamaContainer.createDiv({ cls: \"ztb-ollama-loading\" });",
            "lineNumber": 592
          },
          {
            "text": "\t\tloadingEl.setText(\"Loading Ollama models…\");",
            "lineNumber": 593
          },
          {
            "text": "\t\t(async () =&gt; {",
            "lineNumber": 594
          },
          {
            "text": "\t\t\tconst models = await fetchOllamaModels();",
            "lineNumber": 595
          },
          {
            "text": "\t\t}",
            "lineNumber": 605
          },
          {
            "text": "\t}",
            "lineNumber": 706
          },
          {
            "text": "}",
            "lineNumber": 942,
            "isSignature": true
          }
        ]
      },
      "score": 0.1994187980890274
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/settings.ts",
        "range": {
          "startPosition": {
            "line": 541
          },
          "endPosition": {
            "line": 941,
            "column": 1
          }
        },
        "contents": "export class ZettelSettingTab extends PluginSettingTab {\ndisplay(): void {\n\");\n\n\t\tnew Setting(displaySection)\n\t\t\t.setName(\"Show role labels on canvas\")\n\t\t\t.setDesc(\"Show a floating label above each node (e.g. Model: llama2, Text, Python) based on its color\")\n\t\t\t.addToggle((toggle) =&gt; toggle\n\t\t\t\t.setValue(s.showNodeRoleLabels)\n\t\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t\tthis.plugin.settings.showNodeRoleLabels = value;\n\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t}));\n\n\t\taddColorSetting(\n\t\t\tdisplaySection,\n\t\t\tthis.plugin,\n\t\t\t\"blue\",\n\t\t\t\"Python node color\",\n\t\t\t\"Color for Python execution nodes on the canvas\",\n\t\t\twarningCallback\n\t\t);\n\t\taddColorSetting(\n\t\t\tdisplaySection,\n\t\t\tthis.plugin,\n\t\t\t\"yellow\",\n\t\t\t\"Text node color\",\n\t\t\t\"Color for text (input) nodes: pass-through text, no AI processing\",\n\t\t\twarningCallback\n\t\t);\n\t\taddColorSetting(\n\t\t\tdisplaySection,\n\t\t\tthis.plugin,\n\t\t\t\"green\",\n\t\t\t\"Output node color\",\n\t\t\t\"Color for auto-generated output nodes on the canvas\",\n\t\t\twarningCallback\n\t\t);\n\n\t\tnew Setting(displaySection)\n\t\t\t.setName(\"Show prompt in output\")\n\t\t\t.setDesc(\"When enabled, create a separate node above the output showing the full prompt sent to the model (in a lighter shade of the output color)\")\n\t\t\t.addToggle((toggle) =&gt; toggle\n\t\t\t\t.setValue(s.showPromptInOutput)\n\t\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t\tthis.plugin.settings.showPromptInOutput = value;\n\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t}));\n\n\t\tnew Setting(displaySection)\n\t\t\t.setName(\"Show model thinking node\")\n\t\t\t.setDesc(\"When enabled and the model returns thinking (e.g. reasoning trace), create an extra node to display it\")\n\t\t\t.addToggle((toggle) =&gt; toggle\n\t\t\t\t.setValue(s.showThinkingNode)\n\t\t\t\t.onChange(async (value) =&gt; {\n\t\t\t\t\tthis.plugin.settings.showThinkingNode = value;\n\t\t\t\t\tawait this.plugin.saveSettings();\n\t\t\t\t}));\n\n\t\t// Canvas Templates section\n\t\tconst templatesSection = containerEl.createDiv({ cls: \"ztb-settings-section\" });\n\t\ttemplatesSection.createEl(\"h4\", { text: \"Canvas Templates\", cls: \"ztb-section-title\" });\n\t\tconst templatesHint = templatesSection.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });\n\t\ttemplatesHint.setText(\"Define folders for canvas templates and where new canvases from templates should be created. Use the \n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 542,
                "column": 1
              },
              "endPosition": {
                "line": 542,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 542,
                "column": 8
              },
              "endPosition": {
                "line": 543,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 550,
                "column": 2
              },
              "endPosition": {
                "line": 551,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export class ZettelSettingTab extends PluginSettingTab {",
            "lineNumber": 542,
            "isSignature": true
          },
          {
            "text": "display(): void {",
            "lineNumber": 550
          },
          {
            "text": "\");",
            "lineNumber": 622
          },
          {
            "lineNumber": 623
          },
          {
            "text": "\t\tnew Setting(displaySection)",
            "lineNumber": 624
          },
          {
            "text": "\t\t\t.setName(\"Show role labels on canvas\")",
            "lineNumber": 625
          },
          {
            "text": "\t\t\t.setDesc(\"Show a floating label above each node (e.g. Model: llama2, Text, Python) based on its color\")",
            "lineNumber": 626
          },
          {
            "text": "\t\t\t.addToggle((toggle) =&gt; toggle",
            "lineNumber": 627
          },
          {
            "text": "\t\t\t\t.setValue(s.showNodeRoleLabels)",
            "lineNumber": 628
          },
          {
            "text": "\t\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 629
          },
          {
            "text": "\t\t\t\t\tthis.plugin.settings.showNodeRoleLabels = value;",
            "lineNumber": 630
          },
          {
            "text": "\t\t\t\t\tawait this.plugin.saveSettings();",
            "lineNumber": 631
          },
          {
            "text": "\t\t\t\t}));",
            "lineNumber": 632
          },
          {
            "lineNumber": 633
          },
          {
            "text": "\t\taddColorSetting(",
            "lineNumber": 634
          },
          {
            "text": "\t\t\tdisplaySection,",
            "lineNumber": 635
          },
          {
            "text": "\t\t\tthis.plugin,",
            "lineNumber": 636
          },
          {
            "text": "\t\t\t\"blue\",",
            "lineNumber": 637
          },
          {
            "text": "\t\t\t\"Python node color\",",
            "lineNumber": 638
          },
          {
            "text": "\t\t\t\"Color for Python execution nodes on the canvas\",",
            "lineNumber": 639
          },
          {
            "text": "\t\t\twarningCallback",
            "lineNumber": 640
          },
          {
            "text": "\t\t);",
            "lineNumber": 641
          },
          {
            "text": "\t\taddColorSetting(",
            "lineNumber": 642
          },
          {
            "text": "\t\t\tdisplaySection,",
            "lineNumber": 643
          },
          {
            "text": "\t\t\tthis.plugin,",
            "lineNumber": 644
          },
          {
            "text": "\t\t\t\"yellow\",",
            "lineNumber": 645
          },
          {
            "text": "\t\t\t\"Text node color\",",
            "lineNumber": 646
          },
          {
            "text": "\t\t\t\"Color for text (input) nodes: pass-through text, no AI processing\",",
            "lineNumber": 647
          },
          {
            "text": "\t\t\twarningCallback",
            "lineNumber": 648
          },
          {
            "text": "\t\t);",
            "lineNumber": 649
          },
          {
            "text": "\t\taddColorSetting(",
            "lineNumber": 650
          },
          {
            "text": "\t\t\tdisplaySection,",
            "lineNumber": 651
          },
          {
            "text": "\t\t\tthis.plugin,",
            "lineNumber": 652
          },
          {
            "text": "\t\t\t\"green\",",
            "lineNumber": 653
          },
          {
            "text": "\t\t\t\"Output node color\",",
            "lineNumber": 654
          },
          {
            "text": "\t\t\t\"Color for auto-generated output nodes on the canvas\",",
            "lineNumber": 655
          },
          {
            "text": "\t\t\twarningCallback",
            "lineNumber": 656
          },
          {
            "text": "\t\t);",
            "lineNumber": 657
          },
          {
            "lineNumber": 658
          },
          {
            "text": "\t\tnew Setting(displaySection)",
            "lineNumber": 659
          },
          {
            "text": "\t\t\t.setName(\"Show prompt in output\")",
            "lineNumber": 660
          },
          {
            "text": "\t\t\t.setDesc(\"When enabled, create a separate node above the output showing the full prompt sent to the model (in a lighter shade of the output color)\")",
            "lineNumber": 661
          },
          {
            "text": "\t\t\t.addToggle((toggle) =&gt; toggle",
            "lineNumber": 662
          },
          {
            "text": "\t\t\t\t.setValue(s.showPromptInOutput)",
            "lineNumber": 663
          },
          {
            "text": "\t\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 664
          },
          {
            "text": "\t\t\t\t\tthis.plugin.settings.showPromptInOutput = value;",
            "lineNumber": 665
          },
          {
            "text": "\t\t\t\t\tawait this.plugin.saveSettings();",
            "lineNumber": 666
          },
          {
            "text": "\t\t\t\t}));",
            "lineNumber": 667
          },
          {
            "lineNumber": 668
          },
          {
            "text": "\t\tnew Setting(displaySection)",
            "lineNumber": 669
          },
          {
            "text": "\t\t\t.setName(\"Show model thinking node\")",
            "lineNumber": 670
          },
          {
            "text": "\t\t\t.setDesc(\"When enabled and the model returns thinking (e.g. reasoning trace), create an extra node to display it\")",
            "lineNumber": 671
          },
          {
            "text": "\t\t\t.addToggle((toggle) =&gt; toggle",
            "lineNumber": 672
          },
          {
            "text": "\t\t\t\t.setValue(s.showThinkingNode)",
            "lineNumber": 673
          },
          {
            "text": "\t\t\t\t.onChange(async (value) =&gt; {",
            "lineNumber": 674
          },
          {
            "text": "\t\t\t\t\tthis.plugin.settings.showThinkingNode = value;",
            "lineNumber": 675
          },
          {
            "text": "\t\t\t\t\tawait this.plugin.saveSettings();",
            "lineNumber": 676
          },
          {
            "text": "\t\t\t\t}));",
            "lineNumber": 677
          },
          {
            "lineNumber": 678
          },
          {
            "text": "\t\t// Canvas Templates section",
            "lineNumber": 679
          },
          {
            "text": "\t\tconst templatesSection = containerEl.createDiv({ cls: \"ztb-settings-section\" });",
            "lineNumber": 680
          },
          {
            "text": "\t\ttemplatesSection.createEl(\"h4\", { text: \"Canvas Templates\", cls: \"ztb-section-title\" });",
            "lineNumber": 681
          },
          {
            "text": "\t\tconst templatesHint = templatesSection.createDiv({ cls: \"ztb-settings-hint setting-item-description\" });",
            "lineNumber": 682
          },
          {
            "text": "\t\ttemplatesHint.setText(\"Define folders for canvas templates and where new canvases from templates should be created. Use the ",
            "lineNumber": 683
          },
          {
            "text": "\t}",
            "lineNumber": 706
          },
          {
            "text": "}",
            "lineNumber": 942,
            "isSignature": true
          }
        ]
      },
      "score": 0.1926632523536682
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 97
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\nconst y5 =  TUT_WELCOME_BOTTOM_GAP;\n\tconst y6 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;\n\n\t// Group bounds (x, y, w, h) for each workflow block\n\tconst TUT_WELCOME_CARD_H = 132;\n\tconst groupWelcome = g(\n\t\t\"grp-welcome\",\n\t\tTUT_LEFT - TUT_GROUP_PAD,\n\t\twelcomeY - TUT_GROUP_PAD,\n\t\tTUT_WELCOME_W + 2 * TUT_GROUP_PAD,\n\t\tTUT_WELCOME_CARD_H + 2 * TUT_GROUP_PAD,\n\t\t\"Welcome\"\n\t);\n\tconst groupCol1 = g(\n\t\t\"grp-col1\",\n\t\tcommentLeftX(col1) - TUT_GROUP_PAD,\n\t\torangeY - TUT_GROUP_PAD,\n\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,\n\t\torangeOutY + TUT_NODE_H - orangeY + 2 * TUT_GROUP_PAD,\n\t\t\"Primary model\"\n\t);\n\tconst groupCol2 = g(\n\t\t\"grp-col2\",\n\t\tcommentLeftX(col2) - TUT_GROUP_PAD,\n\t\tpurpleY - TUT_GROUP_PAD,\n\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,\n\t\tblueOutY + TUT_NODE_H - purpleY + 2 * TUT_GROUP_PAD,\n\t\t\"Node types\"\n\t);\n\tconst groupCol3 = g(\n\t\t\"grp-col3\",\n\t\tcommentLeftX(col3) - TUT_GROUP_PAD,\n\t\tconcatCommentY - TUT_GROUP_PAD,\n\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,\n\t\tconcatOutY + TUT_NODE_H - concatCommentY + 2 * TUT_GROUP_PAD,\n\t\t\"Concatenation\"\n\t);\n\tconst groupCol4 = g(\n\t\t\"grp-col4\",\n\t\tcommentLeftX(col4) - TUT_GROUP_PAD,\n\t\tinjectFirstY - TUT_GROUP_PAD,\n\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,\n\t\tinjectOutY + TUT_NODE_H - injectFirstY + 2 * TUT_GROUP_PAD,\n\t\t\"Variable injection\"\n\t);\n\tconst groupCol5 = g(\n\t\t\"grp-col5\",\n\t\tcommentLeftX(col5) - TUT_GROUP_PAD,\n\t\ty5 - TUT_GROUP_PAD,\n\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,\n\t\t195 + 2 * TUT_GROUP_PAD,\n\t\t\"How to run\"\n\t);\n\tconst groupCol6 = g(\n\t\t\"grp-col6\",\n\t\tcommentLeftX(col6) - TUT_GROUP_PAD,\n\t\ty6 - TUT_GROUP_PAD,\n\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,\n\t\t145 + 2 * TUT_GROUP_PAD,\n\t\t\"Sidebar\"\n\t);\n\n\tconst nodes: CanvasData[\"nodes\"] = [\n\t\t// Groups first (render behind)\n\t\tgroupWelcome\n,\n\t];\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 98,
                "column": 1
              },
              "endPosition": {
                "line": 99,
                "column": 2
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "text": "const y5 =  TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 197
          },
          {
            "text": "\tconst y6 = TUT_TOP + TUT_WELCOME_H + TUT_WELCOME_BOTTOM_GAP;",
            "lineNumber": 198
          },
          {
            "lineNumber": 199
          },
          {
            "text": "\t// Group bounds (x, y, w, h) for each workflow block",
            "lineNumber": 200
          },
          {
            "text": "\tconst TUT_WELCOME_CARD_H = 132;",
            "lineNumber": 201
          },
          {
            "text": "\tconst groupWelcome = g(",
            "lineNumber": 202
          },
          {
            "text": "\t\t\"grp-welcome\",",
            "lineNumber": 203
          },
          {
            "text": "\t\tTUT_LEFT - TUT_GROUP_PAD,",
            "lineNumber": 204
          },
          {
            "text": "\t\twelcomeY - TUT_GROUP_PAD,",
            "lineNumber": 205
          },
          {
            "text": "\t\tTUT_WELCOME_W + 2 * TUT_GROUP_PAD,",
            "lineNumber": 206
          },
          {
            "text": "\t\tTUT_WELCOME_CARD_H + 2 * TUT_GROUP_PAD,",
            "lineNumber": 207
          },
          {
            "text": "\t\t\"Welcome\"",
            "lineNumber": 208
          },
          {
            "text": "\t);",
            "lineNumber": 209
          },
          {
            "text": "\tconst groupCol1 = g(",
            "lineNumber": 210
          },
          {
            "text": "\t\t\"grp-col1\",",
            "lineNumber": 211
          },
          {
            "text": "\t\tcommentLeftX(col1) - TUT_GROUP_PAD,",
            "lineNumber": 212
          },
          {
            "text": "\t\torangeY - TUT_GROUP_PAD,",
            "lineNumber": 213
          },
          {
            "text": "\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,",
            "lineNumber": 214
          },
          {
            "text": "\t\torangeOutY + TUT_NODE_H - orangeY + 2 * TUT_GROUP_PAD,",
            "lineNumber": 215
          },
          {
            "text": "\t\t\"Primary model\"",
            "lineNumber": 216
          },
          {
            "text": "\t);",
            "lineNumber": 217
          },
          {
            "text": "\tconst groupCol2 = g(",
            "lineNumber": 218
          },
          {
            "text": "\t\t\"grp-col2\",",
            "lineNumber": 219
          },
          {
            "text": "\t\tcommentLeftX(col2) - TUT_GROUP_PAD,",
            "lineNumber": 220
          },
          {
            "text": "\t\tpurpleY - TUT_GROUP_PAD,",
            "lineNumber": 221
          },
          {
            "text": "\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,",
            "lineNumber": 222
          },
          {
            "text": "\t\tblueOutY + TUT_NODE_H - purpleY + 2 * TUT_GROUP_PAD,",
            "lineNumber": 223
          },
          {
            "text": "\t\t\"Node types\"",
            "lineNumber": 224
          },
          {
            "text": "\t);",
            "lineNumber": 225
          },
          {
            "text": "\tconst groupCol3 = g(",
            "lineNumber": 226
          },
          {
            "text": "\t\t\"grp-col3\",",
            "lineNumber": 227
          },
          {
            "text": "\t\tcommentLeftX(col3) - TUT_GROUP_PAD,",
            "lineNumber": 228
          },
          {
            "text": "\t\tconcatCommentY - TUT_GROUP_PAD,",
            "lineNumber": 229
          },
          {
            "text": "\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,",
            "lineNumber": 230
          },
          {
            "text": "\t\tconcatOutY + TUT_NODE_H - concatCommentY + 2 * TUT_GROUP_PAD,",
            "lineNumber": 231
          },
          {
            "text": "\t\t\"Concatenation\"",
            "lineNumber": 232
          },
          {
            "text": "\t);",
            "lineNumber": 233
          },
          {
            "text": "\tconst groupCol4 = g(",
            "lineNumber": 234
          },
          {
            "text": "\t\t\"grp-col4\",",
            "lineNumber": 235
          },
          {
            "text": "\t\tcommentLeftX(col4) - TUT_GROUP_PAD,",
            "lineNumber": 236
          },
          {
            "text": "\t\tinjectFirstY - TUT_GROUP_PAD,",
            "lineNumber": 237
          },
          {
            "text": "\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,",
            "lineNumber": 238
          },
          {
            "text": "\t\tinjectOutY + TUT_NODE_H - injectFirstY + 2 * TUT_GROUP_PAD,",
            "lineNumber": 239
          },
          {
            "text": "\t\t\"Variable injection\"",
            "lineNumber": 240
          },
          {
            "text": "\t);",
            "lineNumber": 241
          },
          {
            "text": "\tconst groupCol5 = g(",
            "lineNumber": 242
          },
          {
            "text": "\t\t\"grp-col5\",",
            "lineNumber": 243
          },
          {
            "text": "\t\tcommentLeftX(col5) - TUT_GROUP_PAD,",
            "lineNumber": 244
          },
          {
            "text": "\t\ty5 - TUT_GROUP_PAD,",
            "lineNumber": 245
          },
          {
            "text": "\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,",
            "lineNumber": 246
          },
          {
            "text": "\t\t195 + 2 * TUT_GROUP_PAD,",
            "lineNumber": 247
          },
          {
            "text": "\t\t\"How to run\"",
            "lineNumber": 248
          },
          {
            "text": "\t);",
            "lineNumber": 249
          },
          {
            "text": "\tconst groupCol6 = g(",
            "lineNumber": 250
          },
          {
            "text": "\t\t\"grp-col6\",",
            "lineNumber": 251
          },
          {
            "text": "\t\tcommentLeftX(col6) - TUT_GROUP_PAD,",
            "lineNumber": 252
          },
          {
            "text": "\t\ty6 - TUT_GROUP_PAD,",
            "lineNumber": 253
          },
          {
            "text": "\t\tTUT_COL_TOTAL_W + 2 * TUT_GROUP_PAD,",
            "lineNumber": 254
          },
          {
            "text": "\t\t145 + 2 * TUT_GROUP_PAD,",
            "lineNumber": 255
          },
          {
            "text": "\t\t\"Sidebar\"",
            "lineNumber": 256
          },
          {
            "text": "\t);",
            "lineNumber": 257
          },
          {
            "lineNumber": 258
          },
          {
            "text": "\tconst nodes: CanvasData[\"nodes\"] = [",
            "lineNumber": 259
          },
          {
            "text": "\t\t// Groups first (render behind)",
            "lineNumber": 260
          },
          {
            "text": "\t\tgroupWelcome",
            "lineNumber": 261
          },
          {
            "text": ",",
            "lineNumber": 300
          },
          {
            "text": "\t];",
            "lineNumber": 301
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.18911239504814148
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 35,
            "column": 109
          }
        },
        "contents": "import type {App} from \"obsidian\";\nimport {Notice} from \"obsidian\";\nimport {\n\tEDGE_LABEL_OUTPUT,\n\tEDGE_LABEL_PROMPT,\n\tEDGE_LABEL_THINKING,\n\tfindAuxiliaryNodeForSource,\n\tfindOutputNodeForSource,\n\tgetNodeById,\n\tgetNodeContent,\n\tgetNodeRole,\n\tgetIncomingEdgesWithLabels,\n\tgetParentIdsSortedByY,\n\tGREEN_NODE_PADDING,\n\tisAuxiliaryEdge,\n\tloadCanvasData,\n\tsaveCanvasData,\n} from \"../canvas/nodes\";\nimport type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";\nimport { getTextNodeContent, parseEdgeVariableName } from \"../canvas/types\";\nimport {isTextNode} from \"../canvas/types\";\nimport type {LiveCanvas} from \"./canvasApi\";\nimport {getKernelForCanvas} from \"./kernelManager\";\nimport {ollamaGenerate} from \"./ollama\";\nimport {\n\tgetCanvasKey,\n\tgetNodeResult,\n\tsetNodeResult,\n\tsetEdgeModes,\n\tsetRunningNodeId,\n} from \"./state\";\nimport {DEFAULT_SETTINGS, shadeColor, type NodeRole, type ZettelPluginSettings} from \"../settings\";\n\ntype EdgeInputMode = \"inject\" | \"concatenate\";\n\n/** True if the role is non-AI (Python or text pass-through); prefer running these first for early output. */",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import type {App} from \"obsidian\";",
            "lineNumber": 1
          },
          {
            "text": "import {Notice} from \"obsidian\";",
            "lineNumber": 2
          },
          {
            "text": "import {",
            "lineNumber": 3
          },
          {
            "text": "\tEDGE_LABEL_OUTPUT,",
            "lineNumber": 4
          },
          {
            "text": "\tEDGE_LABEL_PROMPT,",
            "lineNumber": 5
          },
          {
            "text": "\tEDGE_LABEL_THINKING,",
            "lineNumber": 6
          },
          {
            "text": "\tfindAuxiliaryNodeForSource,",
            "lineNumber": 7
          },
          {
            "text": "\tfindOutputNodeForSource,",
            "lineNumber": 8
          },
          {
            "text": "\tgetNodeById,",
            "lineNumber": 9
          },
          {
            "text": "\tgetNodeContent,",
            "lineNumber": 10
          },
          {
            "text": "\tgetNodeRole,",
            "lineNumber": 11
          },
          {
            "text": "\tgetIncomingEdgesWithLabels,",
            "lineNumber": 12
          },
          {
            "text": "\tgetParentIdsSortedByY,",
            "lineNumber": 13
          },
          {
            "text": "\tGREEN_NODE_PADDING,",
            "lineNumber": 14
          },
          {
            "text": "\tisAuxiliaryEdge,",
            "lineNumber": 15
          },
          {
            "text": "\tloadCanvasData,",
            "lineNumber": 16
          },
          {
            "text": "\tsaveCanvasData,",
            "lineNumber": 17
          },
          {
            "text": "} from \"../canvas/nodes\";",
            "lineNumber": 18
          },
          {
            "text": "import type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";",
            "lineNumber": 19
          },
          {
            "text": "import { getTextNodeContent, parseEdgeVariableName } from \"../canvas/types\";",
            "lineNumber": 20
          },
          {
            "text": "import {isTextNode} from \"../canvas/types\";",
            "lineNumber": 21
          },
          {
            "text": "import type {LiveCanvas} from \"./canvasApi\";",
            "lineNumber": 22
          },
          {
            "text": "import {getKernelForCanvas} from \"./kernelManager\";",
            "lineNumber": 23
          },
          {
            "text": "import {ollamaGenerate} from \"./ollama\";",
            "lineNumber": 24
          },
          {
            "text": "import {",
            "lineNumber": 25
          },
          {
            "text": "\tgetCanvasKey,",
            "lineNumber": 26
          },
          {
            "text": "\tgetNodeResult,",
            "lineNumber": 27
          },
          {
            "text": "\tsetNodeResult,",
            "lineNumber": 28
          },
          {
            "text": "\tsetEdgeModes,",
            "lineNumber": 29
          },
          {
            "text": "\tsetRunningNodeId,",
            "lineNumber": 30
          },
          {
            "text": "} from \"./state\";",
            "lineNumber": 31
          },
          {
            "text": "import {DEFAULT_SETTINGS, shadeColor, type NodeRole, type ZettelPluginSettings} from \"../settings\";",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "type EdgeInputMode = \"inject\" | \"concatenate\";",
            "lineNumber": 34,
            "isSignature": true
          },
          {
            "lineNumber": 35
          },
          {
            "text": "/** True if the role is non-AI (Python or text pass-through); prefer running these first for early output. */",
            "lineNumber": 36
          }
        ]
      },
      "score": 0.1863999366760254
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 329
          },
          "endPosition": {
            "line": 877,
            "column": 1
          }
        },
        "contents": "export default class ZettelThinkingBoardPlugin extends Plugin {\nasync onload() {\n // Track which paths we've warned about\n\t\t\tthis.registerEvent(\n\t\t\t\tthis.app.workspace.on(\"layout-change\", async () =&gt; {\n\t\t\t\t\tconst leaves = this.app.workspace.getLeavesOfType(\"canvas\");\n\t\t\t\t\tconst openPaths = new Set&lt;string&gt;();\n\t\t\t\t\tfor (const leaf of leaves) {\n\t\t\t\t\t\tconst v = leaf.view as { file?: { path: string } };\n\t\t\t\t\t\tif (v?.file?.path) openPaths.add(v.file.path);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const path of previousCanvasPaths) {\n\t\t\t\t\t\tif (!openPaths.has(path)) {\n\t\t\t\t\t\t\t// Canvas is being closed - check for output nodes\n\t\t\t\t\t\t\tif (!hasShownOutputWarningForPath.has(path)) {\n\t\t\t\t\t\t\t\tconst data = await loadCanvasData(this.app.vault, path);\n\t\t\t\t\t\t\t\tif (data &amp;&amp; hasOutputNodes(data)) {\n\t\t\t\t\t\t\t\t\t// Show reminder about output nodes\n\t\t\t\t\t\t\t\t\tnew Notice(\"Canvas has output nodes. Remember to use \\\"Dismiss all output\\\" if you want to clean up before closing.\", 5000);\n\t\t\t\t\t\t\t\t\thasShownOutputWarningForPath.add(path);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Terminate kernel\n\t\t\t\t\t\t\tterminateKernel(path);\n\t\t\t\t\t\t\t// Clear warning flag after a delay (canvas might be reopened)\n\t\t\t\t\t\t\tsetTimeout(() =&gt; {\n\t\t\t\t\t\t\t\thasShownOutputWarningForPath.delete(path);\n\t\t\t\t\t\t\t}, 60000); // Clear after 1 minute\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpreviousCanvasPaths = openPaths;\n\t\t\t\t})\n\t\t\t);\n\n\t\t\t// Floating role labels on canvas: sync when active leaf is a canvas, clear when not\n\t\t\tlet roleLabelsContainerEl: HTMLElement | null = null;\n\t\t\tlet roleLabelsIntervalId: number | null = null;\n\t\t\tconst runSyncLabels = (): void =&gt; {\n\t\t\t\tconst view = this.getActiveCanvasView();\n;\n\t}\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 330,
                "column": 1
              },
              "endPosition": {
                "line": 330,
                "column": 16
              }
            },
            {
              "startPosition": {
                "line": 330,
                "column": 16
              },
              "endPosition": {
                "line": 331,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 333,
                "column": 2
              },
              "endPosition": {
                "line": 334,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "export default class ZettelThinkingBoardPlugin extends Plugin {",
            "lineNumber": 330,
            "isSignature": true
          },
          {
            "text": "async onload() {",
            "lineNumber": 333
          },
          {
            "text": " // Track which paths we've warned about",
            "lineNumber": 493
          },
          {
            "text": "\t\t\tthis.registerEvent(",
            "lineNumber": 494
          },
          {
            "text": "\t\t\t\tthis.app.workspace.on(\"layout-change\", async () =&gt; {",
            "lineNumber": 495
          },
          {
            "text": "\t\t\t\t\tconst leaves = this.app.workspace.getLeavesOfType(\"canvas\");",
            "lineNumber": 496
          },
          {
            "text": "\t\t\t\t\tconst openPaths = new Set&lt;string&gt;();",
            "lineNumber": 497
          },
          {
            "text": "\t\t\t\t\tfor (const leaf of leaves) {",
            "lineNumber": 498
          },
          {
            "text": "\t\t\t\t\t\tconst v = leaf.view as { file?: { path: string } };",
            "lineNumber": 499
          },
          {
            "text": "\t\t\t\t\t\tif (v?.file?.path) openPaths.add(v.file.path);",
            "lineNumber": 500
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 501
          },
          {
            "text": "\t\t\t\t\tfor (const path of previousCanvasPaths) {",
            "lineNumber": 502
          },
          {
            "text": "\t\t\t\t\t\tif (!openPaths.has(path)) {",
            "lineNumber": 503
          },
          {
            "text": "\t\t\t\t\t\t\t// Canvas is being closed - check for output nodes",
            "lineNumber": 504
          },
          {
            "text": "\t\t\t\t\t\t\tif (!hasShownOutputWarningForPath.has(path)) {",
            "lineNumber": 505
          },
          {
            "text": "\t\t\t\t\t\t\t\tconst data = await loadCanvasData(this.app.vault, path);",
            "lineNumber": 506
          },
          {
            "text": "\t\t\t\t\t\t\t\tif (data &amp;&amp; hasOutputNodes(data)) {",
            "lineNumber": 507
          },
          {
            "text": "\t\t\t\t\t\t\t\t\t// Show reminder about output nodes",
            "lineNumber": 508
          },
          {
            "text": "\t\t\t\t\t\t\t\t\tnew Notice(\"Canvas has output nodes. Remember to use \\\"Dismiss all output\\\" if you want to clean up before closing.\", 5000);",
            "lineNumber": 509
          },
          {
            "text": "\t\t\t\t\t\t\t\t\thasShownOutputWarningForPath.add(path);",
            "lineNumber": 510
          },
          {
            "text": "\t\t\t\t\t\t\t\t}",
            "lineNumber": 511
          },
          {
            "text": "\t\t\t\t\t\t\t}",
            "lineNumber": 512
          },
          {
            "text": "\t\t\t\t\t\t\t// Terminate kernel",
            "lineNumber": 513
          },
          {
            "text": "\t\t\t\t\t\t\tterminateKernel(path);",
            "lineNumber": 514
          },
          {
            "text": "\t\t\t\t\t\t\t// Clear warning flag after a delay (canvas might be reopened)",
            "lineNumber": 515
          },
          {
            "text": "\t\t\t\t\t\t\tsetTimeout(() =&gt; {",
            "lineNumber": 516
          },
          {
            "text": "\t\t\t\t\t\t\t\thasShownOutputWarningForPath.delete(path);",
            "lineNumber": 517
          },
          {
            "text": "\t\t\t\t\t\t\t}, 60000); // Clear after 1 minute",
            "lineNumber": 518
          },
          {
            "text": "\t\t\t\t\t\t}",
            "lineNumber": 519
          },
          {
            "text": "\t\t\t\t\t}",
            "lineNumber": 520
          },
          {
            "text": "\t\t\t\t\tpreviousCanvasPaths = openPaths;",
            "lineNumber": 521
          },
          {
            "text": "\t\t\t\t})",
            "lineNumber": 522
          },
          {
            "text": "\t\t\t);",
            "lineNumber": 523
          },
          {
            "lineNumber": 524
          },
          {
            "text": "\t\t\t// Floating role labels on canvas: sync when active leaf is a canvas, clear when not",
            "lineNumber": 525
          },
          {
            "text": "\t\t\tlet roleLabelsContainerEl: HTMLElement | null = null;",
            "lineNumber": 526
          },
          {
            "text": "\t\t\tlet roleLabelsIntervalId: number | null = null;",
            "lineNumber": 527
          },
          {
            "text": "\t\t\tconst runSyncLabels = (): void =&gt; {",
            "lineNumber": 528
          },
          {
            "text": "\t\t\t\tconst view = this.getActiveCanvasView();",
            "lineNumber": 529
          },
          {
            "text": ";",
            "lineNumber": 588
          },
          {
            "text": "\t}",
            "lineNumber": 595
          },
          {
            "text": "}",
            "lineNumber": 878,
            "isSignature": true
          }
        ]
      },
      "score": 0.18477819859981537
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/main.ts",
        "range": {
          "startPosition": {
            "line": 97
          },
          "endPosition": {
            "line": 313,
            "column": 1
          }
        },
        "contents": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {\nconst nodes: CanvasData[\"nodes\"] = [\n TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 3\n\t\tn(lab3, \"Concatenation: no edge label → parent output appended before your prompt (then \\\"---\\\", then this card).\", commentLeftX(col3), concatCommentY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),\n\t\tn(concatComment, \"I'm input text. My full text is added to the next node's prompt.\", laneNodeX(col3, 0), concatCommentY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(concatOrange, \"Reply in one word: what did the previous card say?\", laneNodeX(col3, LANE_OFFSET), concatOrangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(concatOut, \"\", laneNodeX(col3, 0), concatOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 4\n\t\tn(lab4, \"Variable injection: put a name on the edge and use {{var:name}} in the prompt; that parent is injected there.\", commentLeftX(col4), injectFirstY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),\n\t\tn(injectFirst, \"Say exactly: Hello world.\", laneNodeX(col4, 0), injectFirstY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(injectSecond, \"They said: {{var:reply}}. Confirm in 2 words.\", laneNodeX(col4, LANE_OFFSET), injectSecondY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),\n\t\tn(injectOut, \"\", laneNodeX(col4, 0), injectOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),\n\n\t\t// Column 5 &amp; 6: plain text labels only\n\t\tn(lab5, \"How to run: Right-click a node → Run node or Run chain. Right-click empty canvas → Run entire canvas or Dismiss all output. Title bar: ▶ Run entire canvas, 🗑 Dismiss all. Commands: Open Zettel Controls; Create tutorial canvas.\", commentLeftX(col5), y5, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 195),\n\t\tn(lab6, \"Sidebar: Open Zettel Controls. There: pick Ollama models and Temperature; restart Python kernel; env vars; Console (obsidian_log in Python cards).\", commentLeftX(col6), y6, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 145),\n\t];\n\n\tconst edges: CanvasData[\"edges\"] = [\n\t\te(\"e-orange-out\", orangeNode, orangeOut, EDGE_LABEL_OUTPUT)\n,\n\t];\n}",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 98,
                "column": 1
              },
              "endPosition": {
                "line": 99,
                "column": 2
              }
            },
            {
              "startPosition": {
                "line": 259,
                "column": 2
              },
              "endPosition": {
                "line": 259,
                "column": 8
              }
            },
            {
              "startPosition": {
                "line": 259,
                "column": 8
              },
              "endPosition": {
                "line": 260,
                "column": 3
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "function getTutorialCanvasData(settings: ZettelPluginSettings): CanvasData {",
            "lineNumber": 98,
            "isSignature": true
          },
          {
            "text": "const nodes: CanvasData[\"nodes\"] = [",
            "lineNumber": 259
          },
          {
            "text": " TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 283
          },
          {
            "text": "\t\tn(blueOut, \"\", laneNodeX(col2, 0), blueOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 284
          },
          {
            "lineNumber": 285
          },
          {
            "text": "\t\t// Column 3",
            "lineNumber": 286
          },
          {
            "text": "\t\tn(lab3, \"Concatenation: no edge label → parent output appended before your prompt (then \\\"---\\\", then this card).\", commentLeftX(col3), concatCommentY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),",
            "lineNumber": 287
          },
          {
            "text": "\t\tn(concatComment, \"I'm input text. My full text is added to the next node's prompt.\", laneNodeX(col3, 0), concatCommentY, cYellow, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 288
          },
          {
            "text": "\t\tn(concatOrange, \"Reply in one word: what did the previous card say?\", laneNodeX(col3, LANE_OFFSET), concatOrangeY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 289
          },
          {
            "text": "\t\tn(concatOut, \"\", laneNodeX(col3, 0), concatOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 290
          },
          {
            "lineNumber": 291
          },
          {
            "text": "\t\t// Column 4",
            "lineNumber": 292
          },
          {
            "text": "\t\tn(lab4, \"Variable injection: put a name on the edge and use {{var:name}} in the prompt; that parent is injected there.\", commentLeftX(col4), injectFirstY, \"\", TUT_COMMENT_W, TUT_LABEL_H + 12),",
            "lineNumber": 293
          },
          {
            "text": "\t\tn(injectFirst, \"Say exactly: Hello world.\", laneNodeX(col4, 0), injectFirstY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 294
          },
          {
            "text": "\t\tn(injectSecond, \"They said: {{var:reply}}. Confirm in 2 words.\", laneNodeX(col4, LANE_OFFSET), injectSecondY, cOrange, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 295
          },
          {
            "text": "\t\tn(injectOut, \"\", laneNodeX(col4, 0), injectOutY, cGreen, TUT_NODE_LANE_W, TUT_NODE_H),",
            "lineNumber": 296
          },
          {
            "lineNumber": 297
          },
          {
            "text": "\t\t// Column 5 &amp; 6: plain text labels only",
            "lineNumber": 298
          },
          {
            "text": "\t\tn(lab5, \"How to run: Right-click a node → Run node or Run chain. Right-click empty canvas → Run entire canvas or Dismiss all output. Title bar: ▶ Run entire canvas, 🗑 Dismiss all. Commands: Open Zettel Controls; Create tutorial canvas.\", commentLeftX(col5), y5, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 195),",
            "lineNumber": 299
          },
          {
            "text": "\t\tn(lab6, \"Sidebar: Open Zettel Controls. There: pick Ollama models and Temperature; restart Python kernel; env vars; Console (obsidian_log in Python cards).\", commentLeftX(col6), y6, \"\", TUT_COMMENT_W + TUT_LANE_GAP + TUT_NODE_LANE_W, 145),",
            "lineNumber": 300
          },
          {
            "text": "\t];",
            "lineNumber": 301
          },
          {
            "lineNumber": 302
          },
          {
            "text": "\tconst edges: CanvasData[\"edges\"] = [",
            "lineNumber": 303
          },
          {
            "text": "\t\te(\"e-orange-out\", orangeNode, orangeOut, EDGE_LABEL_OUTPUT)",
            "lineNumber": 304
          },
          {
            "text": ",",
            "lineNumber": 310
          },
          {
            "text": "\t];",
            "lineNumber": 311
          },
          {
            "text": "}",
            "lineNumber": 314,
            "isSignature": true
          }
        ]
      },
      "score": 0.1812116503715515
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./src/engine/runner.ts",
        "range": {
          "startPosition": {
            "line": 669
          },
          "endPosition": {
            "line": 729,
            "column": 1
          }
        },
        "contents": "export async function runNode(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tnodeId: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\n\tconst role = getNodeRole(node, settings);\n\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };\n\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };\n\tconst parentIds = getParentIdsSortedByY(nodeId, data);\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n\tfor (const pid of parentIds) {\n\t\tif (getNodeResult(canvasKey, pid) == null) {\n\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);\n\t\t}\n\t}\n\ttry {\n\t\tsetRunningNodeId(canvasKey, nodeId);\n\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);\n\t\treturn { ok: true };\n\t} catch (e) {\n\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };\n\t} finally {\n\t\tsetRunningNodeId(canvasKey, null);\n\t}\n}\n\nconst CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";\n\n/** Run all nodes reachable from any root, in topological order. */\nexport async function runEntireCanvas(\n\tapp: App,\n\tsettings: ZettelPluginSettings,\n\tcanvasFilePath: string,\n\tliveCanvas: LiveCanvas | null\n): Promise&lt;{ ok: boolean; message?: string }&gt; {\n\tconst data = await loadCanvasData(app.vault, canvasFilePath);\n\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };\n\tconst topo = topologicalOrderFull(data, settings);\n\tif (\"cycle\" in topo) return { ok: false, message: CYCLE_ERROR_MESSAGE };\n\tconst order = topo.order;\n\tconst canvasKey = getCanvasKey(canvasFilePath);\n}",
        "signatures": {},
        "detailedLines": [
          {
            "text": "export async function runNode(",
            "lineNumber": 670,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 671,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 672,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 673,
            "isSignature": true
          },
          {
            "text": "\tnodeId: string,",
            "lineNumber": 674,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 675,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 676,
            "isSignature": true
          },
          {
            "lineNumber": 680
          },
          {
            "text": "\tconst role = getNodeRole(node, settings);",
            "lineNumber": 681
          },
          {
            "text": "\tif (!role) return { ok: false, message: \"Node color is not mapped to a role.\" };",
            "lineNumber": 682
          },
          {
            "text": "\tif (role === \"green\") return { ok: false, message: \"Green nodes are output-only.\" };",
            "lineNumber": 683
          },
          {
            "text": "\tconst parentIds = getParentIdsSortedByY(nodeId, data);",
            "lineNumber": 684
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 685
          },
          {
            "text": "\tfor (const pid of parentIds) {",
            "lineNumber": 686
          },
          {
            "text": "\t\tif (getNodeResult(canvasKey, pid) == null) {",
            "lineNumber": 687
          },
          {
            "text": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);",
            "lineNumber": 688
          },
          {
            "text": "\t\t}",
            "lineNumber": 689
          },
          {
            "text": "\t}",
            "lineNumber": 690
          },
          {
            "text": "\ttry {",
            "lineNumber": 691
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, nodeId);",
            "lineNumber": 692
          },
          {
            "text": "\t\tawait runSingleNode(app, settings, canvasKey, canvasFilePath, data, nodeId, liveCanvas);",
            "lineNumber": 693
          },
          {
            "text": "\t\treturn { ok: true };",
            "lineNumber": 694
          },
          {
            "text": "\t} catch (e) {",
            "lineNumber": 695
          },
          {
            "text": "\t\treturn { ok: false, message: e instanceof Error ? e.message : String(e) };",
            "lineNumber": 696
          },
          {
            "text": "\t} finally {",
            "lineNumber": 697
          },
          {
            "text": "\t\tsetRunningNodeId(canvasKey, null);",
            "lineNumber": 698
          },
          {
            "text": "\t}",
            "lineNumber": 699
          },
          {
            "text": "}",
            "lineNumber": 700,
            "isSignature": true
          },
          {
            "lineNumber": 701
          },
          {
            "text": "const CYCLE_ERROR_MESSAGE = \"Execution graph contains a cycle; fix connections and try again.\";",
            "lineNumber": 702
          },
          {
            "lineNumber": 703
          },
          {
            "text": "/** Run all nodes reachable from any root, in topological order. */",
            "lineNumber": 704
          },
          {
            "text": "export async function runEntireCanvas(",
            "lineNumber": 705,
            "isSignature": true
          },
          {
            "text": "\tapp: App,",
            "lineNumber": 706,
            "isSignature": true
          },
          {
            "text": "\tsettings: ZettelPluginSettings,",
            "lineNumber": 707,
            "isSignature": true
          },
          {
            "text": "\tcanvasFilePath: string,",
            "lineNumber": 708,
            "isSignature": true
          },
          {
            "text": "\tliveCanvas: LiveCanvas | null",
            "lineNumber": 709,
            "isSignature": true
          },
          {
            "text": "): Promise&lt;{ ok: boolean; message?: string }&gt; {",
            "lineNumber": 710,
            "isSignature": true
          },
          {
            "text": "\tconst data = await loadCanvasData(app.vault, canvasFilePath);",
            "lineNumber": 711
          },
          {
            "text": "\tif (!data) return { ok: false, message: \"Could not load canvas data.\" };",
            "lineNumber": 712
          },
          {
            "text": "\tconst topo = topologicalOrderFull(data, settings);",
            "lineNumber": 713
          },
          {
            "text": "\tif (\"cycle\" in topo) return { ok: false, message: CYCLE_ERROR_MESSAGE };",
            "lineNumber": 714
          },
          {
            "text": "\tconst order = topo.order;",
            "lineNumber": 715
          },
          {
            "text": "\tconst canvasKey = getCanvasKey(canvasFilePath);",
            "lineNumber": 716
          },
          {
            "text": "}",
            "lineNumber": 730,
            "isSignature": true
          }
        ]
      },
      "score": 0.18044009804725647
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "prompt.*view|PromptView",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "prompt.*view|PromptView",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "getNodeResult|setNodeResult|runChain|runOrder",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "getNodeResult|setNodeResult|runChain|runOrder",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 27,
                  "content": "\tgetNodeResult,"
                },
                {
                  "lineNumber": 28,
                  "content": "\tsetNodeResult,"
                },
                {
                  "lineNumber": 206,
                  "content": "\t\tconst r = getNodeResult(canvasKey, parentId);"
                },
                {
                  "lineNumber": 284,
                  "content": "\t\t\tsetNodeResult(canvasKey, nodeId, content);"
                },
                {
                  "lineNumber": 318,
                  "content": "\t\tsetNodeResult(canvasKey, nodeId, result.response);"
                },
                {
                  "lineNumber": 335,
                  "content": "\t\tsetNodeResult(canvasKey, nodeId, result.response);"
                },
                {
                  "lineNumber": 352,
                  "content": "\t\tsetNodeResult(canvasKey, nodeId, result.response);"
                },
                {
                  "lineNumber": 364,
                  "content": "\t\tsetNodeResult(canvasKey, nodeId, result);"
                },
                {
                  "lineNumber": 687,
                  "content": "\t\tif (getNodeResult(canvasKey, pid) == null) {"
                },
                {
                  "lineNumber": 688,
                  "content": "\t\t\treturn runChain(app, settings, canvasFilePath, nodeId, liveCanvas);"
                },
                {
                  "lineNumber": 733,
                  "content": "export async function runChain("
                }
              ]
            },
            {
              "file": "src/main.ts",
              "matches": [
                {
                  "lineNumber": 9,
                  "content": "\trunChain as runnerRunChain,"
                },
                {
                  "lineNumber": 426,
                  "content": "\t\t\t\t\titem.setTitle(\"Run chain\").setIcon(\"forward\").onClick(() =&gt; this.runChain(nodeId))"
                },
                {
                  "lineNumber": 839,
                  "content": "\tasync runChain(nodeId: string): Promise&lt;void&gt; {"
                }
              ]
            },
            {
              "file": "src/engine/state.ts",
              "matches": [
                {
                  "lineNumber": 28,
                  "content": "export function getNodeResult(canvasKey: string, nodeId: string): string | undefined {"
                },
                {
                  "lineNumber": 32,
                  "content": "export function setNodeResult(canvasKey: string, nodeId: string, result: string): void {"
                }
              ]
            },
            {
              "file": "src/engine/state.test.ts",
              "matches": [
                {
                  "lineNumber": 4,
                  "content": "\tgetNodeResult,"
                },
                {
                  "lineNumber": 5,
                  "content": "\tsetNodeResult,"
                },
                {
                  "lineNumber": 26,
                  "content": "describe(\"getNodeResult / setNodeResult\", () =&gt; {"
                },
                {
                  "lineNumber": 28,
                  "content": "\t\texpect(getNodeResult(\"/c.md\", \"node1\")).toBeUndefined();"
                },
                {
                  "lineNumber": 30,
                  "content": "\tit(\"returns set result after setNodeResult\", () =&gt; {"
                },
                {
                  "lineNumber": 31,
                  "content": "\t\tsetNodeResult(\"/c.md\", \"node1\", \"hello\");"
                },
                {
                  "lineNumber": 32,
                  "content": "\t\texpect(getNodeResult(\"/c.md\", \"node1\")).toBe(\"hello\");"
                },
                {
                  "lineNumber": 35,
                  "content": "\t\tsetNodeResult(\"/a.md\", \"n1\", \"a1\");"
                },
                {
                  "lineNumber": 36,
                  "content": "\t\tsetNodeResult(\"/b.md\", \"n1\", \"b1\");"
                },
                {
                  "lineNumber": 37,
                  "content": "\t\texpect(getNodeResult(\"/a.md\", \"n1\")).toBe(\"a1\");"
                },
                {
                  "lineNumber": 38,
                  "content": "\t\texpect(getNodeResult(\"/b.md\", \"n1\")).toBe(\"b1\");"
                },
                {
                  "lineNumber": 44,
                  "content": "\t\tsetNodeResult(\"/c.md\", \"n1\", \"x\");"
                },
                {
                  "lineNumber": 46,
                  "content": "\t\texpect(getNodeResult(\"/c.md\", \"n1\")).toBeUndefined();"
                },
                {
                  "lineNumber": 49,
                  "content": "\t\tsetNodeResult(\"/c1.md\", \"n1\", \"v1\");"
                },
                {
                  "lineNumber": 50,
                  "content": "\t\tsetNodeResult(\"/c2.md\", \"n1\", \"v2\");"
                },
                {
                  "lineNumber": 52,
                  "content": "\t\texpect(getNodeResult(\"/c2.md\", \"n1\")).toBe(\"v2\");"
                }
              ]
            }
          ],
          "totalLines": 32,
          "totalMatchedLines": 32
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---


Checking run order for the chain and whether canvas edges support connection sides:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fromSide|toSide|fromEnd|toEnd|edge.*side",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fromSide|toSide|fromEnd|toEnd|edge.*side",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "./src/canvas/types.test.ts",
              "matches": [
                {
                  "lineNumber": 114,
                  "content": "\t\t\t\t{ id: \"e1\", fromNode: \"b\", fromSide: \"bottom\", toNode: \"a\", toSide: \"top\", label: \"first\" },"
                },
                {
                  "lineNumber": 115,
                  "content": "\t\t\t\t{ id: \"e2\", fromNode: \"c\", fromSide: \"bottom\", toNode: \"a\", toSide: \"top\", label: \"second\" },"
                },
                {
                  "lineNumber": 183,
                  "content": "\t\t\t\t{ id: \"e1\", fromNode: \"b\", fromSide: \"bottom\", toNode: \"a\", toSide: \"top\" },"
                },
                {
                  "lineNumber": 184,
                  "content": "\t\t\t\t{ id: \"e2\", fromNode: \"c\", fromSide: \"bottom\", toNode: \"a\", toSide: \"top\" },"
                }
              ]
            },
            {
              "file": "./src/main.ts",
              "matches": [
                {
                  "lineNumber": 112,
                  "content": "\t\tfromSide: \"bottom\" as const,"
                },
                {
                  "lineNumber": 113,
                  "content": "\t\ttoSide: \"top\" as const,"
                }
              ]
            }
          ],
          "totalLines": 6,
          "totalMatchedLines": 6
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---


Checking canvas edge type and where prompt/thinking edges are created:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "CanvasEdgeData|fromSide|toSide",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
  "contextAfter": 0,
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "CanvasEdgeData|fromSide|toSide",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 19,
                  "content": "import type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasTextData} from \"../canvas/types\";"
                },
                {
                  "lineNumber": 109,
                  "content": "\texecEdges: CanvasEdgeData[],"
                },
                {
                  "lineNumber": 201,
                  "content": "\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[]"
                }
              ]
            },
            {
              "file": "src/canvas/types.ts",
              "matches": [
                {
                  "lineNumber": 4,
                  "content": "\tCanvasEdgeData,"
                },
                {
                  "lineNumber": 12,
                  "content": "export type {AllCanvasNodeData, CanvasData, CanvasEdgeData, CanvasFileData, CanvasNodeData, CanvasTextData};"
                },
                {
                  "lineNumber": 53,
                  "content": "export function isOutputEdge(edge: CanvasEdgeData): boolean {"
                },
                {
                  "lineNumber": 58,
                  "content": "export function isAuxiliaryEdge(edge: CanvasEdgeData): boolean {"
                },
                {
                  "lineNumber": 66,
                  "content": "\tedge: CanvasEdgeData;"
                }
              ]
            },
            {
              "file": "src/canvas/types.test.ts",
              "matches": [
                {
                  "lineNumber": 114,
                  "content": "\t\t\t\t{ id: \"e1\", fromNode: \"b\", fromSide: \"bottom\", toNode: \"a\", toSide: \"top\", label: \"first\" },"
                },
                {
                  "lineNumber": 115,
                  "content": "\t\t\t\t{ id: \"e2\", fromNode: \"c\", fromSide: \"bottom\", toNode: \"a\", toSide: \"top\", label: \"second\" },"
                },
                {
                  "lineNumber": 183,
                  "content": "\t\t\t\t{ id: \"e1\", fromNode: \"b\", fromSide: \"bottom\", toNode: \"a\", toSide: \"top\" },"
                },
                {
                  "lineNumber": 184,
                  "content": "\t\t\t\t{ id: \"e2\", fromNode: \"c\", fromSide: \"bottom\", toNode: \"a\", toSide: \"top\" },"
                }
              ]
            },
            {
              "file": "src/main.ts",
              "matches": [
                {
                  "lineNumber": 112,
                  "content": "\t\tfromSide: \"bottom\" as const,"
                },
                {
                  "lineNumber": 113,
                  "content": "\t\ttoSide: \"top\" as const,"
                }
              ]
            },
            {
              "file": "src/__mocks__/obsidian-canvas.ts",
              "matches": [
                {
                  "lineNumber": 7,
                  "content": "export const CanvasEdgeData = {};"
                }
              ]
            }
          ],
          "totalLines": 15,
          "totalMatchedLines": 15
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas/types.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---


Checking Obsidian canvas edge type and how edges are created in the runner:


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "fromSide|toSide|fromEnd|toEnd",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/node_modules/obsidian",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "fromSide|toSide|fromEnd|toEnd",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/node_modules/obsidian",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "node_modules/obsidian/canvas.d.ts",
              "matches": [
                {
                  "lineNumber": 82,
                  "content": "    fromSide?: NodeSide;"
                },
                {
                  "lineNumber": 84,
                  "content": "    fromEnd?: EdgeEnd;"
                },
                {
                  "lineNumber": 87,
                  "content": "    toSide?: NodeSide;"
                },
                {
                  "lineNumber": 89,
                  "content": "    toEnd?: EdgeEnd;"
                }
              ]
            }
          ],
          "totalLines": 4,
          "totalMatchedLines": 4
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/main.ts</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/node_modules/obsidian/canvas.d.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---


Checking for a helper that chooses edge sides and verifying the yellow-node path.


---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "getIncomingEdgesWithLabels|incoming",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "getIncomingEdgesWithLabels|incoming",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {
          "matches": [
            {
              "file": "src/engine/runner.ts",
              "matches": [
                {
                  "lineNumber": 12,
                  "content": "\tgetIncomingEdgesWithLabels,"
                },
                {
                  "lineNumber": 41,
                  "content": "/** Get all root node ids (no incoming non-auxiliary edges). */"
                },
                {
                  "lineNumber": 201,
                  "content": "\tincoming: { parentId: string; edge: CanvasEdgeData; variableName: string }[]"
                },
                {
                  "lineNumber": 205,
                  "content": "\tfor (const { parentId } of incoming) {"
                },
                {
                  "lineNumber": 211,
                  "content": "\tfor (const { parentId, edge, variableName } of incoming) {"
                },
                {
                  "lineNumber": 299,
                  "content": "\tconst incoming = getIncomingEdgesWithLabels(nodeId, data);"
                },
                {
                  "lineNumber": 304,
                  "content": "\t\tincoming"
                }
              ]
            }
          ],
          "totalLines": 7,
          "totalMatchedLines": 7
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---


Creating a plan for both issues.


---

<tool-use data-tool-type="unknown" data-tool-name="create_plan">
<details>
<summary>Tool use: **create_plan**</summary>


Parameters:

```json
{
  "plan": "# Text chain bug and prompt view node improvements\n\n## 1. Bug: Chained text nodes — first node’s text missing at AI\n\n**Cause:** In [src/engine/runner.ts](src/engine/runner.ts), yellow (text) nodes are handled as pure pass-through of their **own** content only. They never use parent results.\n\n- In &#96;runSingleNode&#96; (lines 279–286), when &#96;role === \"yellow\"&#96; the code does:\n  - &#96;content = await getNodeContent(node, app.vault)&#96; (node’s own text only)\n  - &#96;setNodeResult(canvasKey, nodeId, content)&#96;\n- So for **Text1 → Text2 → AI**: Text1’s result is stored; when Text2 runs it overwrites its result with only Text2’s text; the AI then receives only Text2’s result via &#96;buildInputWithVariables&#96; (which reads &#96;getNodeResult&#96; for each parent).\n\n**Fix:** For yellow nodes, use the same input-building logic as other roles:\n\n- Get &#96;incoming = getIncomingEdgesWithLabels(nodeId, data)&#96;.\n- Call &#96;buildInputWithVariables(canvasKey, nodeInput, incoming)&#96; to get &#96;concatenatedPart&#96; and &#96;template&#96;.\n- Form combined content the same way as the full prompt:  \n  &#96;fullContent = concatenatedPart.length &gt; 0 ? concatenatedPart + \"\\n\\n---\\n\\n\" + template : template&#96;\n- &#96;setNodeResult(canvasKey, nodeId, fullContent)&#96; and return that.\n\nThis reuses the existing helper and keeps behavior consistent with AI/Python nodes (concatenate parents + optional &#96;{{var:name}}&#96; in template). No new dependencies; only the yellow branch in &#96;runSingleNode&#96; changes.\n\n---\n\n## 2. Prompt view node: collision avoidance and edge side\n\n**Collision avoidance:** The prompt node **already** uses the same collision-avoidance logic as the output and thinking nodes. In &#96;ensureOutputNodeAndEdge&#96; (around 611–620), prompt position is chosen with:\n\n&#96;&#96;&#96;ts\nconst { x: px, y: py } = chooseOutputPositionXY(\n  data, sourceNode.id, promptId, defaultX, promptDefaultY, width, height, promptExclude\n);\n&#96;&#96;&#96;\n\nSo prompt placement already avoids overlapping other nodes (with &#96;OUTPUT_COLLISION_BUFFER&#96;, horizontal/vertical steps). If you still see overlaps, we can add a short note in comments that prompt uses this, or extend &#96;promptExclude&#96; / the search radius if a scenario is identified.\n\n**Edge connection on an unoccupied side:** Today the edges from the AI (source) node to output, prompt, and thinking are created without &#96;fromSide&#96;/&#96;toSide&#96; (e.g. 640–645, 659–664). Obsidian supports &#96;fromSide&#96;/&#96;toSide&#96; on [CanvasEdgeData](node_modules/obsidian/canvas.d.ts) (&#96;NodeSide = 'top' | 'right' | 'bottom' | 'left'&#96;).\n\n- Add a small helper in [src/engine/runner.ts](src/engine/runner.ts) that, given &#96;data&#96; and &#96;sourceNode.id&#96;, collects which sides of the source node are already used:\n  - Outgoing: &#96;e.fromNode === sourceNode.id&#96; → consider &#96;e.fromSide&#96;\n  - Incoming: &#96;e.toNode === sourceNode.id&#96; → consider &#96;e.toSide&#96;\n- Choose a side for the **prompt** (and optionally **thinking**) edge that is not the primary one for the main output. Convention: output typically uses bottom; inputs often use top. So prefer **left** or **right** for the prompt (and thinking) edge from the AI node.\n- When pushing the new prompt (and thinking) edges in &#96;ensureOutputNodeAndEdge&#96;, set &#96;fromSide&#96; (and optionally &#96;toSide&#96; on the prompt/thinking node) from this helper so the prompt connects on a free side.\n\nImplementation detail: the helper can return the first free side from a preferred order (e.g. &#96;['left','right','top','bottom']&#96; after excluding already-used sides), so the prompt/thinking edges avoid overlapping the main input/output flow.\n\n---\n\n## Summary\n\n| Item | Action |\n|------|--------|\n| Text chain bug | In &#96;runSingleNode&#96;, for yellow nodes: build combined input from parents via &#96;buildInputWithVariables&#96; and set that as the node result instead of only &#96;getNodeContent&#96;. |\n| Prompt collision | Already implemented via &#96;chooseOutputPositionXY&#96;; no code change unless a specific overlap case is found. |\n| Prompt edge side | Add a “choose free side” helper and set &#96;fromSide&#96;/&#96;toSide&#96; when creating the prompt (and optionally thinking) edges from the AI node. |\n",
  "name": "Text chain and prompt node fixes",
  "overview": "Fix the bug where chained text nodes only pass the last node's content to the AI by making yellow (text) nodes merge parent results with their own content; confirm prompt node already uses collision avoidance and add optional edge connection on an unoccupied side of the AI node."
}
```
Additional data:

```json
{
  "reviewData": {
    "status": "Requested",
    "selectedOption": "none",
    "isShowingInput": false
  },
  "planUri": "file:///Users/caffae/.cursor/plans/text_chain_and_prompt_node_fixes_7677e60a.plan.md",
  "hasOpenedEditor": true
}
```
Result:

```json
{
  "rejected": {}
}
```
Status: **completed**


</details>
</tool-use>

---

_**User**_

Implement the plan as specified, it is attached for your reference. Do NOT edit the plan file itself.

To-do's from the plan have already been created. Do not create them again. Mark them as in_progress as you work, starting with the first one. Don't stop until you have completed all the to-dos.

---

_**Agent (model default, mode Agent)**_





---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [-] Fix yellow nodes: use buildInputWithVariables for chained text
- [ ] Add choose-free-side helper and set fromSide/toSide for prompt edges

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---


Implementing the yellow-node fix: building combined input from parents and using it as the node result.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---





---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Fix yellow nodes: use buildInputWithVariables for chained text
- [-] Add choose-free-side helper and set fromSide/toSide for prompt edges

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/node_modules/obsidian/canvas.d.ts</summary>

</details>
</tool-use>

---





---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "NodeSide|from obsidian",
  "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "NodeSide|from obsidian",
    "path": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/canvas",
    "outputMode": "content",
    "workspaceResults": {
      "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board": {
        "content": {}
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>
</tool-use>

---


Adding the helper and updating edge creation. Defining a local NodeSide type for the helper:


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---


Adding fromSide/toSide when creating the thinking and prompt edges. Computing the chosen side once per block and using it for each new edge:


---

Incorrect tool arguments

---





---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts</summary>

</details>

</tool-use>

---





---

<tool-use data-tool-type="unknown" data-tool-name="read_lints">
<details>
<summary>Tool use: **read_lints**</summary>


Parameters:

```json
{
  "paths": [
    "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
  ]
}
```
Result:

```json
{
  "linterErrorsByFile": [
    {
      "relativeWorkspacePath": "/Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board/src/engine/runner.ts"
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---





---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2** • Run command: cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build</summary>

```bash
cd /Users/caffae/Notes/TestPlugin/.obsidian/plugins/Zettel-Thinking-Board && npm run build
```

```

&gt; zettel-thinking-board@1.0.5 build
&gt; tsc -noEmit -skipLibCheck &amp;&amp; node esbuild.config.mjs production


```
</details>
</tool-use>

---





---

<tool-use data-tool-type="task" data-tool-name="todo_write">
<details><summary>Tool use: **todo_write** • Todo List</summary>

- [x] Fix yellow nodes: use buildInputWithVariables for chained text
- [x] Add choose-free-side helper and set fromSide/toSide for prompt edges

</details>
</tool-use>

---


Summary of what was implemented:

**1. Text chain bug (yellow nodes)**  
In `runSingleNode`, yellow (text) nodes no longer use only their own content. They now:
- Get `incoming` via `getIncomingEdgesWithLabels`
- Call `buildInputWithVariables(canvasKey, nodeInput, incoming)` to get `concatenatedPart` and `template`
- Build `fullContent` as `concatenatedPart + "\n\n---\n\n" + template` when there are parents, otherwise `template`
- Call `setNodeResult(canvasKey, nodeId, fullContent)` and return that

So for **Text1 → Text2 → AI**, Text2’s result is the combined Text1 + Text2 content, and the AI receives that full chain.

**2. Prompt/thinking edge sides**  
- **`chooseFreeSideForAuxiliaryEdge(data, sourceNodeId)`**  
  - Collects sides already used by edges from/to the source node (`fromSide` on outgoing, `toSide` on incoming).
  - Returns the first free side from `['left', 'right', 'top', 'bottom']` so prompt/thinking prefer left/right and avoid typical input (top) and output (bottom).

- **Thinking edges**  
  When creating or ensuring the thinking edge, the new edge uses `fromSide: thinkingSide` and `toSide: oppositeSide(thinkingSide)` (left↔right, top↔bottom).

- **Prompt edges**  
  Same for the prompt edge: `fromSide: promptSide`, `toSide: promptToSide` (opposite of `promptSide`).

Prompt node placement was already using `chooseOutputPositionXY` for collision avoidance; no change there. Build completes successfully with `npm run build`.

---

